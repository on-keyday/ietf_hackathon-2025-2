// Code generated by json2go. DO NOT EDIT.
package routing

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"reflect"
)

type ProtocolNumber uint8

const (
	ProtocolNumber_Hopopt        ProtocolNumber = 0
	ProtocolNumber_Icmp          ProtocolNumber = 1
	ProtocolNumber_Igmp          ProtocolNumber = 2
	ProtocolNumber_Ggp           ProtocolNumber = 3
	ProtocolNumber_Ipv4          ProtocolNumber = 4
	ProtocolNumber_St            ProtocolNumber = 5
	ProtocolNumber_Tcp           ProtocolNumber = 6
	ProtocolNumber_Cbt           ProtocolNumber = 7
	ProtocolNumber_Egp           ProtocolNumber = 8
	ProtocolNumber_Igp           ProtocolNumber = 9
	ProtocolNumber_BbnRccMon     ProtocolNumber = 10
	ProtocolNumber_NvpIi         ProtocolNumber = 11
	ProtocolNumber_Pup           ProtocolNumber = 12
	ProtocolNumber_Argus         ProtocolNumber = 13
	ProtocolNumber_Emcon         ProtocolNumber = 14
	ProtocolNumber_Xnet          ProtocolNumber = 15
	ProtocolNumber_Chaos         ProtocolNumber = 16
	ProtocolNumber_Udp           ProtocolNumber = 17
	ProtocolNumber_Mux           ProtocolNumber = 18
	ProtocolNumber_DcnMeas       ProtocolNumber = 19
	ProtocolNumber_Hmp           ProtocolNumber = 20
	ProtocolNumber_Prm           ProtocolNumber = 21
	ProtocolNumber_XnsIdp        ProtocolNumber = 22
	ProtocolNumber_Trunk1        ProtocolNumber = 23
	ProtocolNumber_Trunk2        ProtocolNumber = 24
	ProtocolNumber_RoutingHeader ProtocolNumber = 43
	ProtocolNumber_Icmpv6        ProtocolNumber = 58
	ProtocolNumber_Ethernet      ProtocolNumber = 143
)

func (t ProtocolNumber) String() string {
	switch t {
	case ProtocolNumber_Hopopt:
		return "Hopopt"
	case ProtocolNumber_Icmp:
		return "Icmp"
	case ProtocolNumber_Igmp:
		return "Igmp"
	case ProtocolNumber_Ggp:
		return "Ggp"
	case ProtocolNumber_Ipv4:
		return "Ipv4"
	case ProtocolNumber_St:
		return "St"
	case ProtocolNumber_Tcp:
		return "Tcp"
	case ProtocolNumber_Cbt:
		return "Cbt"
	case ProtocolNumber_Egp:
		return "Egp"
	case ProtocolNumber_Igp:
		return "Igp"
	case ProtocolNumber_BbnRccMon:
		return "BbnRccMon"
	case ProtocolNumber_NvpIi:
		return "NvpIi"
	case ProtocolNumber_Pup:
		return "Pup"
	case ProtocolNumber_Argus:
		return "Argus"
	case ProtocolNumber_Emcon:
		return "Emcon"
	case ProtocolNumber_Xnet:
		return "Xnet"
	case ProtocolNumber_Chaos:
		return "Chaos"
	case ProtocolNumber_Udp:
		return "Udp"
	case ProtocolNumber_Mux:
		return "Mux"
	case ProtocolNumber_DcnMeas:
		return "DcnMeas"
	case ProtocolNumber_Hmp:
		return "Hmp"
	case ProtocolNumber_Prm:
		return "Prm"
	case ProtocolNumber_XnsIdp:
		return "XnsIdp"
	case ProtocolNumber_Trunk1:
		return "Trunk1"
	case ProtocolNumber_Trunk2:
		return "Trunk2"
	case ProtocolNumber_RoutingHeader:
		return "RoutingHeader"
	case ProtocolNumber_Icmpv6:
		return "Icmpv6"
	case ProtocolNumber_Ethernet:
		return "Ethernet"
	}
	return fmt.Sprintf("ProtocolNumber(%d)", t)
}

type Bgptype uint8

const (
	Bgptype_Open         Bgptype = 1
	Bgptype_Update       Bgptype = 2
	Bgptype_Notification Bgptype = 3
	Bgptype_Keepalive    Bgptype = 4
)

func (t Bgptype) String() string {
	switch t {
	case Bgptype_Open:
		return "Open"
	case Bgptype_Update:
		return "Update"
	case Bgptype_Notification:
		return "Notification"
	case Bgptype_Keepalive:
		return "Keepalive"
	}
	return fmt.Sprintf("Bgptype(%d)", t)
}

type EtherType uint16

const (
	EtherType_Ipv4           EtherType = 0x0800
	EtherType_Arp            EtherType = 0x0806
	EtherType_Vlan           EtherType = 0x8100
	EtherType_Ipv6           EtherType = 0x86DD
	EtherType_ServiceVlen    EtherType = 0x88A8
	EtherType_PppoeDiscovery EtherType = 0x8863
	EtherType_PppoeSession   EtherType = 0x8864
)

func (t EtherType) String() string {
	switch t {
	case EtherType_Ipv4:
		return "Ipv4"
	case EtherType_Arp:
		return "Arp"
	case EtherType_Vlan:
		return "Vlan"
	case EtherType_Ipv6:
		return "Ipv6"
	case EtherType_ServiceVlen:
		return "ServiceVlen"
	case EtherType_PppoeDiscovery:
		return "PppoeDiscovery"
	case EtherType_PppoeSession:
		return "PppoeSession"
	}
	return fmt.Sprintf("EtherType(%d)", t)
}

type Tcpstate int

const (
	Tcpstate_Closed      Tcpstate = 0
	Tcpstate_Listen      Tcpstate = 1
	Tcpstate_SynSent     Tcpstate = 2
	Tcpstate_SynRcvd     Tcpstate = 3
	Tcpstate_Established Tcpstate = 4
	Tcpstate_FinWait1    Tcpstate = 5
	Tcpstate_FinWait2    Tcpstate = 6
	Tcpstate_CloseWait   Tcpstate = 7
	Tcpstate_Closing     Tcpstate = 8
	Tcpstate_LastAck     Tcpstate = 9
	Tcpstate_TimeWait    Tcpstate = 10
)

func (t Tcpstate) String() string {
	switch t {
	case Tcpstate_Closed:
		return "Closed"
	case Tcpstate_Listen:
		return "Listen"
	case Tcpstate_SynSent:
		return "SynSent"
	case Tcpstate_SynRcvd:
		return "SynRcvd"
	case Tcpstate_Established:
		return "Established"
	case Tcpstate_FinWait1:
		return "FinWait1"
	case Tcpstate_FinWait2:
		return "FinWait2"
	case Tcpstate_CloseWait:
		return "CloseWait"
	case Tcpstate_Closing:
		return "Closing"
	case Tcpstate_LastAck:
		return "LastAck"
	case Tcpstate_TimeWait:
		return "TimeWait"
	}
	return fmt.Sprintf("Tcpstate(%d)", t)
}

type TcpoptionKind uint8

const (
	TcpoptionKind_EndOfOptionsList   TcpoptionKind = 0
	TcpoptionKind_Nop                TcpoptionKind = 1
	TcpoptionKind_MaximumSegmentSize TcpoptionKind = 2
	TcpoptionKind_WindowScale        TcpoptionKind = 3
	TcpoptionKind_SackPermitted      TcpoptionKind = 4
	TcpoptionKind_Sack               TcpoptionKind = 5
	TcpoptionKind_Timestamp          TcpoptionKind = 8
	TcpoptionKind_Mptcp              TcpoptionKind = 30
)

func (t TcpoptionKind) String() string {
	switch t {
	case TcpoptionKind_EndOfOptionsList:
		return "EndOfOptionsList"
	case TcpoptionKind_Nop:
		return "Nop"
	case TcpoptionKind_MaximumSegmentSize:
		return "MaximumSegmentSize"
	case TcpoptionKind_WindowScale:
		return "WindowScale"
	case TcpoptionKind_SackPermitted:
		return "SackPermitted"
	case TcpoptionKind_Sack:
		return "Sack"
	case TcpoptionKind_Timestamp:
		return "Timestamp"
	case TcpoptionKind_Mptcp:
		return "Mptcp"
	}
	return fmt.Sprintf("TcpoptionKind(%d)", t)
}

type union2_SegmentRoutingTlv interface {
	isunion1_()
}
type union_3_t struct {
	Len  uint8
	Data []uint8
}
type SegmentRoutingTlv struct {
	Type    uint8
	union1_ union2_SegmentRoutingTlv
}
type VisitorKEYKW interface {
	Visit(v VisitorKEYKW, name string, field any)
}
type VisitorKEYKWFunc func(v VisitorKEYKW, name string, field any)

func (f VisitorKEYKWFunc) Visit(v VisitorKEYKW, name string, field any) {
	f(v, name, field)
}

type VisitorKEYKWVisitable interface {
	Visit(v VisitorKEYKW)
}

func VisitorKEYKWToMap(v any) interface{} {
	if v == nil {
		return nil
	}
	if inter, ok := v.(VisitorKEYKWVisitable); ok {
		if p := reflect.ValueOf(inter); p.Kind() == reflect.Pointer && p.IsNil() {
			return nil
		}
		m := map[string]interface{}{}
		inter.Visit(VisitorKEYKWFunc(func(v VisitorKEYKW, name string, field any) {
			m[name] = VisitorKEYKWToMap(field)
		}))
		return m
	}
	if tf := reflect.TypeOf(v); (tf.Kind() == reflect.Slice || tf.Kind() == reflect.Array) && !(func() bool { k := tf.Elem().Kind().String(); return k[:3] == "int" || k[:3] == "uin" || k[:3] == "flo" })() {
		m := []interface{}{}
		vf := reflect.ValueOf(v)
		for i := 0; i < vf.Len(); i++ {
			index := vf.Index(i)
			if index.Kind() == reflect.Struct && index.CanAddr() {
				index = index.Addr()
			}
			m = append(m, VisitorKEYKWToMap(index.Interface()))
		}
		return m
	}
	if tf := reflect.TypeOf(v); tf.Kind() == reflect.Pointer {
		val := reflect.ValueOf(v)
		if val.IsNil() {
			return nil
		}
		return VisitorKEYKWToMap(val.Elem().Interface())
	}
	return v
}

type Ipv6Header struct {
	flags4     uint32
	PayloadLen uint16
	NextHeader ProtocolNumber
	HopLimit   uint8
	SrcAddr    [16]uint8
	DstAddr    [16]uint8
}
type Option struct {
	Type uint8
	Len  uint8
	Data []uint8
}
type WithdrawnRoutes struct {
	Len  uint16
	Data []uint8
}
type Withdrawn struct {
	Len  uint16
	Data []uint8
}
type AttributeType struct {
	flags11 uint8
	Code    uint8
}
type NetWorkReachabilityInfo struct {
	Prefixlen uint8
	Prefix    []uint8
}
type Notification struct {
	Code    uint8
	Subcode uint8
	Data    []uint8
}
type Oui struct {
	flags12 uint8
	Low     [2]uint8
}
type union14_EthernetFrame interface {
	isunion13_()
}
type union_15_t struct {
	VlanTag    uint16
	EtherType2 uint16
}
type union_16_t struct {
	ServiceVlanTag uint16
	DummyEtherType uint16
	VlanTag        uint16
	EtherType2     uint16
}
type union18_EthernetFrame interface {
	isunion17_()
}
type union_19_t struct {
	Data []uint8
}
type union_20_t struct {
	Data []uint8
}
type EthernetFrame struct {
	DstMac    [6]uint8
	SrcMac    [6]uint8
	EtherType uint16
	union13_  union14_EthernetFrame
	union17_  union18_EthernetFrame
}
type Tcpflags struct {
	flags28 uint8
}
type SackBlock struct {
	Left  uint32
	Right uint32
}
type Timestamp struct {
	Value     uint32
	EchoReply uint32
}
type SegmentRouting struct {
	NextHeader   ProtocolNumber
	HdrExtLen    uint8
	RoutingType  uint8
	SegmentsLeft uint8
	LastEntry    uint8
	Flags        uint8
	Tag          uint16
	SegmentList  [][16]uint8
	Options      []SegmentRoutingTlv
}
type Open struct {
	Version uint8
	As      uint16
	Hold    uint16
	Id      uint32
	Optlen  uint8
	Options []Option
}
type union46_PathAttribute interface {
	isunion45_()
}
type union_47_t struct {
	Len uint16
}
type union_48_t struct {
	Len uint8
}
type PathAttribute struct {
	Type     AttributeType
	union45_ union46_PathAttribute
	Data     []uint8
}
type PathAttrs struct {
	Len  uint16
	Data []PathAttribute
}
type MacAddress struct {
	Oui Oui
	Nic [3]uint8
}
type Sack struct {
	Blocks []SackBlock
}
type union57_Tcpoption interface {
	isunion56_()
}
type union_58_t struct{}
type union_59_t struct{}
type union_60_t struct {
	Length uint8
	Mss    uint16
}
type union_61_t struct {
	Length     uint8
	ShiftCount uint8
}
type union_62_t struct {
	Length uint8
}
type union_63_t struct {
	Length uint8
	Sack   Sack
}
type union_64_t struct {
	Length    uint8
	Timestamp Timestamp
}
type union_65_t struct {
	Length uint8
	Data   []uint8
}
type Tcpoption struct {
	Kind     TcpoptionKind
	union56_ union57_Tcpoption
}
type Tcpheader struct {
	SrcPort       uint16
	DstPort       uint16
	SeqNum        uint32
	AckNum        uint32
	flags71       uint8
	Flags         Tcpflags
	WindowSize    uint16
	Checksum      uint16
	UrgentPointer uint16
	Options       []Tcpoption
}
type Tcpsegment struct {
	Hdr     Tcpheader
	Payload []uint8
}
type Update struct {
	WithdrawnRoutes         WithdrawnRoutes
	PathAttr                PathAttrs
	NetworkReachabilityInfo []NetWorkReachabilityInfo
}
type union85_Bgppacket interface {
	isunion84_()
}
type union_86_t struct {
	Open Open
}
type union_87_t struct {
	Update Update
}
type union_88_t struct {
	Notification Notification
}
type union_89_t struct{}
type Bgppacket struct {
	// "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" (16 byte)
	Length   uint16
	Type     Bgptype
	union84_ union85_Bgppacket
}

func (t *union_3_t) isunion1_() {}
func (t *SegmentRoutingTlv) Data() *[]uint8 {
	if true == (t.Type != 0) {
		if _, ok := t.union1_.(*union_3_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union1_.(*union_3_t).Data)
		return &tmp
	}
	return nil
}
func (t *SegmentRoutingTlv) SetData(v []uint8) bool {
	if true == (t.Type != 0) {
		if len(v) > int(^uint8(0)) {
			return false
		}
		if _, ok := t.union1_.(*union_3_t); !ok {
			t.union1_ = &union_3_t{}
		}
		t.union1_.(*union_3_t).Len = uint8(len(v))
		t.union1_.(*union_3_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *SegmentRoutingTlv) Len() *uint8 {
	if true == (t.Type != 0) {
		if _, ok := t.union1_.(*union_3_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union1_.(*union_3_t).Len)
		return &tmp
	}
	return nil
}
func (t *SegmentRoutingTlv) SetLen(v uint8) bool {
	if true == (t.Type != 0) {
		if _, ok := t.union1_.(*union_3_t); !ok {
			t.union1_ = &union_3_t{}
		}
		t.union1_.(*union_3_t).Len = uint8(v)
		return true
	}
	return false
}
func (t *SegmentRoutingTlv) Visit(v VisitorKEYKW) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "Len", (t.Len()))
}
func (t *SegmentRoutingTlv) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *SegmentRoutingTlv) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	if t.Type != 0 {
		if _, ok := t.union1_.(*union_3_t); !ok {
			return fmt.Errorf("encode t.union1_: union is not set to union_3_t")
		}
		if n, err := w.Write([]byte{byte(t.union1_.(*union_3_t).Len)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union1_.(*union_3_t).Len: %w", err)
		}
		len_Data := int(t.union1_.(*union_3_t).Len)
		if len(t.union1_.(*union_3_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union1_.(*union_3_t).Data))
		}
		if n, err := w.Write(t.union1_.(*union_3_t).Data); err != nil || n != len(t.union1_.(*union_3_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *SegmentRoutingTlv) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SegmentRoutingTlv) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SegmentRoutingTlv) Read(r io.Reader) (err error) {
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint8(tmpType[0])
	if t.Type != 0 {
		t.union1_ = &union_3_t{}
		tmpLen := [1]byte{}
		n_Len, err := io.ReadFull(r, tmpLen[:])
		if err != nil {
			return fmt.Errorf("read Len: expect 1 byte but read %d bytes: %w", n_Len, err)
		}
		t.union1_.(*union_3_t).Len = uint8(tmpLen[0])
		len_Data := int(t.union1_.(*union_3_t).Len)
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union1_.(*union_3_t).Data = tmpData[:]
		} else {
			t.union1_.(*union_3_t).Data = nil
		}
	}
	return nil
}

func (t *SegmentRoutingTlv) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SegmentRoutingTlv) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SegmentRoutingTlv: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Ipv6Header) Version() uint32 {
	return ((t.flags4 & 0xf0000000) >> 28)
}
func (t *Ipv6Header) SetVersion(v uint32) bool {
	if v > 15 {
		return false
	}
	t.flags4 = (t.flags4 & ^uint32(0xf0000000)) | ((v & 0xf) << 28)
	return true
}
func (t *Ipv6Header) TrafficClass() uint32 {
	return ((t.flags4 & 0x0ff00000) >> 20)
}
func (t *Ipv6Header) SetTrafficClass(v uint32) bool {
	if v > 255 {
		return false
	}
	t.flags4 = (t.flags4 & ^uint32(0xff00000)) | ((v & 0xff) << 20)
	return true
}
func (t *Ipv6Header) FlowLabel() uint32 {
	return ((t.flags4 & 0x000fffff) >> 0)
}
func (t *Ipv6Header) SetFlowLabel(v uint32) bool {
	if v > 1048575 {
		return false
	}
	t.flags4 = (t.flags4 & ^uint32(0xfffff)) | ((v & 0xfffff) << 0)
	return true
}
func (t *Ipv6Header) Visit(v VisitorKEYKW) {
	v.Visit(v, "Version", t.Version())
	v.Visit(v, "TrafficClass", t.TrafficClass())
	v.Visit(v, "FlowLabel", t.FlowLabel())
	v.Visit(v, "PayloadLen", &t.PayloadLen)
	v.Visit(v, "NextHeader", &t.NextHeader)
	v.Visit(v, "HopLimit", &t.HopLimit)
	v.Visit(v, "SrcAddr", &t.SrcAddr)
	v.Visit(v, "DstAddr", &t.DstAddr)
}
func (t *Ipv6Header) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Ipv6Header) Write(w io.Writer) (err error) {
	tmp5 := [4]byte{}
	binary.BigEndian.PutUint32(tmp5[:], uint32(t.flags4))
	if n, err := w.Write(tmp5[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.flags4: %w", err)
	}
	tmp6 := [2]byte{}
	binary.BigEndian.PutUint16(tmp6[:], uint16(t.PayloadLen))
	if n, err := w.Write(tmp6[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.PayloadLen: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.NextHeader)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.NextHeader: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.HopLimit)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.HopLimit: %w", err)
	}
	if n, err := w.Write(t.SrcAddr[:]); err != nil || n != len(t.SrcAddr) {
		return fmt.Errorf("encode SrcAddr: %w", err)
	}
	if n, err := w.Write(t.DstAddr[:]); err != nil || n != len(t.DstAddr) {
		return fmt.Errorf("encode DstAddr: %w", err)
	}
	return nil
}
func (t *Ipv6Header) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 40))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Ipv6Header) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Ipv6Header) Read(r io.Reader) (err error) {
	tmpflags4 := [4]byte{}
	n_flags4, err := io.ReadFull(r, tmpflags4[:])
	if err != nil {
		return fmt.Errorf("read flags4: expect 4 bytes but read %d bytes: %w", n_flags4, err)
	}
	t.flags4 = uint32(binary.BigEndian.Uint32(tmpflags4[:]))
	tmpPayloadLen := [2]byte{}
	n_PayloadLen, err := io.ReadFull(r, tmpPayloadLen[:])
	if err != nil {
		return fmt.Errorf("read PayloadLen: expect 2 bytes but read %d bytes: %w", n_PayloadLen, err)
	}
	t.PayloadLen = uint16(binary.BigEndian.Uint16(tmpPayloadLen[:]))
	tmpNextHeader := [1]byte{}
	n_NextHeader, err := io.ReadFull(r, tmpNextHeader[:])
	if err != nil {
		return fmt.Errorf("read NextHeader: expect 1 byte but read %d bytes: %w", n_NextHeader, err)
	}
	t.NextHeader = ProtocolNumber(tmpNextHeader[0])
	tmpHopLimit := [1]byte{}
	n_HopLimit, err := io.ReadFull(r, tmpHopLimit[:])
	if err != nil {
		return fmt.Errorf("read HopLimit: expect 1 byte but read %d bytes: %w", n_HopLimit, err)
	}
	t.HopLimit = uint8(tmpHopLimit[0])
	n_SrcAddr, err := io.ReadFull(r, t.SrcAddr[:])
	if err != nil {
		return fmt.Errorf("read SrcAddr: expect %d bytes but read %d bytes: %w", 16, n_SrcAddr, err)
	}
	n_DstAddr, err := io.ReadFull(r, t.DstAddr[:])
	if err != nil {
		return fmt.Errorf("read DstAddr: expect %d bytes but read %d bytes: %w", 16, n_DstAddr, err)
	}
	return nil
}

func (t *Ipv6Header) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Ipv6Header) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Ipv6Header: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Option) SetData(v []uint8) bool {
	if len(v) > int(^uint8(0)) {
		return false
	}
	t.Len = uint8(len(v))
	t.Data = v
	return true
}
func (t *Option) Visit(v VisitorKEYKW) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Len", &t.Len)
	v.Visit(v, "Data", &t.Data)
}
func (t *Option) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Option) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Len)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Len: %w", err)
	}
	len_Data := int(t.Len)
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.Data))
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Option) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Option) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Option) Read(r io.Reader) (err error) {
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint8(tmpType[0])
	tmpLen := [1]byte{}
	n_Len, err := io.ReadFull(r, tmpLen[:])
	if err != nil {
		return fmt.Errorf("read Len: expect 1 byte but read %d bytes: %w", n_Len, err)
	}
	t.Len = uint8(tmpLen[0])
	len_Data := int(t.Len)
	if len_Data != 0 {
		tmpData := make([]byte, len_Data)
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
		}
		t.Data = tmpData[:]
	} else {
		t.Data = nil
	}
	return nil
}

func (t *Option) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Option) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Option: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *WithdrawnRoutes) Visit(v VisitorKEYKW) {
	v.Visit(v, "Len", &t.Len)
	v.Visit(v, "Data", &t.Data)
}
func (t *WithdrawnRoutes) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *WithdrawnRoutes) Write(w io.Writer) (err error) {
	tmp7 := [2]byte{}
	binary.BigEndian.PutUint16(tmp7[:], uint16(t.Len))
	if n, err := w.Write(tmp7[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Len: %w", err)
	}
	new_buf_8 := bytes.NewBuffer(nil)
	old_buf_8_w := w
	w = new_buf_8
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	if new_buf_8.Len() != int(t.Len) {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", new_buf_8.Len(), int(t.Len))
	}
	_, err = new_buf_8.WriteTo(old_buf_8_w)
	if err != nil {
		return err
	}
	w = old_buf_8_w
	return nil
}
func (t *WithdrawnRoutes) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *WithdrawnRoutes) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *WithdrawnRoutes) Read(r io.Reader) (err error) {
	tmpLen := [2]byte{}
	n_Len, err := io.ReadFull(r, tmpLen[:])
	if err != nil {
		return fmt.Errorf("read Len: expect 2 bytes but read %d bytes: %w", n_Len, err)
	}
	t.Len = uint16(binary.BigEndian.Uint16(tmpLen[:]))
	sub_byte_len_Data := int64(t.Len)
	sub_byte_r_Data := io.LimitReader(r, int64(sub_byte_len_Data))
	tmp_old_r_Data_9 := r
	r = sub_byte_r_Data
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	if sub_byte_r_Data.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Data: expect %d bytes but got %d bytes", sub_byte_len_Data, sub_byte_len_Data-sub_byte_r_Data.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Data_9
	return nil
}

func (t *WithdrawnRoutes) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *WithdrawnRoutes) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode WithdrawnRoutes: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Withdrawn) SetData(v []uint8) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.Len = uint16(len(v))
	t.Data = v
	return true
}
func (t *Withdrawn) Visit(v VisitorKEYKW) {
	v.Visit(v, "Len", &t.Len)
	v.Visit(v, "Data", &t.Data)
}
func (t *Withdrawn) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Withdrawn) Write(w io.Writer) (err error) {
	tmp10 := [2]byte{}
	binary.BigEndian.PutUint16(tmp10[:], uint16(t.Len))
	if n, err := w.Write(tmp10[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Len: %w", err)
	}
	len_Data := int(t.Len)
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.Data))
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Withdrawn) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Withdrawn) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Withdrawn) Read(r io.Reader) (err error) {
	tmpLen := [2]byte{}
	n_Len, err := io.ReadFull(r, tmpLen[:])
	if err != nil {
		return fmt.Errorf("read Len: expect 2 bytes but read %d bytes: %w", n_Len, err)
	}
	t.Len = uint16(binary.BigEndian.Uint16(tmpLen[:]))
	len_Data := int(t.Len)
	if len_Data != 0 {
		tmpData := make([]byte, len_Data)
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
		}
		t.Data = tmpData[:]
	} else {
		t.Data = nil
	}
	return nil
}

func (t *Withdrawn) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Withdrawn) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Withdrawn: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *AttributeType) Option() bool {
	return ((t.flags11 & 0x80) >> 7) == 1
}
func (t *AttributeType) SetOption(v bool) {
	if v {
		t.flags11 |= uint8(0x80)
	} else {
		t.flags11 &= ^uint8(0x80)
	}
}
func (t *AttributeType) Transitive() bool {
	return ((t.flags11 & 0x40) >> 6) == 1
}
func (t *AttributeType) SetTransitive(v bool) {
	if v {
		t.flags11 |= uint8(0x40)
	} else {
		t.flags11 &= ^uint8(0x40)
	}
}
func (t *AttributeType) Partial() bool {
	return ((t.flags11 & 0x20) >> 5) == 1
}
func (t *AttributeType) SetPartial(v bool) {
	if v {
		t.flags11 |= uint8(0x20)
	} else {
		t.flags11 &= ^uint8(0x20)
	}
}
func (t *AttributeType) Extended() bool {
	return ((t.flags11 & 0x10) >> 4) == 1
}
func (t *AttributeType) SetExtended(v bool) {
	if v {
		t.flags11 |= uint8(0x10)
	} else {
		t.flags11 &= ^uint8(0x10)
	}
}
func (t *AttributeType) Reserved() uint8 {
	return ((t.flags11 & 0x0f) >> 0)
}
func (t *AttributeType) SetReserved(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags11 = (t.flags11 & ^uint8(0xf)) | ((v & 0xf) << 0)
	return true
}
func (t *AttributeType) Visit(v VisitorKEYKW) {
	v.Visit(v, "Option", (func() uint8 {
		if t.Option() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Transitive", (func() uint8 {
		if t.Transitive() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Partial", (func() uint8 {
		if t.Partial() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Extended", (func() uint8 {
		if t.Extended() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved", t.Reserved())
	v.Visit(v, "Code", &t.Code)
}
func (t *AttributeType) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *AttributeType) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags11)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags11: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Code)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Code: %w", err)
	}
	return nil
}
func (t *AttributeType) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *AttributeType) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *AttributeType) Read(r io.Reader) (err error) {
	tmpflags11 := [1]byte{}
	n_flags11, err := io.ReadFull(r, tmpflags11[:])
	if err != nil {
		return fmt.Errorf("read flags11: expect 1 byte but read %d bytes: %w", n_flags11, err)
	}
	t.flags11 = uint8(tmpflags11[0])
	tmpCode := [1]byte{}
	n_Code, err := io.ReadFull(r, tmpCode[:])
	if err != nil {
		return fmt.Errorf("read Code: expect 1 byte but read %d bytes: %w", n_Code, err)
	}
	t.Code = uint8(tmpCode[0])
	return nil
}

func (t *AttributeType) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *AttributeType) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode AttributeType: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NetWorkReachabilityInfo) SetPrefix(v []uint8) bool {
	if len(v) > int(^uint8(0)) {
		return false
	}
	t.Prefixlen = uint8(len(v))
	t.Prefix = v
	return true
}
func (t *NetWorkReachabilityInfo) Visit(v VisitorKEYKW) {
	v.Visit(v, "Prefixlen", &t.Prefixlen)
	v.Visit(v, "Prefix", &t.Prefix)
}
func (t *NetWorkReachabilityInfo) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *NetWorkReachabilityInfo) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Prefixlen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Prefixlen: %w", err)
	}
	len_Prefix := int(t.Prefixlen)
	if len(t.Prefix) != len_Prefix {
		return fmt.Errorf("encode Prefix: expect %d bytes but got %d bytes", len_Prefix, len(t.Prefix))
	}
	if n, err := w.Write(t.Prefix); err != nil || n != len(t.Prefix) {
		return fmt.Errorf("encode Prefix: %w", err)
	}
	return nil
}
func (t *NetWorkReachabilityInfo) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NetWorkReachabilityInfo) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NetWorkReachabilityInfo) Read(r io.Reader) (err error) {
	tmpPrefixlen := [1]byte{}
	n_Prefixlen, err := io.ReadFull(r, tmpPrefixlen[:])
	if err != nil {
		return fmt.Errorf("read Prefixlen: expect 1 byte but read %d bytes: %w", n_Prefixlen, err)
	}
	t.Prefixlen = uint8(tmpPrefixlen[0])
	len_Prefix := int(t.Prefixlen)
	if len_Prefix != 0 {
		tmpPrefix := make([]byte, len_Prefix)
		n_Prefix, err := io.ReadFull(r, tmpPrefix[:])
		if err != nil {
			return fmt.Errorf("read Prefix: expect %d bytes but read %d bytes: %w", len_Prefix, n_Prefix, err)
		}
		t.Prefix = tmpPrefix[:]
	} else {
		t.Prefix = nil
	}
	return nil
}

func (t *NetWorkReachabilityInfo) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NetWorkReachabilityInfo) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NetWorkReachabilityInfo: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Notification) Visit(v VisitorKEYKW) {
	v.Visit(v, "Code", &t.Code)
	v.Visit(v, "Subcode", &t.Subcode)
	v.Visit(v, "Data", &t.Data)
}
func (t *Notification) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Notification) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Code)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Code: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Subcode)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Subcode: %w", err)
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Notification) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Notification) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Notification) Read(r io.Reader) (err error) {
	tmpCode := [1]byte{}
	n_Code, err := io.ReadFull(r, tmpCode[:])
	if err != nil {
		return fmt.Errorf("read Code: expect 1 byte but read %d bytes: %w", n_Code, err)
	}
	t.Code = uint8(tmpCode[0])
	tmpSubcode := [1]byte{}
	n_Subcode, err := io.ReadFull(r, tmpSubcode[:])
	if err != nil {
		return fmt.Errorf("read Subcode: expect 1 byte but read %d bytes: %w", n_Subcode, err)
	}
	t.Subcode = uint8(tmpSubcode[0])
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	return nil
}

func (t *Notification) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Notification) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Notification: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Oui) High() uint8 {
	return ((t.flags12 & 0xfc) >> 2)
}
func (t *Oui) SetHigh(v uint8) bool {
	if v > 63 {
		return false
	}
	t.flags12 = (t.flags12 & ^uint8(0xfc)) | ((v & 0x3f) << 2)
	return true
}
func (t *Oui) Local() bool {
	return ((t.flags12 & 0x02) >> 1) == 1
}
func (t *Oui) SetLocal(v bool) {
	if v {
		t.flags12 |= uint8(0x2)
	} else {
		t.flags12 &= ^uint8(0x2)
	}
}
func (t *Oui) Multicast() bool {
	return ((t.flags12 & 0x01) >> 0) == 1
}
func (t *Oui) SetMulticast(v bool) {
	if v {
		t.flags12 |= uint8(0x1)
	} else {
		t.flags12 &= ^uint8(0x1)
	}
}
func (t *Oui) Visit(v VisitorKEYKW) {
	v.Visit(v, "High", t.High())
	v.Visit(v, "Local", (func() uint8 {
		if t.Local() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Multicast", (func() uint8 {
		if t.Multicast() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Low", &t.Low)
}
func (t *Oui) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Oui) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags12)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags12: %w", err)
	}
	if n, err := w.Write(t.Low[:]); err != nil || n != len(t.Low) {
		return fmt.Errorf("encode Low: %w", err)
	}
	return nil
}
func (t *Oui) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 3))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Oui) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Oui) Read(r io.Reader) (err error) {
	tmpflags12 := [1]byte{}
	n_flags12, err := io.ReadFull(r, tmpflags12[:])
	if err != nil {
		return fmt.Errorf("read flags12: expect 1 byte but read %d bytes: %w", n_flags12, err)
	}
	t.flags12 = uint8(tmpflags12[0])
	n_Low, err := io.ReadFull(r, t.Low[:])
	if err != nil {
		return fmt.Errorf("read Low: expect %d bytes but read %d bytes: %w", 2, n_Low, err)
	}
	return nil
}

func (t *Oui) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Oui) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Oui: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_15_t) isunion13_() {}
func (t *union_16_t) isunion13_() {}
func (t *EthernetFrame) DummyEtherType() *uint16 {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		return nil
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union13_.(*union_16_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union13_.(*union_16_t).DummyEtherType)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetDummyEtherType(v uint16) bool {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		return false
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union13_.(*union_16_t); !ok {
			t.union13_ = &union_16_t{}
		}
		t.union13_.(*union_16_t).DummyEtherType = uint16(v)
		return true
	}
	return false
}
func (t *EthernetFrame) EtherType2() *uint16 {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		if _, ok := t.union13_.(*union_15_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union13_.(*union_15_t).EtherType2)
		return &tmp
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union13_.(*union_16_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union13_.(*union_16_t).EtherType2)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetEtherType2(v uint16) bool {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		if _, ok := t.union13_.(*union_15_t); !ok {
			t.union13_ = &union_15_t{}
		}
		t.union13_.(*union_15_t).EtherType2 = uint16(v)
		return true
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union13_.(*union_16_t); !ok {
			t.union13_ = &union_16_t{}
		}
		t.union13_.(*union_16_t).EtherType2 = uint16(v)
		return true
	}
	return false
}
func (t *EthernetFrame) ServiceVlanTag() *uint16 {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		return nil
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union13_.(*union_16_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union13_.(*union_16_t).ServiceVlanTag)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetServiceVlanTag(v uint16) bool {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		return false
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union13_.(*union_16_t); !ok {
			t.union13_ = &union_16_t{}
		}
		t.union13_.(*union_16_t).ServiceVlanTag = uint16(v)
		return true
	}
	return false
}
func (t *EthernetFrame) VlanTag() *uint16 {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		if _, ok := t.union13_.(*union_15_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union13_.(*union_15_t).VlanTag)
		return &tmp
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union13_.(*union_16_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union13_.(*union_16_t).VlanTag)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetVlanTag(v uint16) bool {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		if _, ok := t.union13_.(*union_15_t); !ok {
			t.union13_ = &union_15_t{}
		}
		t.union13_.(*union_15_t).VlanTag = uint16(v)
		return true
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union13_.(*union_16_t); !ok {
			t.union13_ = &union_16_t{}
		}
		t.union13_.(*union_16_t).VlanTag = uint16(v)
		return true
	}
	return false
}
func (t *union_19_t) isunion17_() {}
func (t *union_20_t) isunion17_() {}
func (t *EthernetFrame) Data() *[]uint8 {
	Len := (func() uint16 {
		if func() bool {
			if true == (t.EtherType == uint16(EtherType_Vlan)) {
				return true
			} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
				return true
			}
			return false
		}() {
			return uint16((*t.EtherType2()))
		} else {
			return uint16(t.EtherType)
		}
	}())
	if true == (Len >= 0x600) {
		if _, ok := t.union17_.(*union_19_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union17_.(*union_19_t).Data)
		return &tmp
	} else if true {
		if _, ok := t.union17_.(*union_20_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union17_.(*union_20_t).Data)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetData(v []uint8) bool {
	Len := (func() uint16 {
		if func() bool {
			if true == (t.EtherType == uint16(EtherType_Vlan)) {
				return true
			} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
				return true
			}
			return false
		}() {
			return uint16((*t.EtherType2()))
		} else {
			return uint16(t.EtherType)
		}
	}())
	if true == (Len >= 0x600) {
		if _, ok := t.union17_.(*union_19_t); !ok {
			t.union17_ = &union_19_t{}
		}
		t.union17_.(*union_19_t).Data = []uint8(v)
		return true
	} else if true {
		if _, ok := t.union17_.(*union_20_t); !ok {
			t.union17_ = &union_20_t{}
		}
		t.union17_.(*union_20_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *EthernetFrame) Visit(v VisitorKEYKW) {
	v.Visit(v, "DstMac", &t.DstMac)
	v.Visit(v, "SrcMac", &t.SrcMac)
	v.Visit(v, "EtherType", &t.EtherType)
	v.Visit(v, "DummyEtherType", (t.DummyEtherType()))
	v.Visit(v, "EtherType2", (t.EtherType2()))
	v.Visit(v, "ServiceVlanTag", (t.ServiceVlanTag()))
	v.Visit(v, "VlanTag", (t.VlanTag()))
	v.Visit(v, "Data", (t.Data()))
}
func (t *EthernetFrame) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *EthernetFrame) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.DstMac[:]); err != nil || n != len(t.DstMac) {
		return fmt.Errorf("encode DstMac: %w", err)
	}
	if n, err := w.Write(t.SrcMac[:]); err != nil || n != len(t.SrcMac) {
		return fmt.Errorf("encode SrcMac: %w", err)
	}
	tmp21 := [2]byte{}
	binary.BigEndian.PutUint16(tmp21[:], uint16(t.EtherType))
	if n, err := w.Write(tmp21[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.EtherType: %w", err)
	}
	if t.EtherType == uint16(EtherType_Vlan) {
		if _, ok := t.union13_.(*union_15_t); !ok {
			return fmt.Errorf("encode t.union13_: union is not set to union_15_t")
		}
		tmp22 := [2]byte{}
		binary.BigEndian.PutUint16(tmp22[:], uint16(t.union13_.(*union_15_t).VlanTag))
		if n, err := w.Write(tmp22[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union13_.(*union_15_t).VlanTag: %w", err)
		}
		tmp23 := [2]byte{}
		binary.BigEndian.PutUint16(tmp23[:], uint16(t.union13_.(*union_15_t).EtherType2))
		if n, err := w.Write(tmp23[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union13_.(*union_15_t).EtherType2: %w", err)
		}
	} else if t.EtherType == uint16(EtherType_ServiceVlen) {
		if _, ok := t.union13_.(*union_16_t); !ok {
			return fmt.Errorf("encode t.union13_: union is not set to union_16_t")
		}
		tmp24 := [2]byte{}
		binary.BigEndian.PutUint16(tmp24[:], uint16(t.union13_.(*union_16_t).ServiceVlanTag))
		if n, err := w.Write(tmp24[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union13_.(*union_16_t).ServiceVlanTag: %w", err)
		}
		tmp25 := [2]byte{}
		binary.BigEndian.PutUint16(tmp25[:], uint16(t.union13_.(*union_16_t).DummyEtherType))
		if n, err := w.Write(tmp25[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union13_.(*union_16_t).DummyEtherType: %w", err)
		}
		tmp26 := [2]byte{}
		binary.BigEndian.PutUint16(tmp26[:], uint16(t.union13_.(*union_16_t).VlanTag))
		if n, err := w.Write(tmp26[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union13_.(*union_16_t).VlanTag: %w", err)
		}
		tmp27 := [2]byte{}
		binary.BigEndian.PutUint16(tmp27[:], uint16(t.union13_.(*union_16_t).EtherType2))
		if n, err := w.Write(tmp27[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union13_.(*union_16_t).EtherType2: %w", err)
		}
	}
	Len := (func() uint16 {
		if func() bool {
			if true == (t.EtherType == uint16(EtherType_Vlan)) {
				return true
			} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
				return true
			}
			return false
		}() {
			return uint16((*t.EtherType2()))
		} else {
			return uint16(t.EtherType)
		}
	}())
	if Len >= 0x600 {
		if _, ok := t.union17_.(*union_19_t); !ok {
			return fmt.Errorf("encode t.union17_: union is not set to union_19_t")
		}
		if n, err := w.Write(t.union17_.(*union_19_t).Data); err != nil || n != len(t.union17_.(*union_19_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	} else {
		if _, ok := t.union17_.(*union_20_t); !ok {
			return fmt.Errorf("encode t.union17_: union is not set to union_20_t")
		}
		len_Data := int(Len)
		if len(t.union17_.(*union_20_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union17_.(*union_20_t).Data))
		}
		if n, err := w.Write(t.union17_.(*union_20_t).Data); err != nil || n != len(t.union17_.(*union_20_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *EthernetFrame) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 14))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *EthernetFrame) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *EthernetFrame) Read(r io.Reader) (err error) {
	n_DstMac, err := io.ReadFull(r, t.DstMac[:])
	if err != nil {
		return fmt.Errorf("read DstMac: expect %d bytes but read %d bytes: %w", 6, n_DstMac, err)
	}
	n_SrcMac, err := io.ReadFull(r, t.SrcMac[:])
	if err != nil {
		return fmt.Errorf("read SrcMac: expect %d bytes but read %d bytes: %w", 6, n_SrcMac, err)
	}
	tmpEtherType := [2]byte{}
	n_EtherType, err := io.ReadFull(r, tmpEtherType[:])
	if err != nil {
		return fmt.Errorf("read EtherType: expect 2 bytes but read %d bytes: %w", n_EtherType, err)
	}
	t.EtherType = uint16(binary.BigEndian.Uint16(tmpEtherType[:]))
	if t.EtherType == uint16(EtherType_Vlan) {
		t.union13_ = &union_15_t{}
		tmpVlanTag := [2]byte{}
		n_VlanTag, err := io.ReadFull(r, tmpVlanTag[:])
		if err != nil {
			return fmt.Errorf("read VlanTag: expect 2 bytes but read %d bytes: %w", n_VlanTag, err)
		}
		t.union13_.(*union_15_t).VlanTag = uint16(binary.BigEndian.Uint16(tmpVlanTag[:]))
		tmpEtherType2 := [2]byte{}
		n_EtherType2, err := io.ReadFull(r, tmpEtherType2[:])
		if err != nil {
			return fmt.Errorf("read EtherType2: expect 2 bytes but read %d bytes: %w", n_EtherType2, err)
		}
		t.union13_.(*union_15_t).EtherType2 = uint16(binary.BigEndian.Uint16(tmpEtherType2[:]))
	} else if t.EtherType == uint16(EtherType_ServiceVlen) {
		t.union13_ = &union_16_t{}
		tmpServiceVlanTag := [2]byte{}
		n_ServiceVlanTag, err := io.ReadFull(r, tmpServiceVlanTag[:])
		if err != nil {
			return fmt.Errorf("read ServiceVlanTag: expect 2 bytes but read %d bytes: %w", n_ServiceVlanTag, err)
		}
		t.union13_.(*union_16_t).ServiceVlanTag = uint16(binary.BigEndian.Uint16(tmpServiceVlanTag[:]))
		tmpDummyEtherType := [2]byte{}
		n_DummyEtherType, err := io.ReadFull(r, tmpDummyEtherType[:])
		if err != nil {
			return fmt.Errorf("read DummyEtherType: expect 2 bytes but read %d bytes: %w", n_DummyEtherType, err)
		}
		t.union13_.(*union_16_t).DummyEtherType = uint16(binary.BigEndian.Uint16(tmpDummyEtherType[:]))
		tmpVlanTag := [2]byte{}
		n_VlanTag, err := io.ReadFull(r, tmpVlanTag[:])
		if err != nil {
			return fmt.Errorf("read VlanTag: expect 2 bytes but read %d bytes: %w", n_VlanTag, err)
		}
		t.union13_.(*union_16_t).VlanTag = uint16(binary.BigEndian.Uint16(tmpVlanTag[:]))
		tmpEtherType2 := [2]byte{}
		n_EtherType2, err := io.ReadFull(r, tmpEtherType2[:])
		if err != nil {
			return fmt.Errorf("read EtherType2: expect 2 bytes but read %d bytes: %w", n_EtherType2, err)
		}
		t.union13_.(*union_16_t).EtherType2 = uint16(binary.BigEndian.Uint16(tmpEtherType2[:]))
	}
	Len := (func() uint16 {
		if func() bool {
			if true == (t.EtherType == uint16(EtherType_Vlan)) {
				return true
			} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
				return true
			}
			return false
		}() {
			return uint16((*t.EtherType2()))
		} else {
			return uint16(t.EtherType)
		}
	}())
	if Len >= 0x600 {
		t.union17_ = &union_19_t{}
		bytes_buf_Data := &bytes.Buffer{}
		if _, err := io.Copy(bytes_buf_Data, r); err != nil {
			return err
		}
		t.union17_.(*union_19_t).Data = bytes_buf_Data.Bytes()
	} else {
		t.union17_ = &union_20_t{}
		len_Data := int(Len)
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union17_.(*union_20_t).Data = tmpData[:]
		} else {
			t.union17_.(*union_20_t).Data = nil
		}
	}
	return nil
}

func (t *EthernetFrame) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *EthernetFrame) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode EthernetFrame: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Tcpflags) Cwr() bool {
	return ((t.flags28 & 0x80) >> 7) == 1
}
func (t *Tcpflags) SetCwr(v bool) {
	if v {
		t.flags28 |= uint8(0x80)
	} else {
		t.flags28 &= ^uint8(0x80)
	}
}
func (t *Tcpflags) Ece() bool {
	return ((t.flags28 & 0x40) >> 6) == 1
}
func (t *Tcpflags) SetEce(v bool) {
	if v {
		t.flags28 |= uint8(0x40)
	} else {
		t.flags28 &= ^uint8(0x40)
	}
}
func (t *Tcpflags) Urg() bool {
	return ((t.flags28 & 0x20) >> 5) == 1
}
func (t *Tcpflags) SetUrg(v bool) {
	if v {
		t.flags28 |= uint8(0x20)
	} else {
		t.flags28 &= ^uint8(0x20)
	}
}
func (t *Tcpflags) Ack() bool {
	return ((t.flags28 & 0x10) >> 4) == 1
}
func (t *Tcpflags) SetAck(v bool) {
	if v {
		t.flags28 |= uint8(0x10)
	} else {
		t.flags28 &= ^uint8(0x10)
	}
}
func (t *Tcpflags) Psh() bool {
	return ((t.flags28 & 0x08) >> 3) == 1
}
func (t *Tcpflags) SetPsh(v bool) {
	if v {
		t.flags28 |= uint8(0x8)
	} else {
		t.flags28 &= ^uint8(0x8)
	}
}
func (t *Tcpflags) Rst() bool {
	return ((t.flags28 & 0x04) >> 2) == 1
}
func (t *Tcpflags) SetRst(v bool) {
	if v {
		t.flags28 |= uint8(0x4)
	} else {
		t.flags28 &= ^uint8(0x4)
	}
}
func (t *Tcpflags) Syn() bool {
	return ((t.flags28 & 0x02) >> 1) == 1
}
func (t *Tcpflags) SetSyn(v bool) {
	if v {
		t.flags28 |= uint8(0x2)
	} else {
		t.flags28 &= ^uint8(0x2)
	}
}
func (t *Tcpflags) Fin() bool {
	return ((t.flags28 & 0x01) >> 0) == 1
}
func (t *Tcpflags) SetFin(v bool) {
	if v {
		t.flags28 |= uint8(0x1)
	} else {
		t.flags28 &= ^uint8(0x1)
	}
}
func (t *Tcpflags) Visit(v VisitorKEYKW) {
	v.Visit(v, "Cwr", (func() uint8 {
		if t.Cwr() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Ece", (func() uint8 {
		if t.Ece() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Urg", (func() uint8 {
		if t.Urg() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Ack", (func() uint8 {
		if t.Ack() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Psh", (func() uint8 {
		if t.Psh() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Rst", (func() uint8 {
		if t.Rst() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Syn", (func() uint8 {
		if t.Syn() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Fin", (func() uint8 {
		if t.Fin() {
			return 1
		} else {
			return 0
		}
	}()))
}
func (t *Tcpflags) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Tcpflags) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags28)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags28: %w", err)
	}
	return nil
}
func (t *Tcpflags) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Tcpflags) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Tcpflags) Read(r io.Reader) (err error) {
	tmpflags28 := [1]byte{}
	n_flags28, err := io.ReadFull(r, tmpflags28[:])
	if err != nil {
		return fmt.Errorf("read flags28: expect 1 byte but read %d bytes: %w", n_flags28, err)
	}
	t.flags28 = uint8(tmpflags28[0])
	return nil
}

func (t *Tcpflags) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Tcpflags) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Tcpflags: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SackBlock) Visit(v VisitorKEYKW) {
	v.Visit(v, "Left", &t.Left)
	v.Visit(v, "Right", &t.Right)
}
func (t *SackBlock) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *SackBlock) Write(w io.Writer) (err error) {
	tmp29 := [4]byte{}
	binary.BigEndian.PutUint32(tmp29[:], uint32(t.Left))
	if n, err := w.Write(tmp29[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Left: %w", err)
	}
	tmp30 := [4]byte{}
	binary.BigEndian.PutUint32(tmp30[:], uint32(t.Right))
	if n, err := w.Write(tmp30[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Right: %w", err)
	}
	return nil
}
func (t *SackBlock) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SackBlock) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SackBlock) Read(r io.Reader) (err error) {
	tmpLeft := [4]byte{}
	n_Left, err := io.ReadFull(r, tmpLeft[:])
	if err != nil {
		return fmt.Errorf("read Left: expect 4 bytes but read %d bytes: %w", n_Left, err)
	}
	t.Left = uint32(binary.BigEndian.Uint32(tmpLeft[:]))
	tmpRight := [4]byte{}
	n_Right, err := io.ReadFull(r, tmpRight[:])
	if err != nil {
		return fmt.Errorf("read Right: expect 4 bytes but read %d bytes: %w", n_Right, err)
	}
	t.Right = uint32(binary.BigEndian.Uint32(tmpRight[:]))
	return nil
}

func (t *SackBlock) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SackBlock) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SackBlock: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Timestamp) Visit(v VisitorKEYKW) {
	v.Visit(v, "Value", &t.Value)
	v.Visit(v, "EchoReply", &t.EchoReply)
}
func (t *Timestamp) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Timestamp) Write(w io.Writer) (err error) {
	tmp31 := [4]byte{}
	binary.BigEndian.PutUint32(tmp31[:], uint32(t.Value))
	if n, err := w.Write(tmp31[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Value: %w", err)
	}
	tmp32 := [4]byte{}
	binary.BigEndian.PutUint32(tmp32[:], uint32(t.EchoReply))
	if n, err := w.Write(tmp32[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.EchoReply: %w", err)
	}
	return nil
}
func (t *Timestamp) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Timestamp) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Timestamp) Read(r io.Reader) (err error) {
	tmpValue := [4]byte{}
	n_Value, err := io.ReadFull(r, tmpValue[:])
	if err != nil {
		return fmt.Errorf("read Value: expect 4 bytes but read %d bytes: %w", n_Value, err)
	}
	t.Value = uint32(binary.BigEndian.Uint32(tmpValue[:]))
	tmpEchoReply := [4]byte{}
	n_EchoReply, err := io.ReadFull(r, tmpEchoReply[:])
	if err != nil {
		return fmt.Errorf("read EchoReply: expect 4 bytes but read %d bytes: %w", n_EchoReply, err)
	}
	t.EchoReply = uint32(binary.BigEndian.Uint32(tmpEchoReply[:]))
	return nil
}

func (t *Timestamp) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Timestamp) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Timestamp: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SegmentRouting) SetSegmentList(v [][16]uint8) bool {
	t.SegmentList = v
	return true
}
func (t *SegmentRouting) Visit(v VisitorKEYKW) {
	v.Visit(v, "NextHeader", &t.NextHeader)
	v.Visit(v, "HdrExtLen", &t.HdrExtLen)
	v.Visit(v, "RoutingType", &t.RoutingType)
	v.Visit(v, "SegmentsLeft", &t.SegmentsLeft)
	v.Visit(v, "LastEntry", &t.LastEntry)
	v.Visit(v, "Flags", &t.Flags)
	v.Visit(v, "Tag", &t.Tag)
	v.Visit(v, "SegmentList", &t.SegmentList)
	v.Visit(v, "Options", &t.Options)
}
func (t *SegmentRouting) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *SegmentRouting) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.NextHeader)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.NextHeader: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.HdrExtLen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.HdrExtLen: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.RoutingType)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.RoutingType: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.SegmentsLeft)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.SegmentsLeft: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.LastEntry)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.LastEntry: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Flags)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Flags: %w", err)
	}
	tmp33 := [2]byte{}
	binary.BigEndian.PutUint16(tmp33[:], uint16(t.Tag))
	if n, err := w.Write(tmp33[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Tag: %w", err)
	}
	len_SegmentList := int((t.LastEntry + 1))
	if len(t.SegmentList) != len_SegmentList {
		return fmt.Errorf("encode SegmentList: expect %d but got %d for length", len_SegmentList, len(t.SegmentList))
	}
	for _, v := range t.SegmentList {
		if n, err := w.Write(v[:]); err != nil || n != len(v) {
			return fmt.Errorf("encode SegmentList: %w", err)
		}
	}
	Tmp := (uint16(t.LastEntry) + 1)
	RemainingInByte := ((uint16(t.HdrExtLen) * 8) - (Tmp * 16))
	new_buf_34 := bytes.NewBuffer(nil)
	old_buf_34_w := w
	w = new_buf_34
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	if new_buf_34.Len() != int(RemainingInByte) {
		return fmt.Errorf("encode Options: expect %d bytes but got %d bytes", new_buf_34.Len(), int(RemainingInByte))
	}
	_, err = new_buf_34.WriteTo(old_buf_34_w)
	if err != nil {
		return err
	}
	w = old_buf_34_w
	return nil
}
func (t *SegmentRouting) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SegmentRouting) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SegmentRouting) Read(r io.Reader) (err error) {
	tmpNextHeader := [1]byte{}
	n_NextHeader, err := io.ReadFull(r, tmpNextHeader[:])
	if err != nil {
		return fmt.Errorf("read NextHeader: expect 1 byte but read %d bytes: %w", n_NextHeader, err)
	}
	t.NextHeader = ProtocolNumber(tmpNextHeader[0])
	tmpHdrExtLen := [1]byte{}
	n_HdrExtLen, err := io.ReadFull(r, tmpHdrExtLen[:])
	if err != nil {
		return fmt.Errorf("read HdrExtLen: expect 1 byte but read %d bytes: %w", n_HdrExtLen, err)
	}
	t.HdrExtLen = uint8(tmpHdrExtLen[0])
	tmpRoutingType := [1]byte{}
	n_RoutingType, err := io.ReadFull(r, tmpRoutingType[:])
	if err != nil {
		return fmt.Errorf("read RoutingType: expect 1 byte but read %d bytes: %w", n_RoutingType, err)
	}
	t.RoutingType = uint8(tmpRoutingType[0])
	tmpSegmentsLeft := [1]byte{}
	n_SegmentsLeft, err := io.ReadFull(r, tmpSegmentsLeft[:])
	if err != nil {
		return fmt.Errorf("read SegmentsLeft: expect 1 byte but read %d bytes: %w", n_SegmentsLeft, err)
	}
	t.SegmentsLeft = uint8(tmpSegmentsLeft[0])
	tmpLastEntry := [1]byte{}
	n_LastEntry, err := io.ReadFull(r, tmpLastEntry[:])
	if err != nil {
		return fmt.Errorf("read LastEntry: expect 1 byte but read %d bytes: %w", n_LastEntry, err)
	}
	t.LastEntry = uint8(tmpLastEntry[0])
	tmpFlags := [1]byte{}
	n_Flags, err := io.ReadFull(r, tmpFlags[:])
	if err != nil {
		return fmt.Errorf("read Flags: expect 1 byte but read %d bytes: %w", n_Flags, err)
	}
	t.Flags = uint8(tmpFlags[0])
	tmpTag := [2]byte{}
	n_Tag, err := io.ReadFull(r, tmpTag[:])
	if err != nil {
		return fmt.Errorf("read Tag: expect 2 bytes but read %d bytes: %w", n_Tag, err)
	}
	t.Tag = uint16(binary.BigEndian.Uint16(tmpTag[:]))
	len_SegmentList := int((t.LastEntry + 1))
	for i_35 := 0; i_35 < len_SegmentList; i_35++ {
		var tmp36_ [16]uint8
		n_SegmentList, err := io.ReadFull(r, tmp36_[:])
		if err != nil {
			return fmt.Errorf("read SegmentList: expect %d bytes but read %d bytes: %w", 16, n_SegmentList, err)
		}
		t.SegmentList = append(t.SegmentList, tmp36_)
	}
	Tmp := (uint16(t.LastEntry) + 1)
	RemainingInByte := ((uint16(t.HdrExtLen) * 8) - (Tmp * 16))
	sub_byte_len_Options := int64(RemainingInByte)
	sub_byte_r_Options := io.LimitReader(r, int64(sub_byte_len_Options))
	tmp_old_r_Options_37 := r
	r = sub_byte_r_Options
	len_Options := int(r.(*io.LimitedReader).N)
	tmpOptions := make([]byte, len_Options)
	n_Options, err := io.ReadFull(r, tmpOptions[:])
	if err != nil {
		return fmt.Errorf("read Options: expect %d bytes but read %d bytes: %w", len_Options, n_Options, err)
	}
	range_tmp_Options := bytes.NewReader(tmpOptions[:])
	tmp_old_r_Options := r
	r = range_tmp_Options
	for range_tmp_Options.Len() > 0 {
		var tmp38_ SegmentRoutingTlv
		if err := tmp38_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp38_)
	}
	r = tmp_old_r_Options
	if sub_byte_r_Options.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Options: expect %d bytes but got %d bytes", sub_byte_len_Options, sub_byte_len_Options-sub_byte_r_Options.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Options_37
	return nil
}

func (t *SegmentRouting) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SegmentRouting) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SegmentRouting: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Open) Visit(v VisitorKEYKW) {
	v.Visit(v, "Version", &t.Version)
	v.Visit(v, "As", &t.As)
	v.Visit(v, "Hold", &t.Hold)
	v.Visit(v, "Id", &t.Id)
	v.Visit(v, "Optlen", &t.Optlen)
	v.Visit(v, "Options", &t.Options)
}
func (t *Open) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Open) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Version)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Version: %w", err)
	}
	tmp39 := [2]byte{}
	binary.BigEndian.PutUint16(tmp39[:], uint16(t.As))
	if n, err := w.Write(tmp39[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.As: %w", err)
	}
	tmp40 := [2]byte{}
	binary.BigEndian.PutUint16(tmp40[:], uint16(t.Hold))
	if n, err := w.Write(tmp40[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Hold: %w", err)
	}
	tmp41 := [4]byte{}
	binary.BigEndian.PutUint32(tmp41[:], uint32(t.Id))
	if n, err := w.Write(tmp41[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Id: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Optlen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Optlen: %w", err)
	}
	new_buf_42 := bytes.NewBuffer(nil)
	old_buf_42_w := w
	w = new_buf_42
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	if new_buf_42.Len() != int(t.Optlen) {
		return fmt.Errorf("encode Options: expect %d bytes but got %d bytes", new_buf_42.Len(), int(t.Optlen))
	}
	_, err = new_buf_42.WriteTo(old_buf_42_w)
	if err != nil {
		return err
	}
	w = old_buf_42_w
	return nil
}
func (t *Open) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 10))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Open) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Open) Read(r io.Reader) (err error) {
	tmpVersion := [1]byte{}
	n_Version, err := io.ReadFull(r, tmpVersion[:])
	if err != nil {
		return fmt.Errorf("read Version: expect 1 byte but read %d bytes: %w", n_Version, err)
	}
	t.Version = uint8(tmpVersion[0])
	tmpAs := [2]byte{}
	n_As, err := io.ReadFull(r, tmpAs[:])
	if err != nil {
		return fmt.Errorf("read As: expect 2 bytes but read %d bytes: %w", n_As, err)
	}
	t.As = uint16(binary.BigEndian.Uint16(tmpAs[:]))
	tmpHold := [2]byte{}
	n_Hold, err := io.ReadFull(r, tmpHold[:])
	if err != nil {
		return fmt.Errorf("read Hold: expect 2 bytes but read %d bytes: %w", n_Hold, err)
	}
	t.Hold = uint16(binary.BigEndian.Uint16(tmpHold[:]))
	tmpId := [4]byte{}
	n_Id, err := io.ReadFull(r, tmpId[:])
	if err != nil {
		return fmt.Errorf("read Id: expect 4 bytes but read %d bytes: %w", n_Id, err)
	}
	t.Id = uint32(binary.BigEndian.Uint32(tmpId[:]))
	tmpOptlen := [1]byte{}
	n_Optlen, err := io.ReadFull(r, tmpOptlen[:])
	if err != nil {
		return fmt.Errorf("read Optlen: expect 1 byte but read %d bytes: %w", n_Optlen, err)
	}
	t.Optlen = uint8(tmpOptlen[0])
	sub_byte_len_Options := int64(t.Optlen)
	sub_byte_r_Options := io.LimitReader(r, int64(sub_byte_len_Options))
	tmp_old_r_Options_43 := r
	r = sub_byte_r_Options
	len_Options := int(r.(*io.LimitedReader).N)
	tmpOptions := make([]byte, len_Options)
	n_Options, err := io.ReadFull(r, tmpOptions[:])
	if err != nil {
		return fmt.Errorf("read Options: expect %d bytes but read %d bytes: %w", len_Options, n_Options, err)
	}
	range_tmp_Options := bytes.NewReader(tmpOptions[:])
	tmp_old_r_Options := r
	r = range_tmp_Options
	for range_tmp_Options.Len() > 0 {
		var tmp44_ Option
		if err := tmp44_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp44_)
	}
	r = tmp_old_r_Options
	if sub_byte_r_Options.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Options: expect %d bytes but got %d bytes", sub_byte_len_Options, sub_byte_len_Options-sub_byte_r_Options.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Options_43
	return nil
}

func (t *Open) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Open) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Open: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_47_t) isunion45_() {}
func (t *union_48_t) isunion45_() {}
func (t *PathAttribute) Len() *uint16 {
	if true == ((func() uint8 {
		if t.Type.Extended() {
			return 1
		} else {
			return 0
		}
	}()) == 1) {
		if _, ok := t.union45_.(*union_47_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union45_.(*union_47_t).Len)
		return &tmp
	} else if true {
		if _, ok := t.union45_.(*union_48_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union45_.(*union_48_t).Len)
		return &tmp
	}
	return nil
}
func (t *PathAttribute) SetLen(v uint16) bool {
	if true == ((func() uint8 {
		if t.Type.Extended() {
			return 1
		} else {
			return 0
		}
	}()) == 1) {
		if _, ok := t.union45_.(*union_47_t); !ok {
			t.union45_ = &union_47_t{}
		}
		t.union45_.(*union_47_t).Len = uint16(v)
		return true
	} else if true {
		if v > uint16(^uint8(0)) {
			return false
		}
		if _, ok := t.union45_.(*union_48_t); !ok {
			t.union45_ = &union_48_t{}
		}
		t.union45_.(*union_48_t).Len = uint8(v)
		return true
	}
	return false
}
func (t *PathAttribute) SetData(v []uint8) bool {
	t.Data = v
	return true
}
func (t *PathAttribute) Visit(v VisitorKEYKW) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Len", (t.Len()))
	v.Visit(v, "Data", &t.Data)
}
func (t *PathAttribute) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *PathAttribute) Write(w io.Writer) (err error) {
	if err := t.Type.Write(w); err != nil {
		return fmt.Errorf("encode Type: %w", err)
	}
	if (func() uint8 {
		if t.Type.Extended() {
			return 1
		} else {
			return 0
		}
	}()) == 1 {
		if _, ok := t.union45_.(*union_47_t); !ok {
			return fmt.Errorf("encode t.union45_: union is not set to union_47_t")
		}
		tmp49 := [2]byte{}
		binary.BigEndian.PutUint16(tmp49[:], uint16(t.union45_.(*union_47_t).Len))
		if n, err := w.Write(tmp49[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union45_.(*union_47_t).Len: %w", err)
		}
	} else {
		if _, ok := t.union45_.(*union_48_t); !ok {
			return fmt.Errorf("encode t.union45_: union is not set to union_48_t")
		}
		if n, err := w.Write([]byte{byte(t.union45_.(*union_48_t).Len)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union45_.(*union_48_t).Len: %w", err)
		}
	}
	LenTmp := (*t.Len())
	len_Data := int(LenTmp)
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.Data))
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *PathAttribute) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *PathAttribute) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *PathAttribute) Read(r io.Reader) (err error) {
	if err := t.Type.Read(r); err != nil {
		return fmt.Errorf("read Type: %w", err)
	}
	if (func() uint8 {
		if t.Type.Extended() {
			return 1
		} else {
			return 0
		}
	}()) == 1 {
		t.union45_ = &union_47_t{}
		tmpLen := [2]byte{}
		n_Len, err := io.ReadFull(r, tmpLen[:])
		if err != nil {
			return fmt.Errorf("read Len: expect 2 bytes but read %d bytes: %w", n_Len, err)
		}
		t.union45_.(*union_47_t).Len = uint16(binary.BigEndian.Uint16(tmpLen[:]))
	} else {
		t.union45_ = &union_48_t{}
		tmpLen := [1]byte{}
		n_Len, err := io.ReadFull(r, tmpLen[:])
		if err != nil {
			return fmt.Errorf("read Len: expect 1 byte but read %d bytes: %w", n_Len, err)
		}
		t.union45_.(*union_48_t).Len = uint8(tmpLen[0])
	}
	LenTmp := (*t.Len())
	len_Data := int(LenTmp)
	if len_Data != 0 {
		tmpData := make([]byte, len_Data)
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
		}
		t.Data = tmpData[:]
	} else {
		t.Data = nil
	}
	return nil
}

func (t *PathAttribute) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *PathAttribute) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode PathAttribute: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *PathAttrs) Visit(v VisitorKEYKW) {
	v.Visit(v, "Len", &t.Len)
	v.Visit(v, "Data", &t.Data)
}
func (t *PathAttrs) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *PathAttrs) Write(w io.Writer) (err error) {
	tmp50 := [2]byte{}
	binary.BigEndian.PutUint16(tmp50[:], uint16(t.Len))
	if n, err := w.Write(tmp50[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Len: %w", err)
	}
	new_buf_51 := bytes.NewBuffer(nil)
	old_buf_51_w := w
	w = new_buf_51
	for _, v := range t.Data {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	if new_buf_51.Len() != int(t.Len) {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", new_buf_51.Len(), int(t.Len))
	}
	_, err = new_buf_51.WriteTo(old_buf_51_w)
	if err != nil {
		return err
	}
	w = old_buf_51_w
	return nil
}
func (t *PathAttrs) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *PathAttrs) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *PathAttrs) Read(r io.Reader) (err error) {
	tmpLen := [2]byte{}
	n_Len, err := io.ReadFull(r, tmpLen[:])
	if err != nil {
		return fmt.Errorf("read Len: expect 2 bytes but read %d bytes: %w", n_Len, err)
	}
	t.Len = uint16(binary.BigEndian.Uint16(tmpLen[:]))
	sub_byte_len_Data := int64(t.Len)
	sub_byte_r_Data := io.LimitReader(r, int64(sub_byte_len_Data))
	tmp_old_r_Data_52 := r
	r = sub_byte_r_Data
	len_Data := int(r.(*io.LimitedReader).N)
	tmpData := make([]byte, len_Data)
	n_Data, err := io.ReadFull(r, tmpData[:])
	if err != nil {
		return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
	}
	range_tmp_Data := bytes.NewReader(tmpData[:])
	tmp_old_r_Data := r
	r = range_tmp_Data
	for range_tmp_Data.Len() > 0 {
		var tmp53_ PathAttribute
		if err := tmp53_.Read(r); err != nil {
			return fmt.Errorf("read Data: %w", err)
		}
		t.Data = append(t.Data, tmp53_)
	}
	r = tmp_old_r_Data
	if sub_byte_r_Data.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Data: expect %d bytes but got %d bytes", sub_byte_len_Data, sub_byte_len_Data-sub_byte_r_Data.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Data_52
	return nil
}

func (t *PathAttrs) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *PathAttrs) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode PathAttrs: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *MacAddress) Visit(v VisitorKEYKW) {
	v.Visit(v, "Oui", &t.Oui)
	v.Visit(v, "Nic", &t.Nic)
}
func (t *MacAddress) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *MacAddress) Write(w io.Writer) (err error) {
	if err := t.Oui.Write(w); err != nil {
		return fmt.Errorf("encode Oui: %w", err)
	}
	if n, err := w.Write(t.Nic[:]); err != nil || n != len(t.Nic) {
		return fmt.Errorf("encode Nic: %w", err)
	}
	return nil
}
func (t *MacAddress) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 6))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *MacAddress) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *MacAddress) Read(r io.Reader) (err error) {
	if err := t.Oui.Read(r); err != nil {
		return fmt.Errorf("read Oui: %w", err)
	}
	n_Nic, err := io.ReadFull(r, t.Nic[:])
	if err != nil {
		return fmt.Errorf("read Nic: expect %d bytes but read %d bytes: %w", 3, n_Nic, err)
	}
	return nil
}

func (t *MacAddress) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *MacAddress) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode MacAddress: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Sack) Visit(v VisitorKEYKW) {
	v.Visit(v, "Blocks", &t.Blocks)
}
func (t *Sack) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Sack) Write(w io.Writer) (err error) {
	for _, v := range t.Blocks {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Blocks: %w", err)
		}
	}
	return nil
}
func (t *Sack) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Sack) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Sack) Read(r io.Reader) (err error) {
	tmp_byte_scanner54_ := bufio.NewReaderSize(r, 1)
	old_r_Blocks := r
	r = tmp_byte_scanner54_
	for {
		_, err := tmp_byte_scanner54_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Blocks: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner54_.UnreadByte(); err != nil {
			return fmt.Errorf("read Blocks: unexpected unread error: %w", err)
		}
		var tmp55_ SackBlock
		if err := tmp55_.Read(r); err != nil {
			return fmt.Errorf("read Blocks: %w", err)
		}
		t.Blocks = append(t.Blocks, tmp55_)
	}
	r = old_r_Blocks
	return nil
}

func (t *Sack) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Sack) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Sack: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_58_t) isunion56_() {}
func (t *union_59_t) isunion56_() {}
func (t *union_60_t) isunion56_() {}
func (t *union_61_t) isunion56_() {}
func (t *union_62_t) isunion56_() {}
func (t *union_63_t) isunion56_() {}
func (t *union_64_t) isunion56_() {}
func (t *union_65_t) isunion56_() {}
func (t *Tcpoption) Data() *[]uint8 {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return nil
	} else if t.Kind == TcpoptionKind_WindowScale {
		return nil
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return nil
	} else if t.Kind == TcpoptionKind_Sack {
		return nil
	} else if t.Kind == TcpoptionKind_Timestamp {
		return nil
	} else if true {
		if _, ok := t.union56_.(*union_65_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union56_.(*union_65_t).Data)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetData(v []uint8) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return false
	} else if t.Kind == TcpoptionKind_WindowScale {
		return false
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return false
	} else if t.Kind == TcpoptionKind_Sack {
		return false
	} else if t.Kind == TcpoptionKind_Timestamp {
		return false
	} else if true {
		if _, ok := t.union56_.(*union_65_t); !ok {
			t.union56_ = &union_65_t{}
		}
		t.union56_.(*union_65_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *Tcpoption) Length() *uint8 {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		if _, ok := t.union56_.(*union_60_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union56_.(*union_60_t).Length)
		return &tmp
	} else if t.Kind == TcpoptionKind_WindowScale {
		if _, ok := t.union56_.(*union_61_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union56_.(*union_61_t).Length)
		return &tmp
	} else if t.Kind == TcpoptionKind_SackPermitted {
		if _, ok := t.union56_.(*union_62_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union56_.(*union_62_t).Length)
		return &tmp
	} else if t.Kind == TcpoptionKind_Sack {
		if _, ok := t.union56_.(*union_63_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union56_.(*union_63_t).Length)
		return &tmp
	} else if t.Kind == TcpoptionKind_Timestamp {
		if _, ok := t.union56_.(*union_64_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union56_.(*union_64_t).Length)
		return &tmp
	} else if true {
		if _, ok := t.union56_.(*union_65_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union56_.(*union_65_t).Length)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetLength(v uint8) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		if _, ok := t.union56_.(*union_60_t); !ok {
			t.union56_ = &union_60_t{}
		}
		t.union56_.(*union_60_t).Length = uint8(v)
		return true
	} else if t.Kind == TcpoptionKind_WindowScale {
		if _, ok := t.union56_.(*union_61_t); !ok {
			t.union56_ = &union_61_t{}
		}
		t.union56_.(*union_61_t).Length = uint8(v)
		return true
	} else if t.Kind == TcpoptionKind_SackPermitted {
		if _, ok := t.union56_.(*union_62_t); !ok {
			t.union56_ = &union_62_t{}
		}
		t.union56_.(*union_62_t).Length = uint8(v)
		return true
	} else if t.Kind == TcpoptionKind_Sack {
		if _, ok := t.union56_.(*union_63_t); !ok {
			t.union56_ = &union_63_t{}
		}
		t.union56_.(*union_63_t).Length = uint8(v)
		return true
	} else if t.Kind == TcpoptionKind_Timestamp {
		if _, ok := t.union56_.(*union_64_t); !ok {
			t.union56_ = &union_64_t{}
		}
		t.union56_.(*union_64_t).Length = uint8(v)
		return true
	} else if true {
		if _, ok := t.union56_.(*union_65_t); !ok {
			t.union56_ = &union_65_t{}
		}
		t.union56_.(*union_65_t).Length = uint8(v)
		return true
	}
	return false
}
func (t *Tcpoption) Mss() *uint16 {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		if _, ok := t.union56_.(*union_60_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union56_.(*union_60_t).Mss)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetMss(v uint16) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		if _, ok := t.union56_.(*union_60_t); !ok {
			t.union56_ = &union_60_t{}
		}
		t.union56_.(*union_60_t).Mss = uint16(v)
		return true
	}
	return false
}
func (t *Tcpoption) Sack() *Sack {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return nil
	} else if t.Kind == TcpoptionKind_WindowScale {
		return nil
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return nil
	} else if t.Kind == TcpoptionKind_Sack {
		if _, ok := t.union56_.(*union_63_t); !ok {
			return nil // not set
		}
		tmp := Sack(t.union56_.(*union_63_t).Sack)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetSack(v Sack) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return false
	} else if t.Kind == TcpoptionKind_WindowScale {
		return false
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return false
	} else if t.Kind == TcpoptionKind_Sack {
		if _, ok := t.union56_.(*union_63_t); !ok {
			t.union56_ = &union_63_t{}
		}
		t.union56_.(*union_63_t).Sack = Sack(v)
		return true
	}
	return false
}
func (t *Tcpoption) ShiftCount() *uint8 {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return nil
	} else if t.Kind == TcpoptionKind_WindowScale {
		if _, ok := t.union56_.(*union_61_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union56_.(*union_61_t).ShiftCount)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetShiftCount(v uint8) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return false
	} else if t.Kind == TcpoptionKind_WindowScale {
		if _, ok := t.union56_.(*union_61_t); !ok {
			t.union56_ = &union_61_t{}
		}
		t.union56_.(*union_61_t).ShiftCount = uint8(v)
		return true
	}
	return false
}
func (t *Tcpoption) Timestamp() *Timestamp {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return nil
	} else if t.Kind == TcpoptionKind_WindowScale {
		return nil
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return nil
	} else if t.Kind == TcpoptionKind_Sack {
		return nil
	} else if t.Kind == TcpoptionKind_Timestamp {
		if _, ok := t.union56_.(*union_64_t); !ok {
			return nil // not set
		}
		tmp := Timestamp(t.union56_.(*union_64_t).Timestamp)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetTimestamp(v Timestamp) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return false
	} else if t.Kind == TcpoptionKind_WindowScale {
		return false
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return false
	} else if t.Kind == TcpoptionKind_Sack {
		return false
	} else if t.Kind == TcpoptionKind_Timestamp {
		if _, ok := t.union56_.(*union_64_t); !ok {
			t.union56_ = &union_64_t{}
		}
		t.union56_.(*union_64_t).Timestamp = Timestamp(v)
		return true
	}
	return false
}
func (t *Tcpoption) Visit(v VisitorKEYKW) {
	v.Visit(v, "Kind", &t.Kind)
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "Length", (t.Length()))
	v.Visit(v, "Mss", (t.Mss()))
	v.Visit(v, "Sack", (t.Sack()))
	v.Visit(v, "ShiftCount", (t.ShiftCount()))
	v.Visit(v, "Timestamp", (t.Timestamp()))
}
func (t *Tcpoption) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Tcpoption) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Kind)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Kind: %w", err)
	}
	switch {
	case (t.Kind == TcpoptionKind_EndOfOptionsList):
	case (t.Kind == TcpoptionKind_Nop):
	case (t.Kind == TcpoptionKind_MaximumSegmentSize):
		if _, ok := t.union56_.(*union_60_t); !ok {
			return fmt.Errorf("encode t.union56_: union is not set to union_60_t")
		}
		if n, err := w.Write([]byte{byte(t.union56_.(*union_60_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union56_.(*union_60_t).Length: %w", err)
		}
		tmp66 := [2]byte{}
		binary.BigEndian.PutUint16(tmp66[:], uint16(t.union56_.(*union_60_t).Mss))
		if n, err := w.Write(tmp66[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union56_.(*union_60_t).Mss: %w", err)
		}
	case (t.Kind == TcpoptionKind_WindowScale):
		if _, ok := t.union56_.(*union_61_t); !ok {
			return fmt.Errorf("encode t.union56_: union is not set to union_61_t")
		}
		if n, err := w.Write([]byte{byte(t.union56_.(*union_61_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union56_.(*union_61_t).Length: %w", err)
		}
		if n, err := w.Write([]byte{byte(t.union56_.(*union_61_t).ShiftCount)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union56_.(*union_61_t).ShiftCount: %w", err)
		}
	case (t.Kind == TcpoptionKind_SackPermitted):
		if _, ok := t.union56_.(*union_62_t); !ok {
			return fmt.Errorf("encode t.union56_: union is not set to union_62_t")
		}
		if n, err := w.Write([]byte{byte(t.union56_.(*union_62_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union56_.(*union_62_t).Length: %w", err)
		}
	case (t.Kind == TcpoptionKind_Sack):
		if _, ok := t.union56_.(*union_63_t); !ok {
			return fmt.Errorf("encode t.union56_: union is not set to union_63_t")
		}
		if n, err := w.Write([]byte{byte(t.union56_.(*union_63_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union56_.(*union_63_t).Length: %w", err)
		}
		new_buf_67 := bytes.NewBuffer(nil)
		old_buf_67_w := w
		w = new_buf_67
		if err := t.union56_.(*union_63_t).Sack.Write(w); err != nil {
			return fmt.Errorf("encode Sack: %w", err)
		}
		if new_buf_67.Len() != int((t.union56_.(*union_63_t).Length - 2)) {
			return fmt.Errorf("encode Sack: expect %d bytes but got %d bytes", new_buf_67.Len(), int((t.union56_.(*union_63_t).Length - 2)))
		}
		_, err = new_buf_67.WriteTo(old_buf_67_w)
		if err != nil {
			return err
		}
		w = old_buf_67_w
	case (t.Kind == TcpoptionKind_Timestamp):
		if _, ok := t.union56_.(*union_64_t); !ok {
			return fmt.Errorf("encode t.union56_: union is not set to union_64_t")
		}
		if n, err := w.Write([]byte{byte(t.union56_.(*union_64_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union56_.(*union_64_t).Length: %w", err)
		}
		new_buf_68 := bytes.NewBuffer(nil)
		old_buf_68_w := w
		w = new_buf_68
		if err := t.union56_.(*union_64_t).Timestamp.Write(w); err != nil {
			return fmt.Errorf("encode Timestamp: %w", err)
		}
		if new_buf_68.Len() != int((t.union56_.(*union_64_t).Length - 2)) {
			return fmt.Errorf("encode Timestamp: expect %d bytes but got %d bytes", new_buf_68.Len(), int((t.union56_.(*union_64_t).Length - 2)))
		}
		_, err = new_buf_68.WriteTo(old_buf_68_w)
		if err != nil {
			return err
		}
		w = old_buf_68_w
	default:
		if _, ok := t.union56_.(*union_65_t); !ok {
			return fmt.Errorf("encode t.union56_: union is not set to union_65_t")
		}
		if n, err := w.Write([]byte{byte(t.union56_.(*union_65_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union56_.(*union_65_t).Length: %w", err)
		}
		len_Data := int((t.union56_.(*union_65_t).Length - 2))
		if len(t.union56_.(*union_65_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union56_.(*union_65_t).Data))
		}
		if n, err := w.Write(t.union56_.(*union_65_t).Data); err != nil || n != len(t.union56_.(*union_65_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *Tcpoption) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Tcpoption) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Tcpoption) Read(r io.Reader) (err error) {
	tmpKind := [1]byte{}
	n_Kind, err := io.ReadFull(r, tmpKind[:])
	if err != nil {
		return fmt.Errorf("read Kind: expect 1 byte but read %d bytes: %w", n_Kind, err)
	}
	t.Kind = TcpoptionKind(tmpKind[0])
	switch {
	case (t.Kind == TcpoptionKind_EndOfOptionsList):
	case (t.Kind == TcpoptionKind_Nop):
	case (t.Kind == TcpoptionKind_MaximumSegmentSize):
		t.union56_ = &union_60_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union56_.(*union_60_t).Length = uint8(tmpLength[0])
		tmpMss := [2]byte{}
		n_Mss, err := io.ReadFull(r, tmpMss[:])
		if err != nil {
			return fmt.Errorf("read Mss: expect 2 bytes but read %d bytes: %w", n_Mss, err)
		}
		t.union56_.(*union_60_t).Mss = uint16(binary.BigEndian.Uint16(tmpMss[:]))
	case (t.Kind == TcpoptionKind_WindowScale):
		t.union56_ = &union_61_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union56_.(*union_61_t).Length = uint8(tmpLength[0])
		tmpShiftCount := [1]byte{}
		n_ShiftCount, err := io.ReadFull(r, tmpShiftCount[:])
		if err != nil {
			return fmt.Errorf("read ShiftCount: expect 1 byte but read %d bytes: %w", n_ShiftCount, err)
		}
		t.union56_.(*union_61_t).ShiftCount = uint8(tmpShiftCount[0])
	case (t.Kind == TcpoptionKind_SackPermitted):
		t.union56_ = &union_62_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union56_.(*union_62_t).Length = uint8(tmpLength[0])
	case (t.Kind == TcpoptionKind_Sack):
		t.union56_ = &union_63_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union56_.(*union_63_t).Length = uint8(tmpLength[0])
		sub_byte_len_Sack := int64((t.union56_.(*union_63_t).Length - 2))
		sub_byte_r_Sack := io.LimitReader(r, int64(sub_byte_len_Sack))
		tmp_old_r_Sack_69 := r
		r = sub_byte_r_Sack
		if err := t.union56_.(*union_63_t).Sack.Read(r); err != nil {
			return fmt.Errorf("read Sack: %w", err)
		}
		if sub_byte_r_Sack.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Sack: expect %d bytes but got %d bytes", sub_byte_len_Sack, sub_byte_len_Sack-sub_byte_r_Sack.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Sack_69
	case (t.Kind == TcpoptionKind_Timestamp):
		t.union56_ = &union_64_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union56_.(*union_64_t).Length = uint8(tmpLength[0])
		sub_byte_len_Timestamp := int64((t.union56_.(*union_64_t).Length - 2))
		sub_byte_r_Timestamp := io.LimitReader(r, int64(sub_byte_len_Timestamp))
		tmp_old_r_Timestamp_70 := r
		r = sub_byte_r_Timestamp
		if err := t.union56_.(*union_64_t).Timestamp.Read(r); err != nil {
			return fmt.Errorf("read Timestamp: %w", err)
		}
		if sub_byte_r_Timestamp.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Timestamp: expect %d bytes but got %d bytes", sub_byte_len_Timestamp, sub_byte_len_Timestamp-sub_byte_r_Timestamp.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Timestamp_70
	default:
		t.union56_ = &union_65_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union56_.(*union_65_t).Length = uint8(tmpLength[0])
		len_Data := int((t.union56_.(*union_65_t).Length - 2))
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union56_.(*union_65_t).Data = tmpData[:]
		} else {
			t.union56_.(*union_65_t).Data = nil
		}
	}
	return nil
}

func (t *Tcpoption) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Tcpoption) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Tcpoption: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Tcpheader) DataOffset() uint8 {
	return ((t.flags71 & 0xf0) >> 4)
}
func (t *Tcpheader) SetDataOffset(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags71 = (t.flags71 & ^uint8(0xf0)) | ((v & 0xf) << 4)
	return true
}
func (t *Tcpheader) Reserved() uint8 {
	return ((t.flags71 & 0x0f) >> 0)
}
func (t *Tcpheader) SetReserved(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags71 = (t.flags71 & ^uint8(0xf)) | ((v & 0xf) << 0)
	return true
}
func (t *Tcpheader) Visit(v VisitorKEYKW) {
	v.Visit(v, "SrcPort", &t.SrcPort)
	v.Visit(v, "DstPort", &t.DstPort)
	v.Visit(v, "SeqNum", &t.SeqNum)
	v.Visit(v, "AckNum", &t.AckNum)
	v.Visit(v, "DataOffset", t.DataOffset())
	v.Visit(v, "Reserved", t.Reserved())
	v.Visit(v, "Flags", &t.Flags)
	v.Visit(v, "WindowSize", &t.WindowSize)
	v.Visit(v, "Checksum", &t.Checksum)
	v.Visit(v, "UrgentPointer", &t.UrgentPointer)
	v.Visit(v, "Options", &t.Options)
}
func (t *Tcpheader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Tcpheader) Write(w io.Writer) (err error) {
	tmp72 := [2]byte{}
	binary.BigEndian.PutUint16(tmp72[:], uint16(t.SrcPort))
	if n, err := w.Write(tmp72[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.SrcPort: %w", err)
	}
	tmp73 := [2]byte{}
	binary.BigEndian.PutUint16(tmp73[:], uint16(t.DstPort))
	if n, err := w.Write(tmp73[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.DstPort: %w", err)
	}
	tmp74 := [4]byte{}
	binary.BigEndian.PutUint32(tmp74[:], uint32(t.SeqNum))
	if n, err := w.Write(tmp74[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.SeqNum: %w", err)
	}
	tmp75 := [4]byte{}
	binary.BigEndian.PutUint32(tmp75[:], uint32(t.AckNum))
	if n, err := w.Write(tmp75[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.AckNum: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags71)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags71: %w", err)
	}
	if err := t.Flags.Write(w); err != nil {
		return fmt.Errorf("encode Flags: %w", err)
	}
	tmp76 := [2]byte{}
	binary.BigEndian.PutUint16(tmp76[:], uint16(t.WindowSize))
	if n, err := w.Write(tmp76[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.WindowSize: %w", err)
	}
	tmp77 := [2]byte{}
	binary.BigEndian.PutUint16(tmp77[:], uint16(t.Checksum))
	if n, err := w.Write(tmp77[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Checksum: %w", err)
	}
	tmp78 := [2]byte{}
	binary.BigEndian.PutUint16(tmp78[:], uint16(t.UrgentPointer))
	if n, err := w.Write(tmp78[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.UrgentPointer: %w", err)
	}
	new_buf_79 := bytes.NewBuffer(nil)
	old_buf_79_w := w
	w = new_buf_79
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	if new_buf_79.Len() != int((uint8((t.DataOffset() * 4)) - 20)) {
		return fmt.Errorf("encode Options: expect %d bytes but got %d bytes", new_buf_79.Len(), int((uint8((t.DataOffset() * 4)) - 20)))
	}
	_, err = new_buf_79.WriteTo(old_buf_79_w)
	if err != nil {
		return err
	}
	w = old_buf_79_w
	return nil
}
func (t *Tcpheader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 20))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Tcpheader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Tcpheader) Read(r io.Reader) (err error) {
	tmpSrcPort := [2]byte{}
	n_SrcPort, err := io.ReadFull(r, tmpSrcPort[:])
	if err != nil {
		return fmt.Errorf("read SrcPort: expect 2 bytes but read %d bytes: %w", n_SrcPort, err)
	}
	t.SrcPort = uint16(binary.BigEndian.Uint16(tmpSrcPort[:]))
	tmpDstPort := [2]byte{}
	n_DstPort, err := io.ReadFull(r, tmpDstPort[:])
	if err != nil {
		return fmt.Errorf("read DstPort: expect 2 bytes but read %d bytes: %w", n_DstPort, err)
	}
	t.DstPort = uint16(binary.BigEndian.Uint16(tmpDstPort[:]))
	tmpSeqNum := [4]byte{}
	n_SeqNum, err := io.ReadFull(r, tmpSeqNum[:])
	if err != nil {
		return fmt.Errorf("read SeqNum: expect 4 bytes but read %d bytes: %w", n_SeqNum, err)
	}
	t.SeqNum = uint32(binary.BigEndian.Uint32(tmpSeqNum[:]))
	tmpAckNum := [4]byte{}
	n_AckNum, err := io.ReadFull(r, tmpAckNum[:])
	if err != nil {
		return fmt.Errorf("read AckNum: expect 4 bytes but read %d bytes: %w", n_AckNum, err)
	}
	t.AckNum = uint32(binary.BigEndian.Uint32(tmpAckNum[:]))
	tmpflags71 := [1]byte{}
	n_flags71, err := io.ReadFull(r, tmpflags71[:])
	if err != nil {
		return fmt.Errorf("read flags71: expect 1 byte but read %d bytes: %w", n_flags71, err)
	}
	t.flags71 = uint8(tmpflags71[0])
	if err := t.Flags.Read(r); err != nil {
		return fmt.Errorf("read Flags: %w", err)
	}
	tmpWindowSize := [2]byte{}
	n_WindowSize, err := io.ReadFull(r, tmpWindowSize[:])
	if err != nil {
		return fmt.Errorf("read WindowSize: expect 2 bytes but read %d bytes: %w", n_WindowSize, err)
	}
	t.WindowSize = uint16(binary.BigEndian.Uint16(tmpWindowSize[:]))
	tmpChecksum := [2]byte{}
	n_Checksum, err := io.ReadFull(r, tmpChecksum[:])
	if err != nil {
		return fmt.Errorf("read Checksum: expect 2 bytes but read %d bytes: %w", n_Checksum, err)
	}
	t.Checksum = uint16(binary.BigEndian.Uint16(tmpChecksum[:]))
	tmpUrgentPointer := [2]byte{}
	n_UrgentPointer, err := io.ReadFull(r, tmpUrgentPointer[:])
	if err != nil {
		return fmt.Errorf("read UrgentPointer: expect 2 bytes but read %d bytes: %w", n_UrgentPointer, err)
	}
	t.UrgentPointer = uint16(binary.BigEndian.Uint16(tmpUrgentPointer[:]))
	sub_byte_len_Options := int64((uint8((t.DataOffset() * 4)) - 20))
	sub_byte_r_Options := io.LimitReader(r, int64(sub_byte_len_Options))
	tmp_old_r_Options_80 := r
	r = sub_byte_r_Options
	len_Options := int(r.(*io.LimitedReader).N)
	tmpOptions := make([]byte, len_Options)
	n_Options, err := io.ReadFull(r, tmpOptions[:])
	if err != nil {
		return fmt.Errorf("read Options: expect %d bytes but read %d bytes: %w", len_Options, n_Options, err)
	}
	range_tmp_Options := bytes.NewReader(tmpOptions[:])
	tmp_old_r_Options := r
	r = range_tmp_Options
	for range_tmp_Options.Len() > 0 {
		var tmp81_ Tcpoption
		if err := tmp81_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp81_)
	}
	r = tmp_old_r_Options
	if sub_byte_r_Options.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Options: expect %d bytes but got %d bytes", sub_byte_len_Options, sub_byte_len_Options-sub_byte_r_Options.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Options_80
	return nil
}

func (t *Tcpheader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Tcpheader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Tcpheader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Tcpsegment) Visit(v VisitorKEYKW) {
	v.Visit(v, "Hdr", &t.Hdr)
	v.Visit(v, "Payload", &t.Payload)
}
func (t *Tcpsegment) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Tcpsegment) Write(w io.Writer) (err error) {
	if err := t.Hdr.Write(w); err != nil {
		return fmt.Errorf("encode Hdr: %w", err)
	}
	if n, err := w.Write(t.Payload); err != nil || n != len(t.Payload) {
		return fmt.Errorf("encode Payload: %w", err)
	}
	return nil
}
func (t *Tcpsegment) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Tcpsegment) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Tcpsegment) Read(r io.Reader) (err error) {
	if err := t.Hdr.Read(r); err != nil {
		return fmt.Errorf("read Hdr: %w", err)
	}
	bytes_buf_Payload := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Payload, r); err != nil {
		return err
	}
	t.Payload = bytes_buf_Payload.Bytes()
	return nil
}

func (t *Tcpsegment) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Tcpsegment) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Tcpsegment: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Update) Visit(v VisitorKEYKW) {
	v.Visit(v, "WithdrawnRoutes", &t.WithdrawnRoutes)
	v.Visit(v, "PathAttr", &t.PathAttr)
	v.Visit(v, "NetworkReachabilityInfo", &t.NetworkReachabilityInfo)
}
func (t *Update) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Update) Write(w io.Writer) (err error) {
	if err := t.WithdrawnRoutes.Write(w); err != nil {
		return fmt.Errorf("encode WithdrawnRoutes: %w", err)
	}
	if err := t.PathAttr.Write(w); err != nil {
		return fmt.Errorf("encode PathAttr: %w", err)
	}
	for _, v := range t.NetworkReachabilityInfo {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode NetworkReachabilityInfo: %w", err)
		}
	}
	return nil
}
func (t *Update) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Update) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Update) Read(r io.Reader) (err error) {
	if err := t.WithdrawnRoutes.Read(r); err != nil {
		return fmt.Errorf("read WithdrawnRoutes: %w", err)
	}
	if err := t.PathAttr.Read(r); err != nil {
		return fmt.Errorf("read PathAttr: %w", err)
	}
	tmp_byte_scanner82_ := bufio.NewReaderSize(r, 1)
	old_r_NetworkReachabilityInfo := r
	r = tmp_byte_scanner82_
	for {
		_, err := tmp_byte_scanner82_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read NetworkReachabilityInfo: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner82_.UnreadByte(); err != nil {
			return fmt.Errorf("read NetworkReachabilityInfo: unexpected unread error: %w", err)
		}
		var tmp83_ NetWorkReachabilityInfo
		if err := tmp83_.Read(r); err != nil {
			return fmt.Errorf("read NetworkReachabilityInfo: %w", err)
		}
		t.NetworkReachabilityInfo = append(t.NetworkReachabilityInfo, tmp83_)
	}
	r = old_r_NetworkReachabilityInfo
	return nil
}

func (t *Update) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Update) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Update: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_86_t) isunion84_() {}
func (t *union_87_t) isunion84_() {}
func (t *union_88_t) isunion84_() {}
func (t *union_89_t) isunion84_() {}
func (t *Bgppacket) Notification() *Notification {
	if t.Type == Bgptype_Open {
		return nil
	} else if t.Type == Bgptype_Update {
		return nil
	} else if t.Type == Bgptype_Notification {
		if _, ok := t.union84_.(*union_88_t); !ok {
			return nil // not set
		}
		tmp := Notification(t.union84_.(*union_88_t).Notification)
		return &tmp
	}
	return nil
}
func (t *Bgppacket) SetNotification(v Notification) bool {
	if t.Type == Bgptype_Open {
		return false
	} else if t.Type == Bgptype_Update {
		return false
	} else if t.Type == Bgptype_Notification {
		if _, ok := t.union84_.(*union_88_t); !ok {
			t.union84_ = &union_88_t{}
		}
		t.union84_.(*union_88_t).Notification = Notification(v)
		return true
	}
	return false
}
func (t *Bgppacket) Open() *Open {
	if t.Type == Bgptype_Open {
		if _, ok := t.union84_.(*union_86_t); !ok {
			return nil // not set
		}
		tmp := Open(t.union84_.(*union_86_t).Open)
		return &tmp
	}
	return nil
}
func (t *Bgppacket) SetOpen(v Open) bool {
	if t.Type == Bgptype_Open {
		if _, ok := t.union84_.(*union_86_t); !ok {
			t.union84_ = &union_86_t{}
		}
		t.union84_.(*union_86_t).Open = Open(v)
		return true
	}
	return false
}
func (t *Bgppacket) Update() *Update {
	if t.Type == Bgptype_Open {
		return nil
	} else if t.Type == Bgptype_Update {
		if _, ok := t.union84_.(*union_87_t); !ok {
			return nil // not set
		}
		tmp := Update(t.union84_.(*union_87_t).Update)
		return &tmp
	}
	return nil
}
func (t *Bgppacket) SetUpdate(v Update) bool {
	if t.Type == Bgptype_Open {
		return false
	} else if t.Type == Bgptype_Update {
		if _, ok := t.union84_.(*union_87_t); !ok {
			t.union84_ = &union_87_t{}
		}
		t.union84_.(*union_87_t).Update = Update(v)
		return true
	}
	return false
}
func (t *Bgppacket) Visit(v VisitorKEYKW) {
	v.Visit(v, "Marker", "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF")
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Notification", (t.Notification()))
	v.Visit(v, "Open", (t.Open()))
	v.Visit(v, "Update", (t.Update()))
}
func (t *Bgppacket) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Bgppacket) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF")); err != nil || n != len("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF") {
		return fmt.Errorf("encode Marker: %w", err)
	}
	tmp90 := [2]byte{}
	binary.BigEndian.PutUint16(tmp90[:], uint16(t.Length))
	if n, err := w.Write(tmp90[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	switch {
	case (t.Type == Bgptype_Open):
		if _, ok := t.union84_.(*union_86_t); !ok {
			return fmt.Errorf("encode t.union84_: union is not set to union_86_t")
		}
		if err := t.union84_.(*union_86_t).Open.Write(w); err != nil {
			return fmt.Errorf("encode Open: %w", err)
		}
	case (t.Type == Bgptype_Update):
		if _, ok := t.union84_.(*union_87_t); !ok {
			return fmt.Errorf("encode t.union84_: union is not set to union_87_t")
		}
		if err := t.union84_.(*union_87_t).Update.Write(w); err != nil {
			return fmt.Errorf("encode Update: %w", err)
		}
	case (t.Type == Bgptype_Notification):
		if _, ok := t.union84_.(*union_88_t); !ok {
			return fmt.Errorf("encode t.union84_: union is not set to union_88_t")
		}
		if err := t.union84_.(*union_88_t).Notification.Write(w); err != nil {
			return fmt.Errorf("encode Notification: %w", err)
		}
	case (t.Type == Bgptype_Keepalive):
	}
	return nil
}
func (t *Bgppacket) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 19))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Bgppacket) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Bgppacket) Read(r io.Reader) (err error) {
	tmp91_ := [16]byte{}
	n_tmp91_, err := io.ReadFull(r, tmp91_[:])
	if err != nil {
		return fmt.Errorf("read Marker: expect 16 bytes but read %d bytes: %w", n_tmp91_, err)
	}
	if string(tmp91_[:]) != "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" {
		return fmt.Errorf("read Marker: expect %s but got %s", "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", tmp91_[:])
	}
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = Bgptype(tmpType[0])
	switch {
	case (t.Type == Bgptype_Open):
		t.union84_ = &union_86_t{}
		if err := t.union84_.(*union_86_t).Open.Read(r); err != nil {
			return fmt.Errorf("read Open: %w", err)
		}
	case (t.Type == Bgptype_Update):
		t.union84_ = &union_87_t{}
		if err := t.union84_.(*union_87_t).Update.Read(r); err != nil {
			return fmt.Errorf("read Update: %w", err)
		}
	case (t.Type == Bgptype_Notification):
		t.union84_ = &union_88_t{}
		if err := t.union84_.(*union_88_t).Notification.Read(r); err != nil {
			return fmt.Errorf("read Notification: %w", err)
		}
	case (t.Type == Bgptype_Keepalive):
	}
	return nil
}

func (t *Bgppacket) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Bgppacket) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Bgppacket: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
