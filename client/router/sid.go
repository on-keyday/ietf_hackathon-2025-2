// Code generated by json2go. DO NOT EDIT.
package main

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"reflect"
)

type Sid struct {
	LocatorBlock [4]uint8
	LocatorNode  [4]uint8
	Function     uint16
	Args         [6]uint8
}
type VisitorKAIBJ interface {
	Visit(v VisitorKAIBJ, name string, field any)
}
type VisitorKAIBJFunc func(v VisitorKAIBJ, name string, field any)

func (f VisitorKAIBJFunc) Visit(v VisitorKAIBJ, name string, field any) {
	f(v, name, field)
}

type VisitorKAIBJVisitable interface {
	Visit(v VisitorKAIBJ)
}

func VisitorKAIBJToMap(v any) interface{} {
	if v == nil {
		return nil
	}
	if inter, ok := v.(VisitorKAIBJVisitable); ok {
		if p := reflect.ValueOf(inter); p.Kind() == reflect.Pointer && p.IsNil() {
			return nil
		}
		m := map[string]interface{}{}
		inter.Visit(VisitorKAIBJFunc(func(v VisitorKAIBJ, name string, field any) {
			m[name] = VisitorKAIBJToMap(field)
		}))
		return m
	}
	if tf := reflect.TypeOf(v); (tf.Kind() == reflect.Slice || tf.Kind() == reflect.Array) && !(func() bool { k := tf.Elem().Kind().String(); return k[:3] == "int" || k[:3] == "uin" || k[:3] == "flo" })() {
		m := []interface{}{}
		vf := reflect.ValueOf(v)
		for i := 0; i < vf.Len(); i++ {
			index := vf.Index(i)
			if index.Kind() == reflect.Struct && index.CanAddr() {
				index = index.Addr()
			}
			m = append(m, VisitorKAIBJToMap(index.Interface()))
		}
		return m
	}
	if tf := reflect.TypeOf(v); tf.Kind() == reflect.Pointer {
		val := reflect.ValueOf(v)
		if val.IsNil() {
			return nil
		}
		return VisitorKAIBJToMap(val.Elem().Interface())
	}
	return v
}
func (t *Sid) Visit(v VisitorKAIBJ) {
	v.Visit(v, "LocatorBlock", &t.LocatorBlock)
	v.Visit(v, "LocatorNode", &t.LocatorNode)
	v.Visit(v, "Function", &t.Function)
	v.Visit(v, "Args", &t.Args)
}
func (t *Sid) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKAIBJToMap(t))
}
func (t *Sid) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.LocatorBlock[:]); err != nil || n != len(t.LocatorBlock) {
		return fmt.Errorf("encode LocatorBlock: %w", err)
	}
	if n, err := w.Write(t.LocatorNode[:]); err != nil || n != len(t.LocatorNode) {
		return fmt.Errorf("encode LocatorNode: %w", err)
	}
	tmp1 := [2]byte{}
	binary.BigEndian.PutUint16(tmp1[:], uint16(t.Function))
	if n, err := w.Write(tmp1[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Function: %w", err)
	}
	if n, err := w.Write(t.Args[:]); err != nil || n != len(t.Args) {
		return fmt.Errorf("encode Args: %w", err)
	}
	return nil
}
func (t *Sid) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 16))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Sid) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Sid) Read(r io.Reader) (err error) {
	n_LocatorBlock, err := io.ReadFull(r, t.LocatorBlock[:])
	if err != nil {
		return fmt.Errorf("read LocatorBlock: expect %d bytes but read %d bytes: %w", 4, n_LocatorBlock, err)
	}
	n_LocatorNode, err := io.ReadFull(r, t.LocatorNode[:])
	if err != nil {
		return fmt.Errorf("read LocatorNode: expect %d bytes but read %d bytes: %w", 4, n_LocatorNode, err)
	}
	tmpFunction := [2]byte{}
	n_Function, err := io.ReadFull(r, tmpFunction[:])
	if err != nil {
		return fmt.Errorf("read Function: expect 2 bytes but read %d bytes: %w", n_Function, err)
	}
	t.Function = uint16(binary.BigEndian.Uint16(tmpFunction[:]))
	n_Args, err := io.ReadFull(r, t.Args[:])
	if err != nil {
		return fmt.Errorf("read Args: expect %d bytes but read %d bytes: %w", 6, n_Args, err)
	}
	return nil
}

func (t *Sid) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Sid) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Sid: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
