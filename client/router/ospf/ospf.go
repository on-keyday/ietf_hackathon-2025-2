// Code generated by json2go. DO NOT EDIT.
package ospf

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"reflect"
)

type OspfpacketType uint8

const (
	OspfpacketType_Hello                    OspfpacketType = 1
	OspfpacketType_DatabaseDescription      OspfpacketType = 2
	OspfpacketType_LinkStateRequest         OspfpacketType = 3
	OspfpacketType_LinkStateUpdate          OspfpacketType = 4
	OspfpacketType_LinkStateAcknowledgement OspfpacketType = 5
)

func (t OspfpacketType) String() string {
	switch t {
	case OspfpacketType_Hello:
		return "Hello"
	case OspfpacketType_DatabaseDescription:
		return "DatabaseDescription"
	case OspfpacketType_LinkStateRequest:
		return "LinkStateRequest"
	case OspfpacketType_LinkStateUpdate:
		return "LinkStateUpdate"
	case OspfpacketType_LinkStateAcknowledgement:
		return "LinkStateAcknowledgement"
	}
	return fmt.Sprintf("OspfpacketType(%d)", t)
}

type Scoping int

const (
	Scoping_LinkLocal Scoping = 0
	Scoping_AreaLocal Scoping = 1
	Scoping_AsLocal   Scoping = 2
	Scoping_Reserved  Scoping = 3
)

func (t Scoping) String() string {
	switch t {
	case Scoping_LinkLocal:
		return "LinkLocal"
	case Scoping_AreaLocal:
		return "AreaLocal"
	case Scoping_AsLocal:
		return "AsLocal"
	case Scoping_Reserved:
		return "Reserved"
	}
	return fmt.Sprintf("Scoping(%d)", t)
}

type LsafunctionCode uint16

const (
	LsafunctionCode_RouterLsa          LsafunctionCode = 0x2001
	LsafunctionCode_NetworkLsa         LsafunctionCode = 0x2002
	LsafunctionCode_InterAreaPrefixLsa LsafunctionCode = 0x2003
	LsafunctionCode_InterAreaRouterLsa LsafunctionCode = 0x2004
	LsafunctionCode_AsExternalLsa      LsafunctionCode = 0x4005
	LsafunctionCode_NssaLsa            LsafunctionCode = 0x2007
	LsafunctionCode_LinkLsa            LsafunctionCode = 0x0008
	LsafunctionCode_IntraAreaPrefixLsa LsafunctionCode = 0x2009
	LsafunctionCode_IntraAreaRouterLsa LsafunctionCode = 0x200a
)

func (t LsafunctionCode) String() string {
	switch t {
	case LsafunctionCode_RouterLsa:
		return "RouterLsa"
	case LsafunctionCode_NetworkLsa:
		return "NetworkLsa"
	case LsafunctionCode_InterAreaPrefixLsa:
		return "InterAreaPrefixLsa"
	case LsafunctionCode_InterAreaRouterLsa:
		return "InterAreaRouterLsa"
	case LsafunctionCode_AsExternalLsa:
		return "AsExternalLsa"
	case LsafunctionCode_NssaLsa:
		return "NssaLsa"
	case LsafunctionCode_LinkLsa:
		return "LinkLsa"
	case LsafunctionCode_IntraAreaPrefixLsa:
		return "IntraAreaPrefixLsa"
	case LsafunctionCode_IntraAreaRouterLsa:
		return "IntraAreaRouterLsa"
	}
	return fmt.Sprintf("LsafunctionCode(%d)", t)
}

type Ospfheader struct {
	Version      uint8
	Type         OspfpacketType
	PacketLength uint16
	RouterId     uint32
	AreaId       uint32
	CheckSum     uint16
	InstanceId   uint8
	Zero         uint8
}
type VisitorTIJJO interface {
	Visit(v VisitorTIJJO, name string, field any)
}
type VisitorTIJJOFunc func(v VisitorTIJJO, name string, field any)

func (f VisitorTIJJOFunc) Visit(v VisitorTIJJO, name string, field any) {
	f(v, name, field)
}

type VisitorTIJJOVisitable interface {
	Visit(v VisitorTIJJO)
}

func VisitorTIJJOToMap(v any) interface{} {
	if v == nil {
		return nil
	}
	if inter, ok := v.(VisitorTIJJOVisitable); ok {
		if p := reflect.ValueOf(inter); p.Kind() == reflect.Pointer && p.IsNil() {
			return nil
		}
		m := map[string]interface{}{}
		inter.Visit(VisitorTIJJOFunc(func(v VisitorTIJJO, name string, field any) {
			m[name] = VisitorTIJJOToMap(field)
		}))
		return m
	}
	if tf := reflect.TypeOf(v); (tf.Kind() == reflect.Slice || tf.Kind() == reflect.Array) && !(func() bool { k := tf.Elem().Kind().String(); return k[:3] == "int" || k[:3] == "uin" || k[:3] == "flo" })() {
		m := []interface{}{}
		vf := reflect.ValueOf(v)
		for i := 0; i < vf.Len(); i++ {
			index := vf.Index(i)
			if index.Kind() == reflect.Struct && index.CanAddr() {
				index = index.Addr()
			}
			m = append(m, VisitorTIJJOToMap(index.Interface()))
		}
		return m
	}
	if tf := reflect.TypeOf(v); tf.Kind() == reflect.Pointer {
		val := reflect.ValueOf(v)
		if val.IsNil() {
			return nil
		}
		return VisitorTIJJOToMap(val.Elem().Interface())
	}
	return v
}

type HelloPacket struct {
	InterfaceId            uint32
	RtrPriority            uint8
	Options                uint8
	HelloInterval          uint16
	RouterDeadInterval     uint16
	DesignatedRouter       uint32
	BackupDesignatedRouter uint32
	Neighbors              []uint32
}
type OspflinkStateRequestPacket struct {
	Reserved          uint8
	LinkStateType     uint16
	LinkStateId       uint32
	AdvertisingRouter []uint32
}
type PrefixOptions struct {
	flags18 uint8
}
type Lsatype struct {
	flags19 uint16
}
type Lsaheader struct {
	LsAge             uint16
	LsType            LsafunctionCode
	LinkStateId       uint32
	AdvertisingRouter uint32
	LsSequenceNumber  uint32
	LsChecksum        uint16
	Length            uint16
}
type Option struct {
	Reserved uint16
	flags28  uint8
}
type RouterInfo struct {
	Type                uint8
	Reserved            uint8
	Metric              uint16
	InterfaceId         uint32
	NeighborInterfaceId uint32
	NeighborRouterId    uint32
}
type RouterLsa struct {
	flags34  uint8
	Options  Option
	LinkInfo []RouterInfo
}
type NetworkLsa struct {
	Reserved        uint8
	Options         Option
	AttachedRouters []uint32
}
type AddressPrefix struct {
	PrefixLen uint8
	Options   PrefixOptions
	Reserved2 uint16
	Prefix    []uint8
}
type InterAreaPrefixLsa struct {
	Reserved uint8
	Metric   uint32
	Prefix   AddressPrefix
}
type InterAreaRouterLsa struct {
	Reserved     uint8
	Option       Option
	Reserved2    uint8
	Metric       uint32
	DestRouterId uint32
}
type union44_AsexternalLsa interface {
	isunion43_()
}
type union_45_t struct {
	ForwardingAddress [16]uint8
}
type union47_AsexternalLsa interface {
	isunion46_()
}
type union_48_t struct {
	ExternalRouteTag uint32
}
type union50_AsexternalLsa interface {
	isunion49_()
}
type union_51_t struct {
	ReferencedLinkStateId uint32
}
type AsexternalLsa struct {
	flags42          uint8
	Metric           uint32
	PrefixLen        uint8
	PrefixOptions    PrefixOptions
	ReferencedLsType uint16
	union43_         union44_AsexternalLsa
	union46_         union47_AsexternalLsa
	union49_         union50_AsexternalLsa
}
type LinkLsa struct {
	RtrPriority               uint8
	Options                   Option
	LinkLocalInterfaceAddress [16]uint8
	NumPrefixes               uint16
	Prefixes                  []AddressPrefix
}
type IntraAreaPrefixLsa struct {
	NumPrefixes           uint16
	ReferencedLsType      uint16
	ReferencedLinkStateId uint32
	Prefixes              []AddressPrefix
}
type union64_Lsa interface {
	isunion63_()
}
type union_65_t struct {
	RouterLsa RouterLsa
}
type union_66_t struct {
	NetworkLsa NetworkLsa
}
type union_67_t struct {
	InterAreaPrefixLsa InterAreaPrefixLsa
}
type union_68_t struct {
	InterAreaRouterLsa InterAreaRouterLsa
}
type union_69_t struct {
	AsExternalLsa AsexternalLsa
}
type union_70_t struct {
	LinkLsa LinkLsa
}
type union_71_t struct {
	IntraAreaPrefixLsa IntraAreaPrefixLsa
}
type union_72_t struct {
	Data []uint8
}
type Lsa struct {
	LsaHeader Lsaheader
	union63_  union64_Lsa
}
type OspflinkStateUpdatePacket struct {
	NumLsa     uint32
	LsaHeaders []Lsa
}
type OspflinkStateAcknowledgementPacket struct {
	LsaHeaders []Lsaheader
}
type DatabaseDescriptionPacket struct {
	Reserved         uint8
	Options          Option
	InterfaceMtu     uint16
	Reserved2        uint8
	flags92          uint8
	DdSequenceNumber uint32
	LsaHeaders       []Lsaheader
}
type union98_Ospfpacket interface {
	isunion97_()
}
type union_99_t struct {
	HelloPacket HelloPacket
}
type union_100_t struct {
	DatabaseDescriptionPacket DatabaseDescriptionPacket
}
type union_101_t struct {
	OspfLinkStateRequestPacket OspflinkStateRequestPacket
}
type union_102_t struct {
	OspfLinkStateUpdatePacket OspflinkStateUpdatePacket
}
type union_103_t struct {
	OspfLinkStateAcknowledgementPacket OspflinkStateAcknowledgementPacket
}
type union_104_t struct {
	Data []uint8
}
type Ospfpacket struct {
	Header   Ospfheader
	union97_ union98_Ospfpacket
}

func (t *Ospfheader) Visit(v VisitorTIJJO) {
	v.Visit(v, "Version", &t.Version)
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "PacketLength", &t.PacketLength)
	v.Visit(v, "RouterId", &t.RouterId)
	v.Visit(v, "AreaId", &t.AreaId)
	v.Visit(v, "CheckSum", &t.CheckSum)
	v.Visit(v, "InstanceId", &t.InstanceId)
	v.Visit(v, "Zero", &t.Zero)
}
func (t *Ospfheader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *Ospfheader) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Version)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Version: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	tmp1 := [2]byte{}
	binary.BigEndian.PutUint16(tmp1[:], uint16(t.PacketLength))
	if n, err := w.Write(tmp1[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.PacketLength: %w", err)
	}
	tmp2 := [4]byte{}
	binary.BigEndian.PutUint32(tmp2[:], uint32(t.RouterId))
	if n, err := w.Write(tmp2[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.RouterId: %w", err)
	}
	tmp3 := [4]byte{}
	binary.BigEndian.PutUint32(tmp3[:], uint32(t.AreaId))
	if n, err := w.Write(tmp3[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.AreaId: %w", err)
	}
	tmp4 := [2]byte{}
	binary.BigEndian.PutUint16(tmp4[:], uint16(t.CheckSum))
	if n, err := w.Write(tmp4[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.CheckSum: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.InstanceId)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.InstanceId: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Zero)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Zero: %w", err)
	}
	return nil
}
func (t *Ospfheader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 16))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Ospfheader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Ospfheader) Read(r io.Reader) (err error) {
	tmpVersion := [1]byte{}
	n_Version, err := io.ReadFull(r, tmpVersion[:])
	if err != nil {
		return fmt.Errorf("read Version: expect 1 byte but read %d bytes: %w", n_Version, err)
	}
	t.Version = uint8(tmpVersion[0])
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = OspfpacketType(tmpType[0])
	tmpPacketLength := [2]byte{}
	n_PacketLength, err := io.ReadFull(r, tmpPacketLength[:])
	if err != nil {
		return fmt.Errorf("read PacketLength: expect 2 bytes but read %d bytes: %w", n_PacketLength, err)
	}
	t.PacketLength = uint16(binary.BigEndian.Uint16(tmpPacketLength[:]))
	tmpRouterId := [4]byte{}
	n_RouterId, err := io.ReadFull(r, tmpRouterId[:])
	if err != nil {
		return fmt.Errorf("read RouterId: expect 4 bytes but read %d bytes: %w", n_RouterId, err)
	}
	t.RouterId = uint32(binary.BigEndian.Uint32(tmpRouterId[:]))
	tmpAreaId := [4]byte{}
	n_AreaId, err := io.ReadFull(r, tmpAreaId[:])
	if err != nil {
		return fmt.Errorf("read AreaId: expect 4 bytes but read %d bytes: %w", n_AreaId, err)
	}
	t.AreaId = uint32(binary.BigEndian.Uint32(tmpAreaId[:]))
	tmpCheckSum := [2]byte{}
	n_CheckSum, err := io.ReadFull(r, tmpCheckSum[:])
	if err != nil {
		return fmt.Errorf("read CheckSum: expect 2 bytes but read %d bytes: %w", n_CheckSum, err)
	}
	t.CheckSum = uint16(binary.BigEndian.Uint16(tmpCheckSum[:]))
	tmpInstanceId := [1]byte{}
	n_InstanceId, err := io.ReadFull(r, tmpInstanceId[:])
	if err != nil {
		return fmt.Errorf("read InstanceId: expect 1 byte but read %d bytes: %w", n_InstanceId, err)
	}
	t.InstanceId = uint8(tmpInstanceId[0])
	tmpZero := [1]byte{}
	n_Zero, err := io.ReadFull(r, tmpZero[:])
	if err != nil {
		return fmt.Errorf("read Zero: expect 1 byte but read %d bytes: %w", n_Zero, err)
	}
	t.Zero = uint8(tmpZero[0])
	return nil
}

func (t *Ospfheader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Ospfheader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Ospfheader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *HelloPacket) Visit(v VisitorTIJJO) {
	v.Visit(v, "InterfaceId", &t.InterfaceId)
	v.Visit(v, "RtrPriority", &t.RtrPriority)
	v.Visit(v, "Options", &t.Options)
	v.Visit(v, "HelloInterval", &t.HelloInterval)
	v.Visit(v, "RouterDeadInterval", &t.RouterDeadInterval)
	v.Visit(v, "DesignatedRouter", &t.DesignatedRouter)
	v.Visit(v, "BackupDesignatedRouter", &t.BackupDesignatedRouter)
	v.Visit(v, "Neighbors", &t.Neighbors)
}
func (t *HelloPacket) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *HelloPacket) Write(w io.Writer) (err error) {
	tmp5 := [4]byte{}
	binary.BigEndian.PutUint32(tmp5[:], uint32(t.InterfaceId))
	if n, err := w.Write(tmp5[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.InterfaceId: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.RtrPriority)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.RtrPriority: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Options)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Options: %w", err)
	}
	tmp6 := [2]byte{}
	binary.BigEndian.PutUint16(tmp6[:], uint16(t.HelloInterval))
	if n, err := w.Write(tmp6[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.HelloInterval: %w", err)
	}
	tmp7 := [2]byte{}
	binary.BigEndian.PutUint16(tmp7[:], uint16(t.RouterDeadInterval))
	if n, err := w.Write(tmp7[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.RouterDeadInterval: %w", err)
	}
	tmp8 := [4]byte{}
	binary.BigEndian.PutUint32(tmp8[:], uint32(t.DesignatedRouter))
	if n, err := w.Write(tmp8[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.DesignatedRouter: %w", err)
	}
	tmp9 := [4]byte{}
	binary.BigEndian.PutUint32(tmp9[:], uint32(t.BackupDesignatedRouter))
	if n, err := w.Write(tmp9[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.BackupDesignatedRouter: %w", err)
	}
	for _, v := range t.Neighbors {
		tmp10 := [4]byte{}
		binary.BigEndian.PutUint32(tmp10[:], uint32(v))
		if n, err := w.Write(tmp10[:]); err != nil || n != 4 {
			return fmt.Errorf("encode v: %w", err)
		}
	}
	return nil
}
func (t *HelloPacket) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 18))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *HelloPacket) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *HelloPacket) Read(r io.Reader) (err error) {
	tmpInterfaceId := [4]byte{}
	n_InterfaceId, err := io.ReadFull(r, tmpInterfaceId[:])
	if err != nil {
		return fmt.Errorf("read InterfaceId: expect 4 bytes but read %d bytes: %w", n_InterfaceId, err)
	}
	t.InterfaceId = uint32(binary.BigEndian.Uint32(tmpInterfaceId[:]))
	tmpRtrPriority := [1]byte{}
	n_RtrPriority, err := io.ReadFull(r, tmpRtrPriority[:])
	if err != nil {
		return fmt.Errorf("read RtrPriority: expect 1 byte but read %d bytes: %w", n_RtrPriority, err)
	}
	t.RtrPriority = uint8(tmpRtrPriority[0])
	tmpOptions := [1]byte{}
	n_Options, err := io.ReadFull(r, tmpOptions[:])
	if err != nil {
		return fmt.Errorf("read Options: expect 1 byte but read %d bytes: %w", n_Options, err)
	}
	t.Options = uint8(tmpOptions[0])
	tmpHelloInterval := [2]byte{}
	n_HelloInterval, err := io.ReadFull(r, tmpHelloInterval[:])
	if err != nil {
		return fmt.Errorf("read HelloInterval: expect 2 bytes but read %d bytes: %w", n_HelloInterval, err)
	}
	t.HelloInterval = uint16(binary.BigEndian.Uint16(tmpHelloInterval[:]))
	tmpRouterDeadInterval := [2]byte{}
	n_RouterDeadInterval, err := io.ReadFull(r, tmpRouterDeadInterval[:])
	if err != nil {
		return fmt.Errorf("read RouterDeadInterval: expect 2 bytes but read %d bytes: %w", n_RouterDeadInterval, err)
	}
	t.RouterDeadInterval = uint16(binary.BigEndian.Uint16(tmpRouterDeadInterval[:]))
	tmpDesignatedRouter := [4]byte{}
	n_DesignatedRouter, err := io.ReadFull(r, tmpDesignatedRouter[:])
	if err != nil {
		return fmt.Errorf("read DesignatedRouter: expect 4 bytes but read %d bytes: %w", n_DesignatedRouter, err)
	}
	t.DesignatedRouter = uint32(binary.BigEndian.Uint32(tmpDesignatedRouter[:]))
	tmpBackupDesignatedRouter := [4]byte{}
	n_BackupDesignatedRouter, err := io.ReadFull(r, tmpBackupDesignatedRouter[:])
	if err != nil {
		return fmt.Errorf("read BackupDesignatedRouter: expect 4 bytes but read %d bytes: %w", n_BackupDesignatedRouter, err)
	}
	t.BackupDesignatedRouter = uint32(binary.BigEndian.Uint32(tmpBackupDesignatedRouter[:]))
	tmp_byte_scanner11_ := bufio.NewReaderSize(r, 1)
	old_r_Neighbors := r
	r = tmp_byte_scanner11_
	for {
		_, err := tmp_byte_scanner11_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Neighbors: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner11_.UnreadByte(); err != nil {
			return fmt.Errorf("read Neighbors: unexpected unread error: %w", err)
		}
		var tmp12_ uint32
		tmpNeighbors := [4]byte{}
		n_Neighbors, err := io.ReadFull(r, tmpNeighbors[:])
		if err != nil {
			return fmt.Errorf("read Neighbors: expect 4 bytes but read %d bytes: %w", n_Neighbors, err)
		}
		tmp12_ = uint32(binary.BigEndian.Uint32(tmpNeighbors[:]))
		t.Neighbors = append(t.Neighbors, tmp12_)
	}
	r = old_r_Neighbors
	return nil
}

func (t *HelloPacket) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *HelloPacket) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode HelloPacket: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *OspflinkStateRequestPacket) Visit(v VisitorTIJJO) {
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "LinkStateType", &t.LinkStateType)
	v.Visit(v, "LinkStateId", &t.LinkStateId)
	v.Visit(v, "AdvertisingRouter", &t.AdvertisingRouter)
}
func (t *OspflinkStateRequestPacket) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *OspflinkStateRequestPacket) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Reserved)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	tmp13 := [2]byte{}
	binary.BigEndian.PutUint16(tmp13[:], uint16(t.LinkStateType))
	if n, err := w.Write(tmp13[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.LinkStateType: %w", err)
	}
	tmp14 := [4]byte{}
	binary.BigEndian.PutUint32(tmp14[:], uint32(t.LinkStateId))
	if n, err := w.Write(tmp14[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.LinkStateId: %w", err)
	}
	for _, v := range t.AdvertisingRouter {
		tmp15 := [4]byte{}
		binary.BigEndian.PutUint32(tmp15[:], uint32(v))
		if n, err := w.Write(tmp15[:]); err != nil || n != 4 {
			return fmt.Errorf("encode v: %w", err)
		}
	}
	return nil
}
func (t *OspflinkStateRequestPacket) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 7))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *OspflinkStateRequestPacket) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *OspflinkStateRequestPacket) Read(r io.Reader) (err error) {
	tmpReserved := [1]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 1 byte but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint8(tmpReserved[0])
	tmpLinkStateType := [2]byte{}
	n_LinkStateType, err := io.ReadFull(r, tmpLinkStateType[:])
	if err != nil {
		return fmt.Errorf("read LinkStateType: expect 2 bytes but read %d bytes: %w", n_LinkStateType, err)
	}
	t.LinkStateType = uint16(binary.BigEndian.Uint16(tmpLinkStateType[:]))
	tmpLinkStateId := [4]byte{}
	n_LinkStateId, err := io.ReadFull(r, tmpLinkStateId[:])
	if err != nil {
		return fmt.Errorf("read LinkStateId: expect 4 bytes but read %d bytes: %w", n_LinkStateId, err)
	}
	t.LinkStateId = uint32(binary.BigEndian.Uint32(tmpLinkStateId[:]))
	tmp_byte_scanner16_ := bufio.NewReaderSize(r, 1)
	old_r_AdvertisingRouter := r
	r = tmp_byte_scanner16_
	for {
		_, err := tmp_byte_scanner16_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read AdvertisingRouter: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner16_.UnreadByte(); err != nil {
			return fmt.Errorf("read AdvertisingRouter: unexpected unread error: %w", err)
		}
		var tmp17_ uint32
		tmpAdvertisingRouter := [4]byte{}
		n_AdvertisingRouter, err := io.ReadFull(r, tmpAdvertisingRouter[:])
		if err != nil {
			return fmt.Errorf("read AdvertisingRouter: expect 4 bytes but read %d bytes: %w", n_AdvertisingRouter, err)
		}
		tmp17_ = uint32(binary.BigEndian.Uint32(tmpAdvertisingRouter[:]))
		t.AdvertisingRouter = append(t.AdvertisingRouter, tmp17_)
	}
	r = old_r_AdvertisingRouter
	return nil
}

func (t *OspflinkStateRequestPacket) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *OspflinkStateRequestPacket) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode OspflinkStateRequestPacket: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *PrefixOptions) Reserved() uint8 {
	return ((t.flags18 & 0xe0) >> 5)
}
func (t *PrefixOptions) SetReserved(v uint8) bool {
	if v > 7 {
		return false
	}
	t.flags18 = (t.flags18 & ^uint8(0xe0)) | ((v & 0x7) << 5)
	return true
}
func (t *PrefixOptions) Dn() bool {
	return ((t.flags18 & 0x10) >> 4) == 1
}
func (t *PrefixOptions) SetDn(v bool) {
	if v {
		t.flags18 |= uint8(0x10)
	} else {
		t.flags18 &= ^uint8(0x10)
	}
}
func (t *PrefixOptions) Propagate() bool {
	return ((t.flags18 & 0x08) >> 3) == 1
}
func (t *PrefixOptions) SetPropagate(v bool) {
	if v {
		t.flags18 |= uint8(0x8)
	} else {
		t.flags18 &= ^uint8(0x8)
	}
}
func (t *PrefixOptions) Multicast() bool {
	return ((t.flags18 & 0x04) >> 2) == 1
}
func (t *PrefixOptions) SetMulticast(v bool) {
	if v {
		t.flags18 |= uint8(0x4)
	} else {
		t.flags18 &= ^uint8(0x4)
	}
}
func (t *PrefixOptions) LocalAddress() bool {
	return ((t.flags18 & 0x02) >> 1) == 1
}
func (t *PrefixOptions) SetLocalAddress(v bool) {
	if v {
		t.flags18 |= uint8(0x2)
	} else {
		t.flags18 &= ^uint8(0x2)
	}
}
func (t *PrefixOptions) NoUnicast() bool {
	return ((t.flags18 & 0x01) >> 0) == 1
}
func (t *PrefixOptions) SetNoUnicast(v bool) {
	if v {
		t.flags18 |= uint8(0x1)
	} else {
		t.flags18 &= ^uint8(0x1)
	}
}
func (t *PrefixOptions) Visit(v VisitorTIJJO) {
	v.Visit(v, "Reserved", t.Reserved())
	v.Visit(v, "Dn", (func() uint8 {
		if t.Dn() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Propagate", (func() uint8 {
		if t.Propagate() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Multicast", (func() uint8 {
		if t.Multicast() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "LocalAddress", (func() uint8 {
		if t.LocalAddress() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "NoUnicast", (func() uint8 {
		if t.NoUnicast() {
			return 1
		} else {
			return 0
		}
	}()))
}
func (t *PrefixOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *PrefixOptions) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags18)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags18: %w", err)
	}
	return nil
}
func (t *PrefixOptions) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *PrefixOptions) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *PrefixOptions) Read(r io.Reader) (err error) {
	tmpflags18 := [1]byte{}
	n_flags18, err := io.ReadFull(r, tmpflags18[:])
	if err != nil {
		return fmt.Errorf("read flags18: expect 1 byte but read %d bytes: %w", n_flags18, err)
	}
	t.flags18 = uint8(tmpflags18[0])
	return nil
}

func (t *PrefixOptions) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *PrefixOptions) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode PrefixOptions: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Lsatype) Understand() bool {
	return ((t.flags19 & 0x8000) >> 15) == 1
}
func (t *Lsatype) SetUnderstand(v bool) {
	if v {
		t.flags19 |= uint16(0x8000)
	} else {
		t.flags19 &= ^uint16(0x8000)
	}
}
func (t *Lsatype) Scoping() Scoping {
	return Scoping(((t.flags19 & 0x6000) >> 13))
}
func (t *Lsatype) SetScoping(v Scoping) bool {
	if v > 3 {
		return false
	}
	t.flags19 = (t.flags19 & ^uint16(0x6000)) | ((uint16(v) & 0x3) << 13)
	return true
}
func (t *Lsatype) Code() uint16 {
	return ((t.flags19 & 0x1fff) >> 0)
}
func (t *Lsatype) SetCode(v uint16) bool {
	if v > 8191 {
		return false
	}
	t.flags19 = (t.flags19 & ^uint16(0x1fff)) | ((v & 0x1fff) << 0)
	return true
}
func (t *Lsatype) Visit(v VisitorTIJJO) {
	v.Visit(v, "Understand", (func() uint16 {
		if t.Understand() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Scoping", t.Scoping())
	v.Visit(v, "Code", t.Code())
}
func (t *Lsatype) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *Lsatype) Write(w io.Writer) (err error) {
	tmp20 := [2]byte{}
	binary.BigEndian.PutUint16(tmp20[:], uint16(t.flags19))
	if n, err := w.Write(tmp20[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.flags19: %w", err)
	}
	return nil
}
func (t *Lsatype) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Lsatype) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Lsatype) Read(r io.Reader) (err error) {
	tmpflags19 := [2]byte{}
	n_flags19, err := io.ReadFull(r, tmpflags19[:])
	if err != nil {
		return fmt.Errorf("read flags19: expect 2 bytes but read %d bytes: %w", n_flags19, err)
	}
	t.flags19 = uint16(binary.BigEndian.Uint16(tmpflags19[:]))
	return nil
}

func (t *Lsatype) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Lsatype) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Lsatype: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Lsaheader) Visit(v VisitorTIJJO) {
	v.Visit(v, "LsAge", &t.LsAge)
	v.Visit(v, "LsType", &t.LsType)
	v.Visit(v, "LinkStateId", &t.LinkStateId)
	v.Visit(v, "AdvertisingRouter", &t.AdvertisingRouter)
	v.Visit(v, "LsSequenceNumber", &t.LsSequenceNumber)
	v.Visit(v, "LsChecksum", &t.LsChecksum)
	v.Visit(v, "Length", &t.Length)
}
func (t *Lsaheader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *Lsaheader) Write(w io.Writer) (err error) {
	tmp21 := [2]byte{}
	binary.BigEndian.PutUint16(tmp21[:], uint16(t.LsAge))
	if n, err := w.Write(tmp21[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.LsAge: %w", err)
	}
	tmp22 := [2]byte{}
	binary.BigEndian.PutUint16(tmp22[:], uint16(t.LsType))
	if n, err := w.Write(tmp22[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.LsType: %w", err)
	}
	tmp23 := [4]byte{}
	binary.BigEndian.PutUint32(tmp23[:], uint32(t.LinkStateId))
	if n, err := w.Write(tmp23[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.LinkStateId: %w", err)
	}
	tmp24 := [4]byte{}
	binary.BigEndian.PutUint32(tmp24[:], uint32(t.AdvertisingRouter))
	if n, err := w.Write(tmp24[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.AdvertisingRouter: %w", err)
	}
	tmp25 := [4]byte{}
	binary.BigEndian.PutUint32(tmp25[:], uint32(t.LsSequenceNumber))
	if n, err := w.Write(tmp25[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.LsSequenceNumber: %w", err)
	}
	tmp26 := [2]byte{}
	binary.BigEndian.PutUint16(tmp26[:], uint16(t.LsChecksum))
	if n, err := w.Write(tmp26[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.LsChecksum: %w", err)
	}
	tmp27 := [2]byte{}
	binary.BigEndian.PutUint16(tmp27[:], uint16(t.Length))
	if n, err := w.Write(tmp27[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	return nil
}
func (t *Lsaheader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 20))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Lsaheader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Lsaheader) Read(r io.Reader) (err error) {
	tmpLsAge := [2]byte{}
	n_LsAge, err := io.ReadFull(r, tmpLsAge[:])
	if err != nil {
		return fmt.Errorf("read LsAge: expect 2 bytes but read %d bytes: %w", n_LsAge, err)
	}
	t.LsAge = uint16(binary.BigEndian.Uint16(tmpLsAge[:]))
	tmpLsType := [2]byte{}
	n_LsType, err := io.ReadFull(r, tmpLsType[:])
	if err != nil {
		return fmt.Errorf("read LsType: expect 2 bytes but read %d bytes: %w", n_LsType, err)
	}
	t.LsType = LsafunctionCode(binary.BigEndian.Uint16(tmpLsType[:]))
	tmpLinkStateId := [4]byte{}
	n_LinkStateId, err := io.ReadFull(r, tmpLinkStateId[:])
	if err != nil {
		return fmt.Errorf("read LinkStateId: expect 4 bytes but read %d bytes: %w", n_LinkStateId, err)
	}
	t.LinkStateId = uint32(binary.BigEndian.Uint32(tmpLinkStateId[:]))
	tmpAdvertisingRouter := [4]byte{}
	n_AdvertisingRouter, err := io.ReadFull(r, tmpAdvertisingRouter[:])
	if err != nil {
		return fmt.Errorf("read AdvertisingRouter: expect 4 bytes but read %d bytes: %w", n_AdvertisingRouter, err)
	}
	t.AdvertisingRouter = uint32(binary.BigEndian.Uint32(tmpAdvertisingRouter[:]))
	tmpLsSequenceNumber := [4]byte{}
	n_LsSequenceNumber, err := io.ReadFull(r, tmpLsSequenceNumber[:])
	if err != nil {
		return fmt.Errorf("read LsSequenceNumber: expect 4 bytes but read %d bytes: %w", n_LsSequenceNumber, err)
	}
	t.LsSequenceNumber = uint32(binary.BigEndian.Uint32(tmpLsSequenceNumber[:]))
	tmpLsChecksum := [2]byte{}
	n_LsChecksum, err := io.ReadFull(r, tmpLsChecksum[:])
	if err != nil {
		return fmt.Errorf("read LsChecksum: expect 2 bytes but read %d bytes: %w", n_LsChecksum, err)
	}
	t.LsChecksum = uint16(binary.BigEndian.Uint16(tmpLsChecksum[:]))
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	return nil
}

func (t *Lsaheader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Lsaheader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Lsaheader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Option) Ospfv2Compat() uint8 {
	return ((t.flags28 & 0xc0) >> 6)
}
func (t *Option) SetOspfv2Compat(v uint8) bool {
	if v > 3 {
		return false
	}
	t.flags28 = (t.flags28 & ^uint8(0xc0)) | ((v & 0x3) << 6)
	return true
}
func (t *Option) Dc() bool {
	return ((t.flags28 & 0x20) >> 5) == 1
}
func (t *Option) SetDc(v bool) {
	if v {
		t.flags28 |= uint8(0x20)
	} else {
		t.flags28 &= ^uint8(0x20)
	}
}
func (t *Option) R() bool {
	return ((t.flags28 & 0x10) >> 4) == 1
}
func (t *Option) SetR(v bool) {
	if v {
		t.flags28 |= uint8(0x10)
	} else {
		t.flags28 &= ^uint8(0x10)
	}
}
func (t *Option) N() bool {
	return ((t.flags28 & 0x08) >> 3) == 1
}
func (t *Option) SetN(v bool) {
	if v {
		t.flags28 |= uint8(0x8)
	} else {
		t.flags28 &= ^uint8(0x8)
	}
}
func (t *Option) X() bool {
	return ((t.flags28 & 0x04) >> 2) == 1
}
func (t *Option) SetX(v bool) {
	if v {
		t.flags28 |= uint8(0x4)
	} else {
		t.flags28 &= ^uint8(0x4)
	}
}
func (t *Option) External() bool {
	return ((t.flags28 & 0x02) >> 1) == 1
}
func (t *Option) SetExternal(v bool) {
	if v {
		t.flags28 |= uint8(0x2)
	} else {
		t.flags28 &= ^uint8(0x2)
	}
}
func (t *Option) V6() bool {
	return ((t.flags28 & 0x01) >> 0) == 1
}
func (t *Option) SetV6(v bool) {
	if v {
		t.flags28 |= uint8(0x1)
	} else {
		t.flags28 &= ^uint8(0x1)
	}
}
func (t *Option) Visit(v VisitorTIJJO) {
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "Ospfv2Compat", t.Ospfv2Compat())
	v.Visit(v, "Dc", (func() uint8 {
		if t.Dc() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "R", (func() uint8 {
		if t.R() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "N", (func() uint8 {
		if t.N() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "X", (func() uint8 {
		if t.X() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "External", (func() uint8 {
		if t.External() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "V6", (func() uint8 {
		if t.V6() {
			return 1
		} else {
			return 0
		}
	}()))
}
func (t *Option) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *Option) Write(w io.Writer) (err error) {
	tmp29 := [2]byte{}
	binary.BigEndian.PutUint16(tmp29[:], uint16(t.Reserved))
	if n, err := w.Write(tmp29[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags28)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags28: %w", err)
	}
	return nil
}
func (t *Option) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 3))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Option) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Option) Read(r io.Reader) (err error) {
	tmpReserved := [2]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 2 bytes but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint16(binary.BigEndian.Uint16(tmpReserved[:]))
	tmpflags28 := [1]byte{}
	n_flags28, err := io.ReadFull(r, tmpflags28[:])
	if err != nil {
		return fmt.Errorf("read flags28: expect 1 byte but read %d bytes: %w", n_flags28, err)
	}
	t.flags28 = uint8(tmpflags28[0])
	return nil
}

func (t *Option) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Option) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Option: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *RouterInfo) Visit(v VisitorTIJJO) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "Metric", &t.Metric)
	v.Visit(v, "InterfaceId", &t.InterfaceId)
	v.Visit(v, "NeighborInterfaceId", &t.NeighborInterfaceId)
	v.Visit(v, "NeighborRouterId", &t.NeighborRouterId)
}
func (t *RouterInfo) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *RouterInfo) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Reserved)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	tmp30 := [2]byte{}
	binary.BigEndian.PutUint16(tmp30[:], uint16(t.Metric))
	if n, err := w.Write(tmp30[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Metric: %w", err)
	}
	tmp31 := [4]byte{}
	binary.BigEndian.PutUint32(tmp31[:], uint32(t.InterfaceId))
	if n, err := w.Write(tmp31[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.InterfaceId: %w", err)
	}
	tmp32 := [4]byte{}
	binary.BigEndian.PutUint32(tmp32[:], uint32(t.NeighborInterfaceId))
	if n, err := w.Write(tmp32[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.NeighborInterfaceId: %w", err)
	}
	tmp33 := [4]byte{}
	binary.BigEndian.PutUint32(tmp33[:], uint32(t.NeighborRouterId))
	if n, err := w.Write(tmp33[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.NeighborRouterId: %w", err)
	}
	return nil
}
func (t *RouterInfo) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 16))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *RouterInfo) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *RouterInfo) Read(r io.Reader) (err error) {
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint8(tmpType[0])
	tmpReserved := [1]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 1 byte but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint8(tmpReserved[0])
	tmpMetric := [2]byte{}
	n_Metric, err := io.ReadFull(r, tmpMetric[:])
	if err != nil {
		return fmt.Errorf("read Metric: expect 2 bytes but read %d bytes: %w", n_Metric, err)
	}
	t.Metric = uint16(binary.BigEndian.Uint16(tmpMetric[:]))
	tmpInterfaceId := [4]byte{}
	n_InterfaceId, err := io.ReadFull(r, tmpInterfaceId[:])
	if err != nil {
		return fmt.Errorf("read InterfaceId: expect 4 bytes but read %d bytes: %w", n_InterfaceId, err)
	}
	t.InterfaceId = uint32(binary.BigEndian.Uint32(tmpInterfaceId[:]))
	tmpNeighborInterfaceId := [4]byte{}
	n_NeighborInterfaceId, err := io.ReadFull(r, tmpNeighborInterfaceId[:])
	if err != nil {
		return fmt.Errorf("read NeighborInterfaceId: expect 4 bytes but read %d bytes: %w", n_NeighborInterfaceId, err)
	}
	t.NeighborInterfaceId = uint32(binary.BigEndian.Uint32(tmpNeighborInterfaceId[:]))
	tmpNeighborRouterId := [4]byte{}
	n_NeighborRouterId, err := io.ReadFull(r, tmpNeighborRouterId[:])
	if err != nil {
		return fmt.Errorf("read NeighborRouterId: expect 4 bytes but read %d bytes: %w", n_NeighborRouterId, err)
	}
	t.NeighborRouterId = uint32(binary.BigEndian.Uint32(tmpNeighborRouterId[:]))
	return nil
}

func (t *RouterInfo) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *RouterInfo) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode RouterInfo: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *RouterLsa) Reserved() uint8 {
	return ((t.flags34 & 0xe0) >> 5)
}
func (t *RouterLsa) SetReserved(v uint8) bool {
	if v > 7 {
		return false
	}
	t.flags34 = (t.flags34 & ^uint8(0xe0)) | ((v & 0x7) << 5)
	return true
}
func (t *RouterLsa) Nt() bool {
	return ((t.flags34 & 0x10) >> 4) == 1
}
func (t *RouterLsa) SetNt(v bool) {
	if v {
		t.flags34 |= uint8(0x10)
	} else {
		t.flags34 &= ^uint8(0x10)
	}
}
func (t *RouterLsa) X() bool {
	return ((t.flags34 & 0x08) >> 3) == 1
}
func (t *RouterLsa) SetX(v bool) {
	if v {
		t.flags34 |= uint8(0x8)
	} else {
		t.flags34 &= ^uint8(0x8)
	}
}
func (t *RouterLsa) V() bool {
	return ((t.flags34 & 0x04) >> 2) == 1
}
func (t *RouterLsa) SetV(v bool) {
	if v {
		t.flags34 |= uint8(0x4)
	} else {
		t.flags34 &= ^uint8(0x4)
	}
}
func (t *RouterLsa) E() bool {
	return ((t.flags34 & 0x02) >> 1) == 1
}
func (t *RouterLsa) SetE(v bool) {
	if v {
		t.flags34 |= uint8(0x2)
	} else {
		t.flags34 &= ^uint8(0x2)
	}
}
func (t *RouterLsa) B() bool {
	return ((t.flags34 & 0x01) >> 0) == 1
}
func (t *RouterLsa) SetB(v bool) {
	if v {
		t.flags34 |= uint8(0x1)
	} else {
		t.flags34 &= ^uint8(0x1)
	}
}
func (t *RouterLsa) Visit(v VisitorTIJJO) {
	v.Visit(v, "Reserved", t.Reserved())
	v.Visit(v, "Nt", (func() uint8 {
		if t.Nt() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "X", (func() uint8 {
		if t.X() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "V", (func() uint8 {
		if t.V() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "E", (func() uint8 {
		if t.E() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "B", (func() uint8 {
		if t.B() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Options", &t.Options)
	v.Visit(v, "LinkInfo", &t.LinkInfo)
}
func (t *RouterLsa) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *RouterLsa) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags34)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags34: %w", err)
	}
	if err := t.Options.Write(w); err != nil {
		return fmt.Errorf("encode Options: %w", err)
	}
	for _, v := range t.LinkInfo {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode LinkInfo: %w", err)
		}
	}
	return nil
}
func (t *RouterLsa) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *RouterLsa) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *RouterLsa) Read(r io.Reader) (err error) {
	tmpflags34 := [1]byte{}
	n_flags34, err := io.ReadFull(r, tmpflags34[:])
	if err != nil {
		return fmt.Errorf("read flags34: expect 1 byte but read %d bytes: %w", n_flags34, err)
	}
	t.flags34 = uint8(tmpflags34[0])
	if err := t.Options.Read(r); err != nil {
		return fmt.Errorf("read Options: %w", err)
	}
	tmp_byte_scanner35_ := bufio.NewReaderSize(r, 1)
	old_r_LinkInfo := r
	r = tmp_byte_scanner35_
	for {
		_, err := tmp_byte_scanner35_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read LinkInfo: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner35_.UnreadByte(); err != nil {
			return fmt.Errorf("read LinkInfo: unexpected unread error: %w", err)
		}
		var tmp36_ RouterInfo
		if err := tmp36_.Read(r); err != nil {
			return fmt.Errorf("read LinkInfo: %w", err)
		}
		t.LinkInfo = append(t.LinkInfo, tmp36_)
	}
	r = old_r_LinkInfo
	return nil
}

func (t *RouterLsa) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *RouterLsa) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode RouterLsa: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NetworkLsa) Visit(v VisitorTIJJO) {
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "Options", &t.Options)
	v.Visit(v, "AttachedRouters", &t.AttachedRouters)
}
func (t *NetworkLsa) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *NetworkLsa) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Reserved)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	if err := t.Options.Write(w); err != nil {
		return fmt.Errorf("encode Options: %w", err)
	}
	for _, v := range t.AttachedRouters {
		tmp37 := [4]byte{}
		binary.BigEndian.PutUint32(tmp37[:], uint32(v))
		if n, err := w.Write(tmp37[:]); err != nil || n != 4 {
			return fmt.Errorf("encode v: %w", err)
		}
	}
	return nil
}
func (t *NetworkLsa) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NetworkLsa) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NetworkLsa) Read(r io.Reader) (err error) {
	tmpReserved := [1]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 1 byte but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint8(tmpReserved[0])
	if err := t.Options.Read(r); err != nil {
		return fmt.Errorf("read Options: %w", err)
	}
	tmp_byte_scanner38_ := bufio.NewReaderSize(r, 1)
	old_r_AttachedRouters := r
	r = tmp_byte_scanner38_
	for {
		_, err := tmp_byte_scanner38_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read AttachedRouters: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner38_.UnreadByte(); err != nil {
			return fmt.Errorf("read AttachedRouters: unexpected unread error: %w", err)
		}
		var tmp39_ uint32
		tmpAttachedRouters := [4]byte{}
		n_AttachedRouters, err := io.ReadFull(r, tmpAttachedRouters[:])
		if err != nil {
			return fmt.Errorf("read AttachedRouters: expect 4 bytes but read %d bytes: %w", n_AttachedRouters, err)
		}
		tmp39_ = uint32(binary.BigEndian.Uint32(tmpAttachedRouters[:]))
		t.AttachedRouters = append(t.AttachedRouters, tmp39_)
	}
	r = old_r_AttachedRouters
	return nil
}

func (t *NetworkLsa) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NetworkLsa) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NetworkLsa: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *AddressPrefix) SetPrefix(v []uint8) bool {
	if len(v) > int(^uint8(0)) {
		return false
	}
	t.PrefixLen = uint8(len(v))
	t.Prefix = v
	return true
}
func (t *AddressPrefix) Visit(v VisitorTIJJO) {
	v.Visit(v, "PrefixLen", &t.PrefixLen)
	v.Visit(v, "Options", &t.Options)
	v.Visit(v, "Reserved2", &t.Reserved2)
	v.Visit(v, "Prefix", &t.Prefix)
}
func (t *AddressPrefix) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *AddressPrefix) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.PrefixLen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.PrefixLen: %w", err)
	}
	if err := t.Options.Write(w); err != nil {
		return fmt.Errorf("encode Options: %w", err)
	}
	tmp40 := [2]byte{}
	binary.BigEndian.PutUint16(tmp40[:], uint16(t.Reserved2))
	if n, err := w.Write(tmp40[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Reserved2: %w", err)
	}
	len_Prefix := int(t.PrefixLen)
	if len(t.Prefix) != len_Prefix {
		return fmt.Errorf("encode Prefix: expect %d bytes but got %d bytes", len_Prefix, len(t.Prefix))
	}
	if n, err := w.Write(t.Prefix); err != nil || n != len(t.Prefix) {
		return fmt.Errorf("encode Prefix: %w", err)
	}
	return nil
}
func (t *AddressPrefix) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *AddressPrefix) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *AddressPrefix) Read(r io.Reader) (err error) {
	tmpPrefixLen := [1]byte{}
	n_PrefixLen, err := io.ReadFull(r, tmpPrefixLen[:])
	if err != nil {
		return fmt.Errorf("read PrefixLen: expect 1 byte but read %d bytes: %w", n_PrefixLen, err)
	}
	t.PrefixLen = uint8(tmpPrefixLen[0])
	if err := t.Options.Read(r); err != nil {
		return fmt.Errorf("read Options: %w", err)
	}
	tmpReserved2 := [2]byte{}
	n_Reserved2, err := io.ReadFull(r, tmpReserved2[:])
	if err != nil {
		return fmt.Errorf("read Reserved2: expect 2 bytes but read %d bytes: %w", n_Reserved2, err)
	}
	t.Reserved2 = uint16(binary.BigEndian.Uint16(tmpReserved2[:]))
	len_Prefix := int(t.PrefixLen)
	if len_Prefix != 0 {
		tmpPrefix := make([]byte, len_Prefix)
		n_Prefix, err := io.ReadFull(r, tmpPrefix[:])
		if err != nil {
			return fmt.Errorf("read Prefix: expect %d bytes but read %d bytes: %w", len_Prefix, n_Prefix, err)
		}
		t.Prefix = tmpPrefix[:]
	} else {
		t.Prefix = nil
	}
	return nil
}

func (t *AddressPrefix) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *AddressPrefix) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode AddressPrefix: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *InterAreaPrefixLsa) Visit(v VisitorTIJJO) {
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "Metric", &t.Metric)
	v.Visit(v, "Prefix", &t.Prefix)
}
func (t *InterAreaPrefixLsa) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *InterAreaPrefixLsa) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Reserved)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Metric >> 16), byte(t.Metric >> 8), byte(t.Metric)}); err != nil || n != 3 {
		return fmt.Errorf("encode t.Metric: %w", err)
	}
	if err := t.Prefix.Write(w); err != nil {
		return fmt.Errorf("encode Prefix: %w", err)
	}
	return nil
}
func (t *InterAreaPrefixLsa) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *InterAreaPrefixLsa) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *InterAreaPrefixLsa) Read(r io.Reader) (err error) {
	tmpReserved := [1]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 1 byte but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint8(tmpReserved[0])
	tmpMetric := [3]byte{}
	n_Metric, err := io.ReadFull(r, tmpMetric[:])
	if err != nil {
		return fmt.Errorf("read Metric: expect 3 bytes but read %d bytes: %w", n_Metric, err)
	}
	t.Metric = uint32(uint32(tmpMetric[0])<<16 | uint32(tmpMetric[1])<<8 | uint32(tmpMetric[2]))
	if err := t.Prefix.Read(r); err != nil {
		return fmt.Errorf("read Prefix: %w", err)
	}
	return nil
}

func (t *InterAreaPrefixLsa) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *InterAreaPrefixLsa) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode InterAreaPrefixLsa: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *InterAreaRouterLsa) Visit(v VisitorTIJJO) {
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "Option", &t.Option)
	v.Visit(v, "Reserved2", &t.Reserved2)
	v.Visit(v, "Metric", &t.Metric)
	v.Visit(v, "DestRouterId", &t.DestRouterId)
}
func (t *InterAreaRouterLsa) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *InterAreaRouterLsa) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Reserved)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	if err := t.Option.Write(w); err != nil {
		return fmt.Errorf("encode Option: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Reserved2)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Reserved2: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Metric >> 16), byte(t.Metric >> 8), byte(t.Metric)}); err != nil || n != 3 {
		return fmt.Errorf("encode t.Metric: %w", err)
	}
	tmp41 := [4]byte{}
	binary.BigEndian.PutUint32(tmp41[:], uint32(t.DestRouterId))
	if n, err := w.Write(tmp41[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.DestRouterId: %w", err)
	}
	return nil
}
func (t *InterAreaRouterLsa) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 12))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *InterAreaRouterLsa) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *InterAreaRouterLsa) Read(r io.Reader) (err error) {
	tmpReserved := [1]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 1 byte but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint8(tmpReserved[0])
	if err := t.Option.Read(r); err != nil {
		return fmt.Errorf("read Option: %w", err)
	}
	tmpReserved2 := [1]byte{}
	n_Reserved2, err := io.ReadFull(r, tmpReserved2[:])
	if err != nil {
		return fmt.Errorf("read Reserved2: expect 1 byte but read %d bytes: %w", n_Reserved2, err)
	}
	t.Reserved2 = uint8(tmpReserved2[0])
	tmpMetric := [3]byte{}
	n_Metric, err := io.ReadFull(r, tmpMetric[:])
	if err != nil {
		return fmt.Errorf("read Metric: expect 3 bytes but read %d bytes: %w", n_Metric, err)
	}
	t.Metric = uint32(uint32(tmpMetric[0])<<16 | uint32(tmpMetric[1])<<8 | uint32(tmpMetric[2]))
	tmpDestRouterId := [4]byte{}
	n_DestRouterId, err := io.ReadFull(r, tmpDestRouterId[:])
	if err != nil {
		return fmt.Errorf("read DestRouterId: expect 4 bytes but read %d bytes: %w", n_DestRouterId, err)
	}
	t.DestRouterId = uint32(binary.BigEndian.Uint32(tmpDestRouterId[:]))
	return nil
}

func (t *InterAreaRouterLsa) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *InterAreaRouterLsa) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode InterAreaRouterLsa: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *AsexternalLsa) Reserved() uint8 {
	return ((t.flags42 & 0xf8) >> 3)
}
func (t *AsexternalLsa) SetReserved(v uint8) bool {
	if v > 31 {
		return false
	}
	t.flags42 = (t.flags42 & ^uint8(0xf8)) | ((v & 0x1f) << 3)
	return true
}
func (t *AsexternalLsa) External() bool {
	return ((t.flags42 & 0x04) >> 2) == 1
}
func (t *AsexternalLsa) SetExternal(v bool) {
	if v {
		t.flags42 |= uint8(0x4)
	} else {
		t.flags42 &= ^uint8(0x4)
	}
}
func (t *AsexternalLsa) HasForwardingAddress() bool {
	return ((t.flags42 & 0x02) >> 1) == 1
}
func (t *AsexternalLsa) SetHasForwardingAddress(v bool) {
	if v {
		t.flags42 |= uint8(0x2)
	} else {
		t.flags42 &= ^uint8(0x2)
	}
}
func (t *AsexternalLsa) HasExternalRouteTag() bool {
	return ((t.flags42 & 0x01) >> 0) == 1
}
func (t *AsexternalLsa) SetHasExternalRouteTag(v bool) {
	if v {
		t.flags42 |= uint8(0x1)
	} else {
		t.flags42 &= ^uint8(0x1)
	}
}
func (t *union_45_t) isunion43_() {}
func (t *AsexternalLsa) ForwardingAddress() *[16]uint8 {
	if true == ((func() uint8 {
		if t.HasForwardingAddress() {
			return 1
		} else {
			return 0
		}
	}()) == 1) {
		if _, ok := t.union43_.(*union_45_t); !ok {
			return nil // not set
		}
		tmp := [16]uint8(t.union43_.(*union_45_t).ForwardingAddress[:])
		return &tmp
	}
	return nil
}
func (t *AsexternalLsa) SetForwardingAddress(v [16]uint8) bool {
	if true == ((func() uint8 {
		if t.HasForwardingAddress() {
			return 1
		} else {
			return 0
		}
	}()) == 1) {
		if _, ok := t.union43_.(*union_45_t); !ok {
			t.union43_ = &union_45_t{}
		}
		t.union43_.(*union_45_t).ForwardingAddress = [16]uint8(v)
		return true
	}
	return false
}
func (t *union_48_t) isunion46_() {}
func (t *AsexternalLsa) ExternalRouteTag() *uint32 {
	if true == ((func() uint8 {
		if t.HasExternalRouteTag() {
			return 1
		} else {
			return 0
		}
	}()) == 1) {
		if _, ok := t.union46_.(*union_48_t); !ok {
			return nil // not set
		}
		tmp := uint32(t.union46_.(*union_48_t).ExternalRouteTag)
		return &tmp
	}
	return nil
}
func (t *AsexternalLsa) SetExternalRouteTag(v uint32) bool {
	if true == ((func() uint8 {
		if t.HasExternalRouteTag() {
			return 1
		} else {
			return 0
		}
	}()) == 1) {
		if _, ok := t.union46_.(*union_48_t); !ok {
			t.union46_ = &union_48_t{}
		}
		t.union46_.(*union_48_t).ExternalRouteTag = uint32(v)
		return true
	}
	return false
}
func (t *union_51_t) isunion49_() {}
func (t *AsexternalLsa) ReferencedLinkStateId() *uint32 {
	if true == (t.ReferencedLsType != 0) {
		if _, ok := t.union49_.(*union_51_t); !ok {
			return nil // not set
		}
		tmp := uint32(t.union49_.(*union_51_t).ReferencedLinkStateId)
		return &tmp
	}
	return nil
}
func (t *AsexternalLsa) SetReferencedLinkStateId(v uint32) bool {
	if true == (t.ReferencedLsType != 0) {
		if _, ok := t.union49_.(*union_51_t); !ok {
			t.union49_ = &union_51_t{}
		}
		t.union49_.(*union_51_t).ReferencedLinkStateId = uint32(v)
		return true
	}
	return false
}
func (t *AsexternalLsa) Visit(v VisitorTIJJO) {
	v.Visit(v, "Reserved", t.Reserved())
	v.Visit(v, "External", (func() uint8 {
		if t.External() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "HasForwardingAddress", (func() uint8 {
		if t.HasForwardingAddress() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "HasExternalRouteTag", (func() uint8 {
		if t.HasExternalRouteTag() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Metric", &t.Metric)
	v.Visit(v, "PrefixLen", &t.PrefixLen)
	v.Visit(v, "PrefixOptions", &t.PrefixOptions)
	v.Visit(v, "ReferencedLsType", &t.ReferencedLsType)
	v.Visit(v, "ForwardingAddress", (t.ForwardingAddress()))
	v.Visit(v, "ExternalRouteTag", (t.ExternalRouteTag()))
	v.Visit(v, "ReferencedLinkStateId", (t.ReferencedLinkStateId()))
}
func (t *AsexternalLsa) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *AsexternalLsa) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags42)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags42: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Metric >> 16), byte(t.Metric >> 8), byte(t.Metric)}); err != nil || n != 3 {
		return fmt.Errorf("encode t.Metric: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.PrefixLen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.PrefixLen: %w", err)
	}
	if err := t.PrefixOptions.Write(w); err != nil {
		return fmt.Errorf("encode PrefixOptions: %w", err)
	}
	tmp52 := [2]byte{}
	binary.BigEndian.PutUint16(tmp52[:], uint16(t.ReferencedLsType))
	if n, err := w.Write(tmp52[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.ReferencedLsType: %w", err)
	}
	if (func() uint8 {
		if t.HasForwardingAddress() {
			return 1
		} else {
			return 0
		}
	}()) == 1 {
		if _, ok := t.union43_.(*union_45_t); !ok {
			return fmt.Errorf("encode t.union43_: union is not set to union_45_t")
		}
		if n, err := w.Write(t.union43_.(*union_45_t).ForwardingAddress[:]); err != nil || n != len(t.union43_.(*union_45_t).ForwardingAddress) {
			return fmt.Errorf("encode ForwardingAddress: %w", err)
		}
	}
	if (func() uint8 {
		if t.HasExternalRouteTag() {
			return 1
		} else {
			return 0
		}
	}()) == 1 {
		if _, ok := t.union46_.(*union_48_t); !ok {
			return fmt.Errorf("encode t.union46_: union is not set to union_48_t")
		}
		tmp53 := [4]byte{}
		binary.BigEndian.PutUint32(tmp53[:], uint32(t.union46_.(*union_48_t).ExternalRouteTag))
		if n, err := w.Write(tmp53[:]); err != nil || n != 4 {
			return fmt.Errorf("encode t.union46_.(*union_48_t).ExternalRouteTag: %w", err)
		}
	}
	if t.ReferencedLsType != 0 {
		if _, ok := t.union49_.(*union_51_t); !ok {
			return fmt.Errorf("encode t.union49_: union is not set to union_51_t")
		}
		tmp54 := [4]byte{}
		binary.BigEndian.PutUint32(tmp54[:], uint32(t.union49_.(*union_51_t).ReferencedLinkStateId))
		if n, err := w.Write(tmp54[:]); err != nil || n != 4 {
			return fmt.Errorf("encode t.union49_.(*union_51_t).ReferencedLinkStateId: %w", err)
		}
	}
	return nil
}
func (t *AsexternalLsa) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *AsexternalLsa) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *AsexternalLsa) Read(r io.Reader) (err error) {
	tmpflags42 := [1]byte{}
	n_flags42, err := io.ReadFull(r, tmpflags42[:])
	if err != nil {
		return fmt.Errorf("read flags42: expect 1 byte but read %d bytes: %w", n_flags42, err)
	}
	t.flags42 = uint8(tmpflags42[0])
	tmpMetric := [3]byte{}
	n_Metric, err := io.ReadFull(r, tmpMetric[:])
	if err != nil {
		return fmt.Errorf("read Metric: expect 3 bytes but read %d bytes: %w", n_Metric, err)
	}
	t.Metric = uint32(uint32(tmpMetric[0])<<16 | uint32(tmpMetric[1])<<8 | uint32(tmpMetric[2]))
	tmpPrefixLen := [1]byte{}
	n_PrefixLen, err := io.ReadFull(r, tmpPrefixLen[:])
	if err != nil {
		return fmt.Errorf("read PrefixLen: expect 1 byte but read %d bytes: %w", n_PrefixLen, err)
	}
	t.PrefixLen = uint8(tmpPrefixLen[0])
	if err := t.PrefixOptions.Read(r); err != nil {
		return fmt.Errorf("read PrefixOptions: %w", err)
	}
	tmpReferencedLsType := [2]byte{}
	n_ReferencedLsType, err := io.ReadFull(r, tmpReferencedLsType[:])
	if err != nil {
		return fmt.Errorf("read ReferencedLsType: expect 2 bytes but read %d bytes: %w", n_ReferencedLsType, err)
	}
	t.ReferencedLsType = uint16(binary.BigEndian.Uint16(tmpReferencedLsType[:]))
	if (func() uint8 {
		if t.HasForwardingAddress() {
			return 1
		} else {
			return 0
		}
	}()) == 1 {
		t.union43_ = &union_45_t{}
		n_ForwardingAddress, err := io.ReadFull(r, t.union43_.(*union_45_t).ForwardingAddress[:])
		if err != nil {
			return fmt.Errorf("read ForwardingAddress: expect %d bytes but read %d bytes: %w", 16, n_ForwardingAddress, err)
		}
	}
	if (func() uint8 {
		if t.HasExternalRouteTag() {
			return 1
		} else {
			return 0
		}
	}()) == 1 {
		t.union46_ = &union_48_t{}
		tmpExternalRouteTag := [4]byte{}
		n_ExternalRouteTag, err := io.ReadFull(r, tmpExternalRouteTag[:])
		if err != nil {
			return fmt.Errorf("read ExternalRouteTag: expect 4 bytes but read %d bytes: %w", n_ExternalRouteTag, err)
		}
		t.union46_.(*union_48_t).ExternalRouteTag = uint32(binary.BigEndian.Uint32(tmpExternalRouteTag[:]))
	}
	if t.ReferencedLsType != 0 {
		t.union49_ = &union_51_t{}
		tmpReferencedLinkStateId := [4]byte{}
		n_ReferencedLinkStateId, err := io.ReadFull(r, tmpReferencedLinkStateId[:])
		if err != nil {
			return fmt.Errorf("read ReferencedLinkStateId: expect 4 bytes but read %d bytes: %w", n_ReferencedLinkStateId, err)
		}
		t.union49_.(*union_51_t).ReferencedLinkStateId = uint32(binary.BigEndian.Uint32(tmpReferencedLinkStateId[:]))
	}
	return nil
}

func (t *AsexternalLsa) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *AsexternalLsa) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode AsexternalLsa: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *LinkLsa) SetPrefixes(v []AddressPrefix) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.NumPrefixes = uint16(len(v))
	t.Prefixes = v
	return true
}
func (t *LinkLsa) Visit(v VisitorTIJJO) {
	v.Visit(v, "RtrPriority", &t.RtrPriority)
	v.Visit(v, "Options", &t.Options)
	v.Visit(v, "LinkLocalInterfaceAddress", &t.LinkLocalInterfaceAddress)
	v.Visit(v, "NumPrefixes", &t.NumPrefixes)
	v.Visit(v, "Prefixes", &t.Prefixes)
}
func (t *LinkLsa) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *LinkLsa) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.RtrPriority)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.RtrPriority: %w", err)
	}
	if err := t.Options.Write(w); err != nil {
		return fmt.Errorf("encode Options: %w", err)
	}
	if n, err := w.Write(t.LinkLocalInterfaceAddress[:]); err != nil || n != len(t.LinkLocalInterfaceAddress) {
		return fmt.Errorf("encode LinkLocalInterfaceAddress: %w", err)
	}
	tmp55 := [2]byte{}
	binary.BigEndian.PutUint16(tmp55[:], uint16(t.NumPrefixes))
	if n, err := w.Write(tmp55[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.NumPrefixes: %w", err)
	}
	len_Prefixes := int(t.NumPrefixes)
	if len(t.Prefixes) != len_Prefixes {
		return fmt.Errorf("encode Prefixes: expect %d but got %d for length", len_Prefixes, len(t.Prefixes))
	}
	for _, v := range t.Prefixes {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Prefixes: %w", err)
		}
	}
	return nil
}
func (t *LinkLsa) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 22))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *LinkLsa) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *LinkLsa) Read(r io.Reader) (err error) {
	tmpRtrPriority := [1]byte{}
	n_RtrPriority, err := io.ReadFull(r, tmpRtrPriority[:])
	if err != nil {
		return fmt.Errorf("read RtrPriority: expect 1 byte but read %d bytes: %w", n_RtrPriority, err)
	}
	t.RtrPriority = uint8(tmpRtrPriority[0])
	if err := t.Options.Read(r); err != nil {
		return fmt.Errorf("read Options: %w", err)
	}
	n_LinkLocalInterfaceAddress, err := io.ReadFull(r, t.LinkLocalInterfaceAddress[:])
	if err != nil {
		return fmt.Errorf("read LinkLocalInterfaceAddress: expect %d bytes but read %d bytes: %w", 16, n_LinkLocalInterfaceAddress, err)
	}
	tmpNumPrefixes := [2]byte{}
	n_NumPrefixes, err := io.ReadFull(r, tmpNumPrefixes[:])
	if err != nil {
		return fmt.Errorf("read NumPrefixes: expect 2 bytes but read %d bytes: %w", n_NumPrefixes, err)
	}
	t.NumPrefixes = uint16(binary.BigEndian.Uint16(tmpNumPrefixes[:]))
	len_Prefixes := int(t.NumPrefixes)
	for i_56 := 0; i_56 < len_Prefixes; i_56++ {
		var tmp57_ AddressPrefix
		if err := tmp57_.Read(r); err != nil {
			return fmt.Errorf("read Prefixes: %w", err)
		}
		t.Prefixes = append(t.Prefixes, tmp57_)
	}
	return nil
}

func (t *LinkLsa) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *LinkLsa) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode LinkLsa: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *IntraAreaPrefixLsa) SetPrefixes(v []AddressPrefix) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.NumPrefixes = uint16(len(v))
	t.Prefixes = v
	return true
}
func (t *IntraAreaPrefixLsa) Visit(v VisitorTIJJO) {
	v.Visit(v, "NumPrefixes", &t.NumPrefixes)
	v.Visit(v, "ReferencedLsType", &t.ReferencedLsType)
	v.Visit(v, "ReferencedLinkStateId", &t.ReferencedLinkStateId)
	v.Visit(v, "Prefixes", &t.Prefixes)
}
func (t *IntraAreaPrefixLsa) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *IntraAreaPrefixLsa) Write(w io.Writer) (err error) {
	tmp58 := [2]byte{}
	binary.BigEndian.PutUint16(tmp58[:], uint16(t.NumPrefixes))
	if n, err := w.Write(tmp58[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.NumPrefixes: %w", err)
	}
	tmp59 := [2]byte{}
	binary.BigEndian.PutUint16(tmp59[:], uint16(t.ReferencedLsType))
	if n, err := w.Write(tmp59[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.ReferencedLsType: %w", err)
	}
	tmp60 := [4]byte{}
	binary.BigEndian.PutUint32(tmp60[:], uint32(t.ReferencedLinkStateId))
	if n, err := w.Write(tmp60[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.ReferencedLinkStateId: %w", err)
	}
	len_Prefixes := int(t.NumPrefixes)
	if len(t.Prefixes) != len_Prefixes {
		return fmt.Errorf("encode Prefixes: expect %d but got %d for length", len_Prefixes, len(t.Prefixes))
	}
	for _, v := range t.Prefixes {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Prefixes: %w", err)
		}
	}
	return nil
}
func (t *IntraAreaPrefixLsa) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *IntraAreaPrefixLsa) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *IntraAreaPrefixLsa) Read(r io.Reader) (err error) {
	tmpNumPrefixes := [2]byte{}
	n_NumPrefixes, err := io.ReadFull(r, tmpNumPrefixes[:])
	if err != nil {
		return fmt.Errorf("read NumPrefixes: expect 2 bytes but read %d bytes: %w", n_NumPrefixes, err)
	}
	t.NumPrefixes = uint16(binary.BigEndian.Uint16(tmpNumPrefixes[:]))
	tmpReferencedLsType := [2]byte{}
	n_ReferencedLsType, err := io.ReadFull(r, tmpReferencedLsType[:])
	if err != nil {
		return fmt.Errorf("read ReferencedLsType: expect 2 bytes but read %d bytes: %w", n_ReferencedLsType, err)
	}
	t.ReferencedLsType = uint16(binary.BigEndian.Uint16(tmpReferencedLsType[:]))
	tmpReferencedLinkStateId := [4]byte{}
	n_ReferencedLinkStateId, err := io.ReadFull(r, tmpReferencedLinkStateId[:])
	if err != nil {
		return fmt.Errorf("read ReferencedLinkStateId: expect 4 bytes but read %d bytes: %w", n_ReferencedLinkStateId, err)
	}
	t.ReferencedLinkStateId = uint32(binary.BigEndian.Uint32(tmpReferencedLinkStateId[:]))
	len_Prefixes := int(t.NumPrefixes)
	for i_61 := 0; i_61 < len_Prefixes; i_61++ {
		var tmp62_ AddressPrefix
		if err := tmp62_.Read(r); err != nil {
			return fmt.Errorf("read Prefixes: %w", err)
		}
		t.Prefixes = append(t.Prefixes, tmp62_)
	}
	return nil
}

func (t *IntraAreaPrefixLsa) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *IntraAreaPrefixLsa) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode IntraAreaPrefixLsa: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_65_t) isunion63_() {}
func (t *union_66_t) isunion63_() {}
func (t *union_67_t) isunion63_() {}
func (t *union_68_t) isunion63_() {}
func (t *union_69_t) isunion63_() {}
func (t *union_70_t) isunion63_() {}
func (t *union_71_t) isunion63_() {}
func (t *union_72_t) isunion63_() {}
func (t *Lsa) AsExternalLsa() *AsexternalLsa {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_NetworkLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaPrefixLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaRouterLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_AsExternalLsa {
		if _, ok := t.union63_.(*union_69_t); !ok {
			return nil // not set
		}
		tmp := AsexternalLsa(t.union63_.(*union_69_t).AsExternalLsa)
		return &tmp
	}
	return nil
}
func (t *Lsa) SetAsExternalLsa(v AsexternalLsa) bool {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_NetworkLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaPrefixLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaRouterLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_AsExternalLsa {
		if _, ok := t.union63_.(*union_69_t); !ok {
			t.union63_ = &union_69_t{}
		}
		t.union63_.(*union_69_t).AsExternalLsa = AsexternalLsa(v)
		return true
	}
	return false
}
func (t *Lsa) Data() *[]uint8 {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_NetworkLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaPrefixLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaRouterLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_AsExternalLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_LinkLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_IntraAreaPrefixLsa {
		return nil
	} else if true {
		if _, ok := t.union63_.(*union_72_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union63_.(*union_72_t).Data)
		return &tmp
	}
	return nil
}
func (t *Lsa) SetData(v []uint8) bool {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_NetworkLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaPrefixLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaRouterLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_AsExternalLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_LinkLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_IntraAreaPrefixLsa {
		return false
	} else if true {
		if _, ok := t.union63_.(*union_72_t); !ok {
			t.union63_ = &union_72_t{}
		}
		t.union63_.(*union_72_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *Lsa) InterAreaPrefixLsa() *InterAreaPrefixLsa {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_NetworkLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaPrefixLsa {
		if _, ok := t.union63_.(*union_67_t); !ok {
			return nil // not set
		}
		tmp := InterAreaPrefixLsa(t.union63_.(*union_67_t).InterAreaPrefixLsa)
		return &tmp
	}
	return nil
}
func (t *Lsa) SetInterAreaPrefixLsa(v InterAreaPrefixLsa) bool {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_NetworkLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaPrefixLsa {
		if _, ok := t.union63_.(*union_67_t); !ok {
			t.union63_ = &union_67_t{}
		}
		t.union63_.(*union_67_t).InterAreaPrefixLsa = InterAreaPrefixLsa(v)
		return true
	}
	return false
}
func (t *Lsa) InterAreaRouterLsa() *InterAreaRouterLsa {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_NetworkLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaPrefixLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaRouterLsa {
		if _, ok := t.union63_.(*union_68_t); !ok {
			return nil // not set
		}
		tmp := InterAreaRouterLsa(t.union63_.(*union_68_t).InterAreaRouterLsa)
		return &tmp
	}
	return nil
}
func (t *Lsa) SetInterAreaRouterLsa(v InterAreaRouterLsa) bool {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_NetworkLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaPrefixLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaRouterLsa {
		if _, ok := t.union63_.(*union_68_t); !ok {
			t.union63_ = &union_68_t{}
		}
		t.union63_.(*union_68_t).InterAreaRouterLsa = InterAreaRouterLsa(v)
		return true
	}
	return false
}
func (t *Lsa) IntraAreaPrefixLsa() *IntraAreaPrefixLsa {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_NetworkLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaPrefixLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaRouterLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_AsExternalLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_LinkLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_IntraAreaPrefixLsa {
		if _, ok := t.union63_.(*union_71_t); !ok {
			return nil // not set
		}
		tmp := IntraAreaPrefixLsa(t.union63_.(*union_71_t).IntraAreaPrefixLsa)
		return &tmp
	}
	return nil
}
func (t *Lsa) SetIntraAreaPrefixLsa(v IntraAreaPrefixLsa) bool {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_NetworkLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaPrefixLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaRouterLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_AsExternalLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_LinkLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_IntraAreaPrefixLsa {
		if _, ok := t.union63_.(*union_71_t); !ok {
			t.union63_ = &union_71_t{}
		}
		t.union63_.(*union_71_t).IntraAreaPrefixLsa = IntraAreaPrefixLsa(v)
		return true
	}
	return false
}
func (t *Lsa) LinkLsa() *LinkLsa {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_NetworkLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaPrefixLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaRouterLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_AsExternalLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_LinkLsa {
		if _, ok := t.union63_.(*union_70_t); !ok {
			return nil // not set
		}
		tmp := LinkLsa(t.union63_.(*union_70_t).LinkLsa)
		return &tmp
	}
	return nil
}
func (t *Lsa) SetLinkLsa(v LinkLsa) bool {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_NetworkLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaPrefixLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_InterAreaRouterLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_AsExternalLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_LinkLsa {
		if _, ok := t.union63_.(*union_70_t); !ok {
			t.union63_ = &union_70_t{}
		}
		t.union63_.(*union_70_t).LinkLsa = LinkLsa(v)
		return true
	}
	return false
}
func (t *Lsa) NetworkLsa() *NetworkLsa {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		return nil
	} else if t.LsaHeader.LsType == LsafunctionCode_NetworkLsa {
		if _, ok := t.union63_.(*union_66_t); !ok {
			return nil // not set
		}
		tmp := NetworkLsa(t.union63_.(*union_66_t).NetworkLsa)
		return &tmp
	}
	return nil
}
func (t *Lsa) SetNetworkLsa(v NetworkLsa) bool {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		return false
	} else if t.LsaHeader.LsType == LsafunctionCode_NetworkLsa {
		if _, ok := t.union63_.(*union_66_t); !ok {
			t.union63_ = &union_66_t{}
		}
		t.union63_.(*union_66_t).NetworkLsa = NetworkLsa(v)
		return true
	}
	return false
}
func (t *Lsa) RouterLsa() *RouterLsa {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		if _, ok := t.union63_.(*union_65_t); !ok {
			return nil // not set
		}
		tmp := RouterLsa(t.union63_.(*union_65_t).RouterLsa)
		return &tmp
	}
	return nil
}
func (t *Lsa) SetRouterLsa(v RouterLsa) bool {
	if t.LsaHeader.LsType == LsafunctionCode_RouterLsa {
		if _, ok := t.union63_.(*union_65_t); !ok {
			t.union63_ = &union_65_t{}
		}
		t.union63_.(*union_65_t).RouterLsa = RouterLsa(v)
		return true
	}
	return false
}
func (t *Lsa) Visit(v VisitorTIJJO) {
	v.Visit(v, "LsaHeader", &t.LsaHeader)
	v.Visit(v, "AsExternalLsa", (t.AsExternalLsa()))
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "InterAreaPrefixLsa", (t.InterAreaPrefixLsa()))
	v.Visit(v, "InterAreaRouterLsa", (t.InterAreaRouterLsa()))
	v.Visit(v, "IntraAreaPrefixLsa", (t.IntraAreaPrefixLsa()))
	v.Visit(v, "LinkLsa", (t.LinkLsa()))
	v.Visit(v, "NetworkLsa", (t.NetworkLsa()))
	v.Visit(v, "RouterLsa", (t.RouterLsa()))
}
func (t *Lsa) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *Lsa) Write(w io.Writer) (err error) {
	if err := t.LsaHeader.Write(w); err != nil {
		return fmt.Errorf("encode LsaHeader: %w", err)
	}
	switch {
	case (t.LsaHeader.LsType == LsafunctionCode_RouterLsa):
		if _, ok := t.union63_.(*union_65_t); !ok {
			return fmt.Errorf("encode t.union63_: union is not set to union_65_t")
		}
		new_buf_73 := bytes.NewBuffer(nil)
		old_buf_73_w := w
		w = new_buf_73
		if err := t.union63_.(*union_65_t).RouterLsa.Write(w); err != nil {
			return fmt.Errorf("encode RouterLsa: %w", err)
		}
		if new_buf_73.Len() != int((t.LsaHeader.Length - 20)) {
			return fmt.Errorf("encode RouterLsa: expect %d bytes but got %d bytes", new_buf_73.Len(), int((t.LsaHeader.Length - 20)))
		}
		_, err = new_buf_73.WriteTo(old_buf_73_w)
		if err != nil {
			return err
		}
		w = old_buf_73_w
	case (t.LsaHeader.LsType == LsafunctionCode_NetworkLsa):
		if _, ok := t.union63_.(*union_66_t); !ok {
			return fmt.Errorf("encode t.union63_: union is not set to union_66_t")
		}
		new_buf_74 := bytes.NewBuffer(nil)
		old_buf_74_w := w
		w = new_buf_74
		if err := t.union63_.(*union_66_t).NetworkLsa.Write(w); err != nil {
			return fmt.Errorf("encode NetworkLsa: %w", err)
		}
		if new_buf_74.Len() != int((t.LsaHeader.Length - 20)) {
			return fmt.Errorf("encode NetworkLsa: expect %d bytes but got %d bytes", new_buf_74.Len(), int((t.LsaHeader.Length - 20)))
		}
		_, err = new_buf_74.WriteTo(old_buf_74_w)
		if err != nil {
			return err
		}
		w = old_buf_74_w
	case (t.LsaHeader.LsType == LsafunctionCode_InterAreaPrefixLsa):
		if _, ok := t.union63_.(*union_67_t); !ok {
			return fmt.Errorf("encode t.union63_: union is not set to union_67_t")
		}
		new_buf_75 := bytes.NewBuffer(nil)
		old_buf_75_w := w
		w = new_buf_75
		if err := t.union63_.(*union_67_t).InterAreaPrefixLsa.Write(w); err != nil {
			return fmt.Errorf("encode InterAreaPrefixLsa: %w", err)
		}
		if new_buf_75.Len() != int((t.LsaHeader.Length - 20)) {
			return fmt.Errorf("encode InterAreaPrefixLsa: expect %d bytes but got %d bytes", new_buf_75.Len(), int((t.LsaHeader.Length - 20)))
		}
		_, err = new_buf_75.WriteTo(old_buf_75_w)
		if err != nil {
			return err
		}
		w = old_buf_75_w
	case (t.LsaHeader.LsType == LsafunctionCode_InterAreaRouterLsa):
		if _, ok := t.union63_.(*union_68_t); !ok {
			return fmt.Errorf("encode t.union63_: union is not set to union_68_t")
		}
		new_buf_76 := bytes.NewBuffer(nil)
		old_buf_76_w := w
		w = new_buf_76
		if err := t.union63_.(*union_68_t).InterAreaRouterLsa.Write(w); err != nil {
			return fmt.Errorf("encode InterAreaRouterLsa: %w", err)
		}
		if new_buf_76.Len() != int((t.LsaHeader.Length - 20)) {
			return fmt.Errorf("encode InterAreaRouterLsa: expect %d bytes but got %d bytes", new_buf_76.Len(), int((t.LsaHeader.Length - 20)))
		}
		_, err = new_buf_76.WriteTo(old_buf_76_w)
		if err != nil {
			return err
		}
		w = old_buf_76_w
	case (t.LsaHeader.LsType == LsafunctionCode_AsExternalLsa):
		if _, ok := t.union63_.(*union_69_t); !ok {
			return fmt.Errorf("encode t.union63_: union is not set to union_69_t")
		}
		new_buf_77 := bytes.NewBuffer(nil)
		old_buf_77_w := w
		w = new_buf_77
		if err := t.union63_.(*union_69_t).AsExternalLsa.Write(w); err != nil {
			return fmt.Errorf("encode AsExternalLsa: %w", err)
		}
		if new_buf_77.Len() != int((t.LsaHeader.Length - 20)) {
			return fmt.Errorf("encode AsExternalLsa: expect %d bytes but got %d bytes", new_buf_77.Len(), int((t.LsaHeader.Length - 20)))
		}
		_, err = new_buf_77.WriteTo(old_buf_77_w)
		if err != nil {
			return err
		}
		w = old_buf_77_w
	case (t.LsaHeader.LsType == LsafunctionCode_LinkLsa):
		if _, ok := t.union63_.(*union_70_t); !ok {
			return fmt.Errorf("encode t.union63_: union is not set to union_70_t")
		}
		new_buf_78 := bytes.NewBuffer(nil)
		old_buf_78_w := w
		w = new_buf_78
		if err := t.union63_.(*union_70_t).LinkLsa.Write(w); err != nil {
			return fmt.Errorf("encode LinkLsa: %w", err)
		}
		if new_buf_78.Len() != int((t.LsaHeader.Length - 20)) {
			return fmt.Errorf("encode LinkLsa: expect %d bytes but got %d bytes", new_buf_78.Len(), int((t.LsaHeader.Length - 20)))
		}
		_, err = new_buf_78.WriteTo(old_buf_78_w)
		if err != nil {
			return err
		}
		w = old_buf_78_w
	case (t.LsaHeader.LsType == LsafunctionCode_IntraAreaPrefixLsa):
		if _, ok := t.union63_.(*union_71_t); !ok {
			return fmt.Errorf("encode t.union63_: union is not set to union_71_t")
		}
		new_buf_79 := bytes.NewBuffer(nil)
		old_buf_79_w := w
		w = new_buf_79
		if err := t.union63_.(*union_71_t).IntraAreaPrefixLsa.Write(w); err != nil {
			return fmt.Errorf("encode IntraAreaPrefixLsa: %w", err)
		}
		if new_buf_79.Len() != int((t.LsaHeader.Length - 20)) {
			return fmt.Errorf("encode IntraAreaPrefixLsa: expect %d bytes but got %d bytes", new_buf_79.Len(), int((t.LsaHeader.Length - 20)))
		}
		_, err = new_buf_79.WriteTo(old_buf_79_w)
		if err != nil {
			return err
		}
		w = old_buf_79_w
	default:
		if _, ok := t.union63_.(*union_72_t); !ok {
			return fmt.Errorf("encode t.union63_: union is not set to union_72_t")
		}
		len_Data := int((t.LsaHeader.Length - 20))
		if len(t.union63_.(*union_72_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union63_.(*union_72_t).Data))
		}
		if n, err := w.Write(t.union63_.(*union_72_t).Data); err != nil || n != len(t.union63_.(*union_72_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *Lsa) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 20))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Lsa) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Lsa) Read(r io.Reader) (err error) {
	if err := t.LsaHeader.Read(r); err != nil {
		return fmt.Errorf("read LsaHeader: %w", err)
	}
	switch {
	case (t.LsaHeader.LsType == LsafunctionCode_RouterLsa):
		t.union63_ = &union_65_t{}
		sub_byte_len_RouterLsa := int64((t.LsaHeader.Length - 20))
		sub_byte_r_RouterLsa := io.LimitReader(r, int64(sub_byte_len_RouterLsa))
		tmp_old_r_RouterLsa_80 := r
		r = sub_byte_r_RouterLsa
		if err := t.union63_.(*union_65_t).RouterLsa.Read(r); err != nil {
			return fmt.Errorf("read RouterLsa: %w", err)
		}
		if sub_byte_r_RouterLsa.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read RouterLsa: expect %d bytes but got %d bytes", sub_byte_len_RouterLsa, sub_byte_len_RouterLsa-sub_byte_r_RouterLsa.(*io.LimitedReader).N)
		}
		r = tmp_old_r_RouterLsa_80
	case (t.LsaHeader.LsType == LsafunctionCode_NetworkLsa):
		t.union63_ = &union_66_t{}
		sub_byte_len_NetworkLsa := int64((t.LsaHeader.Length - 20))
		sub_byte_r_NetworkLsa := io.LimitReader(r, int64(sub_byte_len_NetworkLsa))
		tmp_old_r_NetworkLsa_81 := r
		r = sub_byte_r_NetworkLsa
		if err := t.union63_.(*union_66_t).NetworkLsa.Read(r); err != nil {
			return fmt.Errorf("read NetworkLsa: %w", err)
		}
		if sub_byte_r_NetworkLsa.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read NetworkLsa: expect %d bytes but got %d bytes", sub_byte_len_NetworkLsa, sub_byte_len_NetworkLsa-sub_byte_r_NetworkLsa.(*io.LimitedReader).N)
		}
		r = tmp_old_r_NetworkLsa_81
	case (t.LsaHeader.LsType == LsafunctionCode_InterAreaPrefixLsa):
		t.union63_ = &union_67_t{}
		sub_byte_len_InterAreaPrefixLsa := int64((t.LsaHeader.Length - 20))
		sub_byte_r_InterAreaPrefixLsa := io.LimitReader(r, int64(sub_byte_len_InterAreaPrefixLsa))
		tmp_old_r_InterAreaPrefixLsa_82 := r
		r = sub_byte_r_InterAreaPrefixLsa
		if err := t.union63_.(*union_67_t).InterAreaPrefixLsa.Read(r); err != nil {
			return fmt.Errorf("read InterAreaPrefixLsa: %w", err)
		}
		if sub_byte_r_InterAreaPrefixLsa.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read InterAreaPrefixLsa: expect %d bytes but got %d bytes", sub_byte_len_InterAreaPrefixLsa, sub_byte_len_InterAreaPrefixLsa-sub_byte_r_InterAreaPrefixLsa.(*io.LimitedReader).N)
		}
		r = tmp_old_r_InterAreaPrefixLsa_82
	case (t.LsaHeader.LsType == LsafunctionCode_InterAreaRouterLsa):
		t.union63_ = &union_68_t{}
		sub_byte_len_InterAreaRouterLsa := int64((t.LsaHeader.Length - 20))
		sub_byte_r_InterAreaRouterLsa := io.LimitReader(r, int64(sub_byte_len_InterAreaRouterLsa))
		tmp_old_r_InterAreaRouterLsa_83 := r
		r = sub_byte_r_InterAreaRouterLsa
		if err := t.union63_.(*union_68_t).InterAreaRouterLsa.Read(r); err != nil {
			return fmt.Errorf("read InterAreaRouterLsa: %w", err)
		}
		if sub_byte_r_InterAreaRouterLsa.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read InterAreaRouterLsa: expect %d bytes but got %d bytes", sub_byte_len_InterAreaRouterLsa, sub_byte_len_InterAreaRouterLsa-sub_byte_r_InterAreaRouterLsa.(*io.LimitedReader).N)
		}
		r = tmp_old_r_InterAreaRouterLsa_83
	case (t.LsaHeader.LsType == LsafunctionCode_AsExternalLsa):
		t.union63_ = &union_69_t{}
		sub_byte_len_AsExternalLsa := int64((t.LsaHeader.Length - 20))
		sub_byte_r_AsExternalLsa := io.LimitReader(r, int64(sub_byte_len_AsExternalLsa))
		tmp_old_r_AsExternalLsa_84 := r
		r = sub_byte_r_AsExternalLsa
		if err := t.union63_.(*union_69_t).AsExternalLsa.Read(r); err != nil {
			return fmt.Errorf("read AsExternalLsa: %w", err)
		}
		if sub_byte_r_AsExternalLsa.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read AsExternalLsa: expect %d bytes but got %d bytes", sub_byte_len_AsExternalLsa, sub_byte_len_AsExternalLsa-sub_byte_r_AsExternalLsa.(*io.LimitedReader).N)
		}
		r = tmp_old_r_AsExternalLsa_84
	case (t.LsaHeader.LsType == LsafunctionCode_LinkLsa):
		t.union63_ = &union_70_t{}
		sub_byte_len_LinkLsa := int64((t.LsaHeader.Length - 20))
		sub_byte_r_LinkLsa := io.LimitReader(r, int64(sub_byte_len_LinkLsa))
		tmp_old_r_LinkLsa_85 := r
		r = sub_byte_r_LinkLsa
		if err := t.union63_.(*union_70_t).LinkLsa.Read(r); err != nil {
			return fmt.Errorf("read LinkLsa: %w", err)
		}
		if sub_byte_r_LinkLsa.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read LinkLsa: expect %d bytes but got %d bytes", sub_byte_len_LinkLsa, sub_byte_len_LinkLsa-sub_byte_r_LinkLsa.(*io.LimitedReader).N)
		}
		r = tmp_old_r_LinkLsa_85
	case (t.LsaHeader.LsType == LsafunctionCode_IntraAreaPrefixLsa):
		t.union63_ = &union_71_t{}
		sub_byte_len_IntraAreaPrefixLsa := int64((t.LsaHeader.Length - 20))
		sub_byte_r_IntraAreaPrefixLsa := io.LimitReader(r, int64(sub_byte_len_IntraAreaPrefixLsa))
		tmp_old_r_IntraAreaPrefixLsa_86 := r
		r = sub_byte_r_IntraAreaPrefixLsa
		if err := t.union63_.(*union_71_t).IntraAreaPrefixLsa.Read(r); err != nil {
			return fmt.Errorf("read IntraAreaPrefixLsa: %w", err)
		}
		if sub_byte_r_IntraAreaPrefixLsa.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read IntraAreaPrefixLsa: expect %d bytes but got %d bytes", sub_byte_len_IntraAreaPrefixLsa, sub_byte_len_IntraAreaPrefixLsa-sub_byte_r_IntraAreaPrefixLsa.(*io.LimitedReader).N)
		}
		r = tmp_old_r_IntraAreaPrefixLsa_86
	default:
		t.union63_ = &union_72_t{}
		len_Data := int((t.LsaHeader.Length - 20))
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union63_.(*union_72_t).Data = tmpData[:]
		} else {
			t.union63_.(*union_72_t).Data = nil
		}
	}
	return nil
}

func (t *Lsa) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Lsa) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Lsa: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *OspflinkStateUpdatePacket) SetLsaHeaders(v []Lsa) bool {
	if len(v) > int(^uint32(0)) {
		return false
	}
	t.NumLsa = uint32(len(v))
	t.LsaHeaders = v
	return true
}
func (t *OspflinkStateUpdatePacket) Visit(v VisitorTIJJO) {
	v.Visit(v, "NumLsa", &t.NumLsa)
	v.Visit(v, "LsaHeaders", &t.LsaHeaders)
}
func (t *OspflinkStateUpdatePacket) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *OspflinkStateUpdatePacket) Write(w io.Writer) (err error) {
	tmp87 := [4]byte{}
	binary.BigEndian.PutUint32(tmp87[:], uint32(t.NumLsa))
	if n, err := w.Write(tmp87[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.NumLsa: %w", err)
	}
	len_LsaHeaders := int(t.NumLsa)
	if len(t.LsaHeaders) != len_LsaHeaders {
		return fmt.Errorf("encode LsaHeaders: expect %d but got %d for length", len_LsaHeaders, len(t.LsaHeaders))
	}
	for _, v := range t.LsaHeaders {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode LsaHeaders: %w", err)
		}
	}
	return nil
}
func (t *OspflinkStateUpdatePacket) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *OspflinkStateUpdatePacket) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *OspflinkStateUpdatePacket) Read(r io.Reader) (err error) {
	tmpNumLsa := [4]byte{}
	n_NumLsa, err := io.ReadFull(r, tmpNumLsa[:])
	if err != nil {
		return fmt.Errorf("read NumLsa: expect 4 bytes but read %d bytes: %w", n_NumLsa, err)
	}
	t.NumLsa = uint32(binary.BigEndian.Uint32(tmpNumLsa[:]))
	len_LsaHeaders := int(t.NumLsa)
	for i_88 := 0; i_88 < len_LsaHeaders; i_88++ {
		var tmp89_ Lsa
		if err := tmp89_.Read(r); err != nil {
			return fmt.Errorf("read LsaHeaders: %w", err)
		}
		t.LsaHeaders = append(t.LsaHeaders, tmp89_)
	}
	return nil
}

func (t *OspflinkStateUpdatePacket) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *OspflinkStateUpdatePacket) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode OspflinkStateUpdatePacket: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *OspflinkStateAcknowledgementPacket) Visit(v VisitorTIJJO) {
	v.Visit(v, "LsaHeaders", &t.LsaHeaders)
}
func (t *OspflinkStateAcknowledgementPacket) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *OspflinkStateAcknowledgementPacket) Write(w io.Writer) (err error) {
	for _, v := range t.LsaHeaders {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode LsaHeaders: %w", err)
		}
	}
	return nil
}
func (t *OspflinkStateAcknowledgementPacket) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *OspflinkStateAcknowledgementPacket) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *OspflinkStateAcknowledgementPacket) Read(r io.Reader) (err error) {
	tmp_byte_scanner90_ := bufio.NewReaderSize(r, 1)
	old_r_LsaHeaders := r
	r = tmp_byte_scanner90_
	for {
		_, err := tmp_byte_scanner90_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read LsaHeaders: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner90_.UnreadByte(); err != nil {
			return fmt.Errorf("read LsaHeaders: unexpected unread error: %w", err)
		}
		var tmp91_ Lsaheader
		if err := tmp91_.Read(r); err != nil {
			return fmt.Errorf("read LsaHeaders: %w", err)
		}
		t.LsaHeaders = append(t.LsaHeaders, tmp91_)
	}
	r = old_r_LsaHeaders
	return nil
}

func (t *OspflinkStateAcknowledgementPacket) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *OspflinkStateAcknowledgementPacket) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode OspflinkStateAcknowledgementPacket: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *DatabaseDescriptionPacket) Reserved3() uint8 {
	return ((t.flags92 & 0xf8) >> 3)
}
func (t *DatabaseDescriptionPacket) SetReserved3(v uint8) bool {
	if v > 31 {
		return false
	}
	t.flags92 = (t.flags92 & ^uint8(0xf8)) | ((v & 0x1f) << 3)
	return true
}
func (t *DatabaseDescriptionPacket) Init() bool {
	return ((t.flags92 & 0x04) >> 2) == 1
}
func (t *DatabaseDescriptionPacket) SetInit(v bool) {
	if v {
		t.flags92 |= uint8(0x4)
	} else {
		t.flags92 &= ^uint8(0x4)
	}
}
func (t *DatabaseDescriptionPacket) More() bool {
	return ((t.flags92 & 0x02) >> 1) == 1
}
func (t *DatabaseDescriptionPacket) SetMore(v bool) {
	if v {
		t.flags92 |= uint8(0x2)
	} else {
		t.flags92 &= ^uint8(0x2)
	}
}
func (t *DatabaseDescriptionPacket) Master() bool {
	return ((t.flags92 & 0x01) >> 0) == 1
}
func (t *DatabaseDescriptionPacket) SetMaster(v bool) {
	if v {
		t.flags92 |= uint8(0x1)
	} else {
		t.flags92 &= ^uint8(0x1)
	}
}
func (t *DatabaseDescriptionPacket) Visit(v VisitorTIJJO) {
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "Options", &t.Options)
	v.Visit(v, "InterfaceMtu", &t.InterfaceMtu)
	v.Visit(v, "Reserved2", &t.Reserved2)
	v.Visit(v, "Reserved3", t.Reserved3())
	v.Visit(v, "Init", (func() uint8 {
		if t.Init() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "More", (func() uint8 {
		if t.More() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Master", (func() uint8 {
		if t.Master() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "DdSequenceNumber", &t.DdSequenceNumber)
	v.Visit(v, "LsaHeaders", &t.LsaHeaders)
}
func (t *DatabaseDescriptionPacket) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *DatabaseDescriptionPacket) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Reserved)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	if err := t.Options.Write(w); err != nil {
		return fmt.Errorf("encode Options: %w", err)
	}
	tmp93 := [2]byte{}
	binary.BigEndian.PutUint16(tmp93[:], uint16(t.InterfaceMtu))
	if n, err := w.Write(tmp93[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.InterfaceMtu: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Reserved2)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Reserved2: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags92)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags92: %w", err)
	}
	tmp94 := [4]byte{}
	binary.BigEndian.PutUint32(tmp94[:], uint32(t.DdSequenceNumber))
	if n, err := w.Write(tmp94[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.DdSequenceNumber: %w", err)
	}
	for _, v := range t.LsaHeaders {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode LsaHeaders: %w", err)
		}
	}
	return nil
}
func (t *DatabaseDescriptionPacket) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 12))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *DatabaseDescriptionPacket) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *DatabaseDescriptionPacket) Read(r io.Reader) (err error) {
	tmpReserved := [1]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 1 byte but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint8(tmpReserved[0])
	if err := t.Options.Read(r); err != nil {
		return fmt.Errorf("read Options: %w", err)
	}
	tmpInterfaceMtu := [2]byte{}
	n_InterfaceMtu, err := io.ReadFull(r, tmpInterfaceMtu[:])
	if err != nil {
		return fmt.Errorf("read InterfaceMtu: expect 2 bytes but read %d bytes: %w", n_InterfaceMtu, err)
	}
	t.InterfaceMtu = uint16(binary.BigEndian.Uint16(tmpInterfaceMtu[:]))
	tmpReserved2 := [1]byte{}
	n_Reserved2, err := io.ReadFull(r, tmpReserved2[:])
	if err != nil {
		return fmt.Errorf("read Reserved2: expect 1 byte but read %d bytes: %w", n_Reserved2, err)
	}
	t.Reserved2 = uint8(tmpReserved2[0])
	tmpflags92 := [1]byte{}
	n_flags92, err := io.ReadFull(r, tmpflags92[:])
	if err != nil {
		return fmt.Errorf("read flags92: expect 1 byte but read %d bytes: %w", n_flags92, err)
	}
	t.flags92 = uint8(tmpflags92[0])
	tmpDdSequenceNumber := [4]byte{}
	n_DdSequenceNumber, err := io.ReadFull(r, tmpDdSequenceNumber[:])
	if err != nil {
		return fmt.Errorf("read DdSequenceNumber: expect 4 bytes but read %d bytes: %w", n_DdSequenceNumber, err)
	}
	t.DdSequenceNumber = uint32(binary.BigEndian.Uint32(tmpDdSequenceNumber[:]))
	tmp_byte_scanner95_ := bufio.NewReaderSize(r, 1)
	old_r_LsaHeaders := r
	r = tmp_byte_scanner95_
	for {
		_, err := tmp_byte_scanner95_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read LsaHeaders: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner95_.UnreadByte(); err != nil {
			return fmt.Errorf("read LsaHeaders: unexpected unread error: %w", err)
		}
		var tmp96_ Lsaheader
		if err := tmp96_.Read(r); err != nil {
			return fmt.Errorf("read LsaHeaders: %w", err)
		}
		t.LsaHeaders = append(t.LsaHeaders, tmp96_)
	}
	r = old_r_LsaHeaders
	return nil
}

func (t *DatabaseDescriptionPacket) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *DatabaseDescriptionPacket) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode DatabaseDescriptionPacket: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_99_t) isunion97_()  {}
func (t *union_100_t) isunion97_() {}
func (t *union_101_t) isunion97_() {}
func (t *union_102_t) isunion97_() {}
func (t *union_103_t) isunion97_() {}
func (t *union_104_t) isunion97_() {}
func (t *Ospfpacket) Data() *[]uint8 {
	if t.Header.Type == OspfpacketType_Hello {
		return nil
	} else if t.Header.Type == OspfpacketType_DatabaseDescription {
		return nil
	} else if t.Header.Type == OspfpacketType_LinkStateRequest {
		return nil
	} else if t.Header.Type == OspfpacketType_LinkStateUpdate {
		return nil
	} else if t.Header.Type == OspfpacketType_LinkStateAcknowledgement {
		return nil
	} else if true {
		if _, ok := t.union97_.(*union_104_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union97_.(*union_104_t).Data)
		return &tmp
	}
	return nil
}
func (t *Ospfpacket) SetData(v []uint8) bool {
	if t.Header.Type == OspfpacketType_Hello {
		return false
	} else if t.Header.Type == OspfpacketType_DatabaseDescription {
		return false
	} else if t.Header.Type == OspfpacketType_LinkStateRequest {
		return false
	} else if t.Header.Type == OspfpacketType_LinkStateUpdate {
		return false
	} else if t.Header.Type == OspfpacketType_LinkStateAcknowledgement {
		return false
	} else if true {
		if _, ok := t.union97_.(*union_104_t); !ok {
			t.union97_ = &union_104_t{}
		}
		t.union97_.(*union_104_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *Ospfpacket) DatabaseDescriptionPacket() *DatabaseDescriptionPacket {
	if t.Header.Type == OspfpacketType_Hello {
		return nil
	} else if t.Header.Type == OspfpacketType_DatabaseDescription {
		if _, ok := t.union97_.(*union_100_t); !ok {
			return nil // not set
		}
		tmp := DatabaseDescriptionPacket(t.union97_.(*union_100_t).DatabaseDescriptionPacket)
		return &tmp
	}
	return nil
}
func (t *Ospfpacket) SetDatabaseDescriptionPacket(v DatabaseDescriptionPacket) bool {
	if t.Header.Type == OspfpacketType_Hello {
		return false
	} else if t.Header.Type == OspfpacketType_DatabaseDescription {
		if _, ok := t.union97_.(*union_100_t); !ok {
			t.union97_ = &union_100_t{}
		}
		t.union97_.(*union_100_t).DatabaseDescriptionPacket = DatabaseDescriptionPacket(v)
		return true
	}
	return false
}
func (t *Ospfpacket) HelloPacket() *HelloPacket {
	if t.Header.Type == OspfpacketType_Hello {
		if _, ok := t.union97_.(*union_99_t); !ok {
			return nil // not set
		}
		tmp := HelloPacket(t.union97_.(*union_99_t).HelloPacket)
		return &tmp
	}
	return nil
}
func (t *Ospfpacket) SetHelloPacket(v HelloPacket) bool {
	if t.Header.Type == OspfpacketType_Hello {
		if _, ok := t.union97_.(*union_99_t); !ok {
			t.union97_ = &union_99_t{}
		}
		t.union97_.(*union_99_t).HelloPacket = HelloPacket(v)
		return true
	}
	return false
}
func (t *Ospfpacket) OspfLinkStateAcknowledgementPacket() *OspflinkStateAcknowledgementPacket {
	if t.Header.Type == OspfpacketType_Hello {
		return nil
	} else if t.Header.Type == OspfpacketType_DatabaseDescription {
		return nil
	} else if t.Header.Type == OspfpacketType_LinkStateRequest {
		return nil
	} else if t.Header.Type == OspfpacketType_LinkStateUpdate {
		return nil
	} else if t.Header.Type == OspfpacketType_LinkStateAcknowledgement {
		if _, ok := t.union97_.(*union_103_t); !ok {
			return nil // not set
		}
		tmp := OspflinkStateAcknowledgementPacket(t.union97_.(*union_103_t).OspfLinkStateAcknowledgementPacket)
		return &tmp
	}
	return nil
}
func (t *Ospfpacket) SetOspfLinkStateAcknowledgementPacket(v OspflinkStateAcknowledgementPacket) bool {
	if t.Header.Type == OspfpacketType_Hello {
		return false
	} else if t.Header.Type == OspfpacketType_DatabaseDescription {
		return false
	} else if t.Header.Type == OspfpacketType_LinkStateRequest {
		return false
	} else if t.Header.Type == OspfpacketType_LinkStateUpdate {
		return false
	} else if t.Header.Type == OspfpacketType_LinkStateAcknowledgement {
		if _, ok := t.union97_.(*union_103_t); !ok {
			t.union97_ = &union_103_t{}
		}
		t.union97_.(*union_103_t).OspfLinkStateAcknowledgementPacket = OspflinkStateAcknowledgementPacket(v)
		return true
	}
	return false
}
func (t *Ospfpacket) OspfLinkStateRequestPacket() *OspflinkStateRequestPacket {
	if t.Header.Type == OspfpacketType_Hello {
		return nil
	} else if t.Header.Type == OspfpacketType_DatabaseDescription {
		return nil
	} else if t.Header.Type == OspfpacketType_LinkStateRequest {
		if _, ok := t.union97_.(*union_101_t); !ok {
			return nil // not set
		}
		tmp := OspflinkStateRequestPacket(t.union97_.(*union_101_t).OspfLinkStateRequestPacket)
		return &tmp
	}
	return nil
}
func (t *Ospfpacket) SetOspfLinkStateRequestPacket(v OspflinkStateRequestPacket) bool {
	if t.Header.Type == OspfpacketType_Hello {
		return false
	} else if t.Header.Type == OspfpacketType_DatabaseDescription {
		return false
	} else if t.Header.Type == OspfpacketType_LinkStateRequest {
		if _, ok := t.union97_.(*union_101_t); !ok {
			t.union97_ = &union_101_t{}
		}
		t.union97_.(*union_101_t).OspfLinkStateRequestPacket = OspflinkStateRequestPacket(v)
		return true
	}
	return false
}
func (t *Ospfpacket) OspfLinkStateUpdatePacket() *OspflinkStateUpdatePacket {
	if t.Header.Type == OspfpacketType_Hello {
		return nil
	} else if t.Header.Type == OspfpacketType_DatabaseDescription {
		return nil
	} else if t.Header.Type == OspfpacketType_LinkStateRequest {
		return nil
	} else if t.Header.Type == OspfpacketType_LinkStateUpdate {
		if _, ok := t.union97_.(*union_102_t); !ok {
			return nil // not set
		}
		tmp := OspflinkStateUpdatePacket(t.union97_.(*union_102_t).OspfLinkStateUpdatePacket)
		return &tmp
	}
	return nil
}
func (t *Ospfpacket) SetOspfLinkStateUpdatePacket(v OspflinkStateUpdatePacket) bool {
	if t.Header.Type == OspfpacketType_Hello {
		return false
	} else if t.Header.Type == OspfpacketType_DatabaseDescription {
		return false
	} else if t.Header.Type == OspfpacketType_LinkStateRequest {
		return false
	} else if t.Header.Type == OspfpacketType_LinkStateUpdate {
		if _, ok := t.union97_.(*union_102_t); !ok {
			t.union97_ = &union_102_t{}
		}
		t.union97_.(*union_102_t).OspfLinkStateUpdatePacket = OspflinkStateUpdatePacket(v)
		return true
	}
	return false
}
func (t *Ospfpacket) Visit(v VisitorTIJJO) {
	v.Visit(v, "Header", &t.Header)
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "DatabaseDescriptionPacket", (t.DatabaseDescriptionPacket()))
	v.Visit(v, "HelloPacket", (t.HelloPacket()))
	v.Visit(v, "OspfLinkStateAcknowledgementPacket", (t.OspfLinkStateAcknowledgementPacket()))
	v.Visit(v, "OspfLinkStateRequestPacket", (t.OspfLinkStateRequestPacket()))
	v.Visit(v, "OspfLinkStateUpdatePacket", (t.OspfLinkStateUpdatePacket()))
}
func (t *Ospfpacket) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorTIJJOToMap(t))
}
func (t *Ospfpacket) Write(w io.Writer) (err error) {
	if err := t.Header.Write(w); err != nil {
		return fmt.Errorf("encode Header: %w", err)
	}
	switch {
	case (t.Header.Type == OspfpacketType_Hello):
		if _, ok := t.union97_.(*union_99_t); !ok {
			return fmt.Errorf("encode t.union97_: union is not set to union_99_t")
		}
		new_buf_105 := bytes.NewBuffer(nil)
		old_buf_105_w := w
		w = new_buf_105
		if err := t.union97_.(*union_99_t).HelloPacket.Write(w); err != nil {
			return fmt.Errorf("encode HelloPacket: %w", err)
		}
		if new_buf_105.Len() != int(24) {
			return fmt.Errorf("encode HelloPacket: expect %d bytes but got %d bytes", new_buf_105.Len(), int(24))
		}
		_, err = new_buf_105.WriteTo(old_buf_105_w)
		if err != nil {
			return err
		}
		w = old_buf_105_w
	case (t.Header.Type == OspfpacketType_DatabaseDescription):
		if _, ok := t.union97_.(*union_100_t); !ok {
			return fmt.Errorf("encode t.union97_: union is not set to union_100_t")
		}
		new_buf_106 := bytes.NewBuffer(nil)
		old_buf_106_w := w
		w = new_buf_106
		if err := t.union97_.(*union_100_t).DatabaseDescriptionPacket.Write(w); err != nil {
			return fmt.Errorf("encode DatabaseDescriptionPacket: %w", err)
		}
		if new_buf_106.Len() != int(24) {
			return fmt.Errorf("encode DatabaseDescriptionPacket: expect %d bytes but got %d bytes", new_buf_106.Len(), int(24))
		}
		_, err = new_buf_106.WriteTo(old_buf_106_w)
		if err != nil {
			return err
		}
		w = old_buf_106_w
	case (t.Header.Type == OspfpacketType_LinkStateRequest):
		if _, ok := t.union97_.(*union_101_t); !ok {
			return fmt.Errorf("encode t.union97_: union is not set to union_101_t")
		}
		new_buf_107 := bytes.NewBuffer(nil)
		old_buf_107_w := w
		w = new_buf_107
		if err := t.union97_.(*union_101_t).OspfLinkStateRequestPacket.Write(w); err != nil {
			return fmt.Errorf("encode OspfLinkStateRequestPacket: %w", err)
		}
		if new_buf_107.Len() != int(24) {
			return fmt.Errorf("encode OspfLinkStateRequestPacket: expect %d bytes but got %d bytes", new_buf_107.Len(), int(24))
		}
		_, err = new_buf_107.WriteTo(old_buf_107_w)
		if err != nil {
			return err
		}
		w = old_buf_107_w
	case (t.Header.Type == OspfpacketType_LinkStateUpdate):
		if _, ok := t.union97_.(*union_102_t); !ok {
			return fmt.Errorf("encode t.union97_: union is not set to union_102_t")
		}
		new_buf_108 := bytes.NewBuffer(nil)
		old_buf_108_w := w
		w = new_buf_108
		if err := t.union97_.(*union_102_t).OspfLinkStateUpdatePacket.Write(w); err != nil {
			return fmt.Errorf("encode OspfLinkStateUpdatePacket: %w", err)
		}
		if new_buf_108.Len() != int(24) {
			return fmt.Errorf("encode OspfLinkStateUpdatePacket: expect %d bytes but got %d bytes", new_buf_108.Len(), int(24))
		}
		_, err = new_buf_108.WriteTo(old_buf_108_w)
		if err != nil {
			return err
		}
		w = old_buf_108_w
	case (t.Header.Type == OspfpacketType_LinkStateAcknowledgement):
		if _, ok := t.union97_.(*union_103_t); !ok {
			return fmt.Errorf("encode t.union97_: union is not set to union_103_t")
		}
		new_buf_109 := bytes.NewBuffer(nil)
		old_buf_109_w := w
		w = new_buf_109
		if err := t.union97_.(*union_103_t).OspfLinkStateAcknowledgementPacket.Write(w); err != nil {
			return fmt.Errorf("encode OspfLinkStateAcknowledgementPacket: %w", err)
		}
		if new_buf_109.Len() != int(24) {
			return fmt.Errorf("encode OspfLinkStateAcknowledgementPacket: expect %d bytes but got %d bytes", new_buf_109.Len(), int(24))
		}
		_, err = new_buf_109.WriteTo(old_buf_109_w)
		if err != nil {
			return err
		}
		w = old_buf_109_w
	default:
		if _, ok := t.union97_.(*union_104_t); !ok {
			return fmt.Errorf("encode t.union97_: union is not set to union_104_t")
		}
		len_Data := int((t.Header.PacketLength - 24))
		if len(t.union97_.(*union_104_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union97_.(*union_104_t).Data))
		}
		if n, err := w.Write(t.union97_.(*union_104_t).Data); err != nil || n != len(t.union97_.(*union_104_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *Ospfpacket) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 16))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Ospfpacket) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Ospfpacket) Read(r io.Reader) (err error) {
	if err := t.Header.Read(r); err != nil {
		return fmt.Errorf("read Header: %w", err)
	}
	switch {
	case (t.Header.Type == OspfpacketType_Hello):
		t.union97_ = &union_99_t{}
		sub_byte_len_HelloPacket := int64(24)
		sub_byte_r_HelloPacket := io.LimitReader(r, int64(sub_byte_len_HelloPacket))
		tmp_old_r_HelloPacket_110 := r
		r = sub_byte_r_HelloPacket
		if err := t.union97_.(*union_99_t).HelloPacket.Read(r); err != nil {
			return fmt.Errorf("read HelloPacket: %w", err)
		}
		if sub_byte_r_HelloPacket.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read HelloPacket: expect %d bytes but got %d bytes", sub_byte_len_HelloPacket, sub_byte_len_HelloPacket-sub_byte_r_HelloPacket.(*io.LimitedReader).N)
		}
		r = tmp_old_r_HelloPacket_110
	case (t.Header.Type == OspfpacketType_DatabaseDescription):
		t.union97_ = &union_100_t{}
		sub_byte_len_DatabaseDescriptionPacket := int64(24)
		sub_byte_r_DatabaseDescriptionPacket := io.LimitReader(r, int64(sub_byte_len_DatabaseDescriptionPacket))
		tmp_old_r_DatabaseDescriptionPacket_111 := r
		r = sub_byte_r_DatabaseDescriptionPacket
		if err := t.union97_.(*union_100_t).DatabaseDescriptionPacket.Read(r); err != nil {
			return fmt.Errorf("read DatabaseDescriptionPacket: %w", err)
		}
		if sub_byte_r_DatabaseDescriptionPacket.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read DatabaseDescriptionPacket: expect %d bytes but got %d bytes", sub_byte_len_DatabaseDescriptionPacket, sub_byte_len_DatabaseDescriptionPacket-sub_byte_r_DatabaseDescriptionPacket.(*io.LimitedReader).N)
		}
		r = tmp_old_r_DatabaseDescriptionPacket_111
	case (t.Header.Type == OspfpacketType_LinkStateRequest):
		t.union97_ = &union_101_t{}
		sub_byte_len_OspfLinkStateRequestPacket := int64(24)
		sub_byte_r_OspfLinkStateRequestPacket := io.LimitReader(r, int64(sub_byte_len_OspfLinkStateRequestPacket))
		tmp_old_r_OspfLinkStateRequestPacket_112 := r
		r = sub_byte_r_OspfLinkStateRequestPacket
		if err := t.union97_.(*union_101_t).OspfLinkStateRequestPacket.Read(r); err != nil {
			return fmt.Errorf("read OspfLinkStateRequestPacket: %w", err)
		}
		if sub_byte_r_OspfLinkStateRequestPacket.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read OspfLinkStateRequestPacket: expect %d bytes but got %d bytes", sub_byte_len_OspfLinkStateRequestPacket, sub_byte_len_OspfLinkStateRequestPacket-sub_byte_r_OspfLinkStateRequestPacket.(*io.LimitedReader).N)
		}
		r = tmp_old_r_OspfLinkStateRequestPacket_112
	case (t.Header.Type == OspfpacketType_LinkStateUpdate):
		t.union97_ = &union_102_t{}
		sub_byte_len_OspfLinkStateUpdatePacket := int64(24)
		sub_byte_r_OspfLinkStateUpdatePacket := io.LimitReader(r, int64(sub_byte_len_OspfLinkStateUpdatePacket))
		tmp_old_r_OspfLinkStateUpdatePacket_113 := r
		r = sub_byte_r_OspfLinkStateUpdatePacket
		if err := t.union97_.(*union_102_t).OspfLinkStateUpdatePacket.Read(r); err != nil {
			return fmt.Errorf("read OspfLinkStateUpdatePacket: %w", err)
		}
		if sub_byte_r_OspfLinkStateUpdatePacket.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read OspfLinkStateUpdatePacket: expect %d bytes but got %d bytes", sub_byte_len_OspfLinkStateUpdatePacket, sub_byte_len_OspfLinkStateUpdatePacket-sub_byte_r_OspfLinkStateUpdatePacket.(*io.LimitedReader).N)
		}
		r = tmp_old_r_OspfLinkStateUpdatePacket_113
	case (t.Header.Type == OspfpacketType_LinkStateAcknowledgement):
		t.union97_ = &union_103_t{}
		sub_byte_len_OspfLinkStateAcknowledgementPacket := int64(24)
		sub_byte_r_OspfLinkStateAcknowledgementPacket := io.LimitReader(r, int64(sub_byte_len_OspfLinkStateAcknowledgementPacket))
		tmp_old_r_OspfLinkStateAcknowledgementPacket_114 := r
		r = sub_byte_r_OspfLinkStateAcknowledgementPacket
		if err := t.union97_.(*union_103_t).OspfLinkStateAcknowledgementPacket.Read(r); err != nil {
			return fmt.Errorf("read OspfLinkStateAcknowledgementPacket: %w", err)
		}
		if sub_byte_r_OspfLinkStateAcknowledgementPacket.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read OspfLinkStateAcknowledgementPacket: expect %d bytes but got %d bytes", sub_byte_len_OspfLinkStateAcknowledgementPacket, sub_byte_len_OspfLinkStateAcknowledgementPacket-sub_byte_r_OspfLinkStateAcknowledgementPacket.(*io.LimitedReader).N)
		}
		r = tmp_old_r_OspfLinkStateAcknowledgementPacket_114
	default:
		t.union97_ = &union_104_t{}
		len_Data := int((t.Header.PacketLength - 24))
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union97_.(*union_104_t).Data = tmpData[:]
		} else {
			t.union97_.(*union_104_t).Data = nil
		}
	}
	return nil
}

func (t *Ospfpacket) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Ospfpacket) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Ospfpacket: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
