// Code generated by json2go. DO NOT EDIT.
package main

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"reflect"
)

type BgpflowSpecTypeAndOp uint8

const (
	BgpflowSpecTypeAndOp_Unknown     BgpflowSpecTypeAndOp = 0
	BgpflowSpecTypeAndOp_DstPrefix   BgpflowSpecTypeAndOp = 1
	BgpflowSpecTypeAndOp_SrcPrefix   BgpflowSpecTypeAndOp = 2
	BgpflowSpecTypeAndOp_IpProto     BgpflowSpecTypeAndOp = 3
	BgpflowSpecTypeAndOp_Port        BgpflowSpecTypeAndOp = 4
	BgpflowSpecTypeAndOp_DstPort     BgpflowSpecTypeAndOp = 5
	BgpflowSpecTypeAndOp_SrcPort     BgpflowSpecTypeAndOp = 6
	BgpflowSpecTypeAndOp_IcmpType    BgpflowSpecTypeAndOp = 7
	BgpflowSpecTypeAndOp_IcmpCode    BgpflowSpecTypeAndOp = 8
	BgpflowSpecTypeAndOp_TcpFlag     BgpflowSpecTypeAndOp = 9
	BgpflowSpecTypeAndOp_PktLen      BgpflowSpecTypeAndOp = 10
	BgpflowSpecTypeAndOp_Dscp        BgpflowSpecTypeAndOp = 11
	BgpflowSpecTypeAndOp_IpFragment  BgpflowSpecTypeAndOp = 12
	BgpflowSpecTypeAndOp_FlowLabel   BgpflowSpecTypeAndOp = 13
	BgpflowSpecTypeAndOp_And         BgpflowSpecTypeAndOp = 0xf0
	BgpflowSpecTypeAndOp_Or          BgpflowSpecTypeAndOp = 0xf1
	BgpflowSpecTypeAndOp_Eq          BgpflowSpecTypeAndOp = 0xf2
	BgpflowSpecTypeAndOp_Neq         BgpflowSpecTypeAndOp = 0xf3
	BgpflowSpecTypeAndOp_Gt          BgpflowSpecTypeAndOp = 0xf4
	BgpflowSpecTypeAndOp_Gte         BgpflowSpecTypeAndOp = 0xf5
	BgpflowSpecTypeAndOp_Ls          BgpflowSpecTypeAndOp = 0xf6
	BgpflowSpecTypeAndOp_Lse         BgpflowSpecTypeAndOp = 0xf7
	BgpflowSpecTypeAndOp_True        BgpflowSpecTypeAndOp = 0xf8
	BgpflowSpecTypeAndOp_False       BgpflowSpecTypeAndOp = 0xf9
	BgpflowSpecTypeAndOp_PrefixValue BgpflowSpecTypeAndOp = 0xfa
	BgpflowSpecTypeAndOp_Value       BgpflowSpecTypeAndOp = 0xfb
)

func (t BgpflowSpecTypeAndOp) String() string {
	switch t {
	case BgpflowSpecTypeAndOp_Unknown:
		return "Unknown"
	case BgpflowSpecTypeAndOp_DstPrefix:
		return "DstPrefix"
	case BgpflowSpecTypeAndOp_SrcPrefix:
		return "SrcPrefix"
	case BgpflowSpecTypeAndOp_IpProto:
		return "IpProto"
	case BgpflowSpecTypeAndOp_Port:
		return "Port"
	case BgpflowSpecTypeAndOp_DstPort:
		return "DstPort"
	case BgpflowSpecTypeAndOp_SrcPort:
		return "SrcPort"
	case BgpflowSpecTypeAndOp_IcmpType:
		return "IcmpType"
	case BgpflowSpecTypeAndOp_IcmpCode:
		return "IcmpCode"
	case BgpflowSpecTypeAndOp_TcpFlag:
		return "TcpFlag"
	case BgpflowSpecTypeAndOp_PktLen:
		return "PktLen"
	case BgpflowSpecTypeAndOp_Dscp:
		return "Dscp"
	case BgpflowSpecTypeAndOp_IpFragment:
		return "IpFragment"
	case BgpflowSpecTypeAndOp_FlowLabel:
		return "FlowLabel"
	case BgpflowSpecTypeAndOp_And:
		return "And"
	case BgpflowSpecTypeAndOp_Or:
		return "Or"
	case BgpflowSpecTypeAndOp_Eq:
		return "Eq"
	case BgpflowSpecTypeAndOp_Neq:
		return "Neq"
	case BgpflowSpecTypeAndOp_Gt:
		return "Gt"
	case BgpflowSpecTypeAndOp_Gte:
		return "Gte"
	case BgpflowSpecTypeAndOp_Ls:
		return "Ls"
	case BgpflowSpecTypeAndOp_Lse:
		return "Lse"
	case BgpflowSpecTypeAndOp_True:
		return "True"
	case BgpflowSpecTypeAndOp_False:
		return "False"
	case BgpflowSpecTypeAndOp_PrefixValue:
		return "PrefixValue"
	case BgpflowSpecTypeAndOp_Value:
		return "Value"
	}
	return fmt.Sprintf("BgpflowSpecTypeAndOp(%d)", t)
}

type PrefixValue struct {
	PrefixLen uint8
	Prefix    []uint8
}
type VisitorAXKRW interface {
	Visit(v VisitorAXKRW, name string, field any)
}
type VisitorAXKRWFunc func(v VisitorAXKRW, name string, field any)

func (f VisitorAXKRWFunc) Visit(v VisitorAXKRW, name string, field any) {
	f(v, name, field)
}

type VisitorAXKRWVisitable interface {
	Visit(v VisitorAXKRW)
}

func VisitorAXKRWToMap(v any) interface{} {
	if v == nil {
		return nil
	}
	if inter, ok := v.(VisitorAXKRWVisitable); ok {
		if p := reflect.ValueOf(inter); p.Kind() == reflect.Pointer && p.IsNil() {
			return nil
		}
		m := map[string]interface{}{}
		inter.Visit(VisitorAXKRWFunc(func(v VisitorAXKRW, name string, field any) {
			m[name] = VisitorAXKRWToMap(field)
		}))
		return m
	}
	if tf := reflect.TypeOf(v); (tf.Kind() == reflect.Slice || tf.Kind() == reflect.Array) && !(func() bool { k := tf.Elem().Kind().String(); return k[:3] == "int" || k[:3] == "uin" || k[:3] == "flo" })() {
		m := []interface{}{}
		vf := reflect.ValueOf(v)
		for i := 0; i < vf.Len(); i++ {
			index := vf.Index(i)
			if index.Kind() == reflect.Struct && index.CanAddr() {
				index = index.Addr()
			}
			m = append(m, VisitorAXKRWToMap(index.Interface()))
		}
		return m
	}
	if tf := reflect.TypeOf(v); tf.Kind() == reflect.Pointer {
		val := reflect.ValueOf(v)
		if val.IsNil() {
			return nil
		}
		return VisitorAXKRWToMap(val.Elem().Interface())
	}
	return v
}

type Value struct {
	Value uint16
}
type union3_Code interface {
	isunion2_()
}
type union_4_t struct {
	PrefixValue PrefixValue
}
type union_5_t struct {
	Value Value
}
type Code struct {
	Code    BgpflowSpecTypeAndOp
	union2_ union3_Code
}

func (t *PrefixValue) SetPrefix(v []uint8) bool {
	t.Prefix = v
	return true
}
func (t *PrefixValue) Visit(v VisitorAXKRW) {
	v.Visit(v, "PrefixLen", &t.PrefixLen)
	v.Visit(v, "Prefix", &t.Prefix)
}
func (t *PrefixValue) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorAXKRWToMap(t))
}
func (t *PrefixValue) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.PrefixLen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.PrefixLen: %w", err)
	}
	PrefixLenInBytes := ((t.PrefixLen + 7) / 8)
	len_Prefix := int(PrefixLenInBytes)
	if len(t.Prefix) != len_Prefix {
		return fmt.Errorf("encode Prefix: expect %d bytes but got %d bytes", len_Prefix, len(t.Prefix))
	}
	if n, err := w.Write(t.Prefix); err != nil || n != len(t.Prefix) {
		return fmt.Errorf("encode Prefix: %w", err)
	}
	return nil
}
func (t *PrefixValue) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *PrefixValue) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *PrefixValue) Read(r io.Reader) (err error) {
	tmpPrefixLen := [1]byte{}
	n_PrefixLen, err := io.ReadFull(r, tmpPrefixLen[:])
	if err != nil {
		return fmt.Errorf("read PrefixLen: expect 1 byte but read %d bytes: %w", n_PrefixLen, err)
	}
	t.PrefixLen = uint8(tmpPrefixLen[0])
	PrefixLenInBytes := ((t.PrefixLen + 7) / 8)
	len_Prefix := int(PrefixLenInBytes)
	if len_Prefix != 0 {
		tmpPrefix := make([]byte, len_Prefix)
		n_Prefix, err := io.ReadFull(r, tmpPrefix[:])
		if err != nil {
			return fmt.Errorf("read Prefix: expect %d bytes but read %d bytes: %w", len_Prefix, n_Prefix, err)
		}
		t.Prefix = tmpPrefix[:]
	} else {
		t.Prefix = nil
	}
	return nil
}

func (t *PrefixValue) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *PrefixValue) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode PrefixValue: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Value) Visit(v VisitorAXKRW) {
	v.Visit(v, "Value", &t.Value)
}
func (t *Value) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorAXKRWToMap(t))
}
func (t *Value) Write(w io.Writer) (err error) {
	tmp1 := [2]byte{}
	binary.BigEndian.PutUint16(tmp1[:], uint16(t.Value))
	if n, err := w.Write(tmp1[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Value: %w", err)
	}
	return nil
}
func (t *Value) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Value) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Value) Read(r io.Reader) (err error) {
	tmpValue := [2]byte{}
	n_Value, err := io.ReadFull(r, tmpValue[:])
	if err != nil {
		return fmt.Errorf("read Value: expect 2 bytes but read %d bytes: %w", n_Value, err)
	}
	t.Value = uint16(binary.BigEndian.Uint16(tmpValue[:]))
	return nil
}

func (t *Value) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Value) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Value: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_4_t) isunion2_() {}
func (t *union_5_t) isunion2_() {}
func (t *Code) PrefixValue() *PrefixValue {
	if t.Code == BgpflowSpecTypeAndOp_PrefixValue {
		if _, ok := t.union2_.(*union_4_t); !ok {
			return nil // not set
		}
		tmp := PrefixValue(t.union2_.(*union_4_t).PrefixValue)
		return &tmp
	}
	return nil
}
func (t *Code) SetPrefixValue(v PrefixValue) bool {
	if t.Code == BgpflowSpecTypeAndOp_PrefixValue {
		if _, ok := t.union2_.(*union_4_t); !ok {
			t.union2_ = &union_4_t{}
		}
		t.union2_.(*union_4_t).PrefixValue = PrefixValue(v)
		return true
	}
	return false
}
func (t *Code) Value() *Value {
	if t.Code == BgpflowSpecTypeAndOp_PrefixValue {
		return nil
	} else if t.Code == BgpflowSpecTypeAndOp_Value {
		if _, ok := t.union2_.(*union_5_t); !ok {
			return nil // not set
		}
		tmp := Value(t.union2_.(*union_5_t).Value)
		return &tmp
	}
	return nil
}
func (t *Code) SetValue(v Value) bool {
	if t.Code == BgpflowSpecTypeAndOp_PrefixValue {
		return false
	} else if t.Code == BgpflowSpecTypeAndOp_Value {
		if _, ok := t.union2_.(*union_5_t); !ok {
			t.union2_ = &union_5_t{}
		}
		t.union2_.(*union_5_t).Value = Value(v)
		return true
	}
	return false
}
func (t *Code) Visit(v VisitorAXKRW) {
	v.Visit(v, "Code", &t.Code)
	v.Visit(v, "PrefixValue", (t.PrefixValue()))
	v.Visit(v, "Value", (t.Value()))
}
func (t *Code) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorAXKRWToMap(t))
}
func (t *Code) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Code)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Code: %w", err)
	}
	switch {
	case (t.Code == BgpflowSpecTypeAndOp_PrefixValue):
		if _, ok := t.union2_.(*union_4_t); !ok {
			return fmt.Errorf("encode t.union2_: union is not set to union_4_t")
		}
		if err := t.union2_.(*union_4_t).PrefixValue.Write(w); err != nil {
			return fmt.Errorf("encode PrefixValue: %w", err)
		}
	case (t.Code == BgpflowSpecTypeAndOp_Value):
		if _, ok := t.union2_.(*union_5_t); !ok {
			return fmt.Errorf("encode t.union2_: union is not set to union_5_t")
		}
		if err := t.union2_.(*union_5_t).Value.Write(w); err != nil {
			return fmt.Errorf("encode Value: %w", err)
		}
	}
	return nil
}
func (t *Code) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Code) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Code) Read(r io.Reader) (err error) {
	tmpCode := [1]byte{}
	n_Code, err := io.ReadFull(r, tmpCode[:])
	if err != nil {
		return fmt.Errorf("read Code: expect 1 byte but read %d bytes: %w", n_Code, err)
	}
	t.Code = BgpflowSpecTypeAndOp(tmpCode[0])
	switch {
	case (t.Code == BgpflowSpecTypeAndOp_PrefixValue):
		t.union2_ = &union_4_t{}
		if err := t.union2_.(*union_4_t).PrefixValue.Read(r); err != nil {
			return fmt.Errorf("read PrefixValue: %w", err)
		}
	case (t.Code == BgpflowSpecTypeAndOp_Value):
		t.union2_ = &union_5_t{}
		if err := t.union2_.(*union_5_t).Value.Read(r); err != nil {
			return fmt.Errorf("read Value: %w", err)
		}
	}
	return nil
}

func (t *Code) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Code) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Code: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
