// Code generated by json2go. DO NOT EDIT.
package routing

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"reflect"
)

const BgpPort = 179

type ProtocolNumber uint8

const (
	ProtocolNumber_Hopopt        ProtocolNumber = 0
	ProtocolNumber_Icmp          ProtocolNumber = 1
	ProtocolNumber_Igmp          ProtocolNumber = 2
	ProtocolNumber_Ggp           ProtocolNumber = 3
	ProtocolNumber_Ipv4          ProtocolNumber = 4
	ProtocolNumber_St            ProtocolNumber = 5
	ProtocolNumber_Tcp           ProtocolNumber = 6
	ProtocolNumber_Cbt           ProtocolNumber = 7
	ProtocolNumber_Egp           ProtocolNumber = 8
	ProtocolNumber_Igp           ProtocolNumber = 9
	ProtocolNumber_BbnRccMon     ProtocolNumber = 10
	ProtocolNumber_NvpIi         ProtocolNumber = 11
	ProtocolNumber_Pup           ProtocolNumber = 12
	ProtocolNumber_Argus         ProtocolNumber = 13
	ProtocolNumber_Emcon         ProtocolNumber = 14
	ProtocolNumber_Xnet          ProtocolNumber = 15
	ProtocolNumber_Chaos         ProtocolNumber = 16
	ProtocolNumber_Udp           ProtocolNumber = 17
	ProtocolNumber_Mux           ProtocolNumber = 18
	ProtocolNumber_DcnMeas       ProtocolNumber = 19
	ProtocolNumber_Hmp           ProtocolNumber = 20
	ProtocolNumber_Prm           ProtocolNumber = 21
	ProtocolNumber_XnsIdp        ProtocolNumber = 22
	ProtocolNumber_Trunk1        ProtocolNumber = 23
	ProtocolNumber_Trunk2        ProtocolNumber = 24
	ProtocolNumber_RoutingHeader ProtocolNumber = 43
	ProtocolNumber_Icmpv6        ProtocolNumber = 58
	ProtocolNumber_Ospf          ProtocolNumber = 89
	ProtocolNumber_Ethernet      ProtocolNumber = 143
)

func (t ProtocolNumber) String() string {
	switch t {
	case ProtocolNumber_Hopopt:
		return "Hopopt"
	case ProtocolNumber_Icmp:
		return "Icmp"
	case ProtocolNumber_Igmp:
		return "Igmp"
	case ProtocolNumber_Ggp:
		return "Ggp"
	case ProtocolNumber_Ipv4:
		return "Ipv4"
	case ProtocolNumber_St:
		return "St"
	case ProtocolNumber_Tcp:
		return "Tcp"
	case ProtocolNumber_Cbt:
		return "Cbt"
	case ProtocolNumber_Egp:
		return "Egp"
	case ProtocolNumber_Igp:
		return "Igp"
	case ProtocolNumber_BbnRccMon:
		return "BbnRccMon"
	case ProtocolNumber_NvpIi:
		return "NvpIi"
	case ProtocolNumber_Pup:
		return "Pup"
	case ProtocolNumber_Argus:
		return "Argus"
	case ProtocolNumber_Emcon:
		return "Emcon"
	case ProtocolNumber_Xnet:
		return "Xnet"
	case ProtocolNumber_Chaos:
		return "Chaos"
	case ProtocolNumber_Udp:
		return "Udp"
	case ProtocolNumber_Mux:
		return "Mux"
	case ProtocolNumber_DcnMeas:
		return "DcnMeas"
	case ProtocolNumber_Hmp:
		return "Hmp"
	case ProtocolNumber_Prm:
		return "Prm"
	case ProtocolNumber_XnsIdp:
		return "XnsIdp"
	case ProtocolNumber_Trunk1:
		return "Trunk1"
	case ProtocolNumber_Trunk2:
		return "Trunk2"
	case ProtocolNumber_RoutingHeader:
		return "RoutingHeader"
	case ProtocolNumber_Icmpv6:
		return "Icmpv6"
	case ProtocolNumber_Ospf:
		return "Ospf"
	case ProtocolNumber_Ethernet:
		return "Ethernet"
	}
	return fmt.Sprintf("ProtocolNumber(%d)", t)
}

type EtherType uint16

const (
	EtherType_Ipv4           EtherType = 0x0800
	EtherType_Arp            EtherType = 0x0806
	EtherType_Vlan           EtherType = 0x8100
	EtherType_Ipv6           EtherType = 0x86DD
	EtherType_ServiceVlen    EtherType = 0x88A8
	EtherType_PppoeDiscovery EtherType = 0x8863
	EtherType_PppoeSession   EtherType = 0x8864
)

func (t EtherType) String() string {
	switch t {
	case EtherType_Ipv4:
		return "Ipv4"
	case EtherType_Arp:
		return "Arp"
	case EtherType_Vlan:
		return "Vlan"
	case EtherType_Ipv6:
		return "Ipv6"
	case EtherType_ServiceVlen:
		return "ServiceVlen"
	case EtherType_PppoeDiscovery:
		return "PppoeDiscovery"
	case EtherType_PppoeSession:
		return "PppoeSession"
	}
	return fmt.Sprintf("EtherType(%d)", t)
}

type Tcpstate int

const (
	Tcpstate_Closed      Tcpstate = 0
	Tcpstate_Listen      Tcpstate = 1
	Tcpstate_SynSent     Tcpstate = 2
	Tcpstate_SynRcvd     Tcpstate = 3
	Tcpstate_Established Tcpstate = 4
	Tcpstate_FinWait1    Tcpstate = 5
	Tcpstate_FinWait2    Tcpstate = 6
	Tcpstate_CloseWait   Tcpstate = 7
	Tcpstate_Closing     Tcpstate = 8
	Tcpstate_LastAck     Tcpstate = 9
	Tcpstate_TimeWait    Tcpstate = 10
)

func (t Tcpstate) String() string {
	switch t {
	case Tcpstate_Closed:
		return "Closed"
	case Tcpstate_Listen:
		return "Listen"
	case Tcpstate_SynSent:
		return "SynSent"
	case Tcpstate_SynRcvd:
		return "SynRcvd"
	case Tcpstate_Established:
		return "Established"
	case Tcpstate_FinWait1:
		return "FinWait1"
	case Tcpstate_FinWait2:
		return "FinWait2"
	case Tcpstate_CloseWait:
		return "CloseWait"
	case Tcpstate_Closing:
		return "Closing"
	case Tcpstate_LastAck:
		return "LastAck"
	case Tcpstate_TimeWait:
		return "TimeWait"
	}
	return fmt.Sprintf("Tcpstate(%d)", t)
}

type TcpoptionKind uint8

const (
	TcpoptionKind_EndOfOptionsList   TcpoptionKind = 0
	TcpoptionKind_Nop                TcpoptionKind = 1
	TcpoptionKind_MaximumSegmentSize TcpoptionKind = 2
	TcpoptionKind_WindowScale        TcpoptionKind = 3
	TcpoptionKind_SackPermitted      TcpoptionKind = 4
	TcpoptionKind_Sack               TcpoptionKind = 5
	TcpoptionKind_Timestamp          TcpoptionKind = 8
	TcpoptionKind_Mptcp              TcpoptionKind = 30
)

func (t TcpoptionKind) String() string {
	switch t {
	case TcpoptionKind_EndOfOptionsList:
		return "EndOfOptionsList"
	case TcpoptionKind_Nop:
		return "Nop"
	case TcpoptionKind_MaximumSegmentSize:
		return "MaximumSegmentSize"
	case TcpoptionKind_WindowScale:
		return "WindowScale"
	case TcpoptionKind_SackPermitted:
		return "SackPermitted"
	case TcpoptionKind_Sack:
		return "Sack"
	case TcpoptionKind_Timestamp:
		return "Timestamp"
	case TcpoptionKind_Mptcp:
		return "Mptcp"
	}
	return fmt.Sprintf("TcpoptionKind(%d)", t)
}

type Icmpv6Type uint8

const (
	Icmpv6Type_DestinationUnreachable                Icmpv6Type = 1
	Icmpv6Type_PacketTooBig                          Icmpv6Type = 2
	Icmpv6Type_TimeExceeded                          Icmpv6Type = 3
	Icmpv6Type_ParameterProblem                      Icmpv6Type = 4
	Icmpv6Type_EchoRequest                           Icmpv6Type = 128
	Icmpv6Type_EchoReply                             Icmpv6Type = 129
	Icmpv6Type_MulticastListenerQuery                Icmpv6Type = 130
	Icmpv6Type_MulticastListenerReport               Icmpv6Type = 131
	Icmpv6Type_MulticastListenerDone                 Icmpv6Type = 132
	Icmpv6Type_RouterSolicitation                    Icmpv6Type = 133
	Icmpv6Type_RouterAdvertisement                   Icmpv6Type = 134
	Icmpv6Type_NeighborSolicitation                  Icmpv6Type = 135
	Icmpv6Type_NeighborAdvertisement                 Icmpv6Type = 136
	Icmpv6Type_RedirectMessage                       Icmpv6Type = 137
	Icmpv6Type_RouterRenumbering                     Icmpv6Type = 138
	Icmpv6Type_NodeInformationQuery                  Icmpv6Type = 139
	Icmpv6Type_NodeInformationResponse               Icmpv6Type = 140
	Icmpv6Type_InverseNeighborDiscoverySolicitation  Icmpv6Type = 141
	Icmpv6Type_InverseNeighborDiscoveryAdvertisement Icmpv6Type = 142
	Icmpv6Type_V2MulticastListenerReport             Icmpv6Type = 143
	Icmpv6Type_HomeAgentAddressDiscoveryRequest      Icmpv6Type = 144
	Icmpv6Type_HomeAgentAddressDiscoveryReply        Icmpv6Type = 145
	Icmpv6Type_MobilePrefixSolicitation              Icmpv6Type = 146
	Icmpv6Type_MobilePrefixAdvertisement             Icmpv6Type = 147
	Icmpv6Type_CertificationPathSolicitation         Icmpv6Type = 148
	Icmpv6Type_CertificationPathAdvertisement        Icmpv6Type = 149
	Icmpv6Type_ExperimentalMobilityProtocols         Icmpv6Type = 253
	Icmpv6Type_ExperimentalMobilityProtocols2        Icmpv6Type = 254
	Icmpv6Type_Reserved                              Icmpv6Type = 255
)

func (t Icmpv6Type) String() string {
	switch t {
	case Icmpv6Type_DestinationUnreachable:
		return "DestinationUnreachable"
	case Icmpv6Type_PacketTooBig:
		return "PacketTooBig"
	case Icmpv6Type_TimeExceeded:
		return "TimeExceeded"
	case Icmpv6Type_ParameterProblem:
		return "ParameterProblem"
	case Icmpv6Type_EchoRequest:
		return "EchoRequest"
	case Icmpv6Type_EchoReply:
		return "EchoReply"
	case Icmpv6Type_MulticastListenerQuery:
		return "MulticastListenerQuery"
	case Icmpv6Type_MulticastListenerReport:
		return "MulticastListenerReport"
	case Icmpv6Type_MulticastListenerDone:
		return "MulticastListenerDone"
	case Icmpv6Type_RouterSolicitation:
		return "RouterSolicitation"
	case Icmpv6Type_RouterAdvertisement:
		return "RouterAdvertisement"
	case Icmpv6Type_NeighborSolicitation:
		return "NeighborSolicitation"
	case Icmpv6Type_NeighborAdvertisement:
		return "NeighborAdvertisement"
	case Icmpv6Type_RedirectMessage:
		return "RedirectMessage"
	case Icmpv6Type_RouterRenumbering:
		return "RouterRenumbering"
	case Icmpv6Type_NodeInformationQuery:
		return "NodeInformationQuery"
	case Icmpv6Type_NodeInformationResponse:
		return "NodeInformationResponse"
	case Icmpv6Type_InverseNeighborDiscoverySolicitation:
		return "InverseNeighborDiscoverySolicitation"
	case Icmpv6Type_InverseNeighborDiscoveryAdvertisement:
		return "InverseNeighborDiscoveryAdvertisement"
	case Icmpv6Type_V2MulticastListenerReport:
		return "V2MulticastListenerReport"
	case Icmpv6Type_HomeAgentAddressDiscoveryRequest:
		return "HomeAgentAddressDiscoveryRequest"
	case Icmpv6Type_HomeAgentAddressDiscoveryReply:
		return "HomeAgentAddressDiscoveryReply"
	case Icmpv6Type_MobilePrefixSolicitation:
		return "MobilePrefixSolicitation"
	case Icmpv6Type_MobilePrefixAdvertisement:
		return "MobilePrefixAdvertisement"
	case Icmpv6Type_CertificationPathSolicitation:
		return "CertificationPathSolicitation"
	case Icmpv6Type_CertificationPathAdvertisement:
		return "CertificationPathAdvertisement"
	case Icmpv6Type_ExperimentalMobilityProtocols:
		return "ExperimentalMobilityProtocols"
	case Icmpv6Type_ExperimentalMobilityProtocols2:
		return "ExperimentalMobilityProtocols2"
	case Icmpv6Type_Reserved:
		return "Reserved"
	}
	return fmt.Sprintf("Icmpv6Type(%d)", t)
}

type NdpoptionType uint8

const (
	NdpoptionType_SourceLinkLayerAddress NdpoptionType = 1
	NdpoptionType_TargetLinkLayerAddress NdpoptionType = 2
	NdpoptionType_PrefixInformation      NdpoptionType = 3
	NdpoptionType_RedirectHeader         NdpoptionType = 4
	NdpoptionType_Mtu                    NdpoptionType = 5
)

func (t NdpoptionType) String() string {
	switch t {
	case NdpoptionType_SourceLinkLayerAddress:
		return "SourceLinkLayerAddress"
	case NdpoptionType_TargetLinkLayerAddress:
		return "TargetLinkLayerAddress"
	case NdpoptionType_PrefixInformation:
		return "PrefixInformation"
	case NdpoptionType_RedirectHeader:
		return "RedirectHeader"
	case NdpoptionType_Mtu:
		return "Mtu"
	}
	return fmt.Sprintf("NdpoptionType(%d)", t)
}

type FlowSpecOp int

const (
	FlowSpecOp_FalseValue   FlowSpecOp = 0
	FlowSpecOp_Equal        FlowSpecOp = 1
	FlowSpecOp_Greater      FlowSpecOp = 2
	FlowSpecOp_GreaterEqual FlowSpecOp = 3
	FlowSpecOp_Less         FlowSpecOp = 4
	FlowSpecOp_LessEqual    FlowSpecOp = 5
	FlowSpecOp_NotEqual     FlowSpecOp = 6
	FlowSpecOp_TrueValue    FlowSpecOp = 7
)

func (t FlowSpecOp) String() string {
	switch t {
	case FlowSpecOp_FalseValue:
		return "FalseValue"
	case FlowSpecOp_Equal:
		return "Equal"
	case FlowSpecOp_Greater:
		return "Greater"
	case FlowSpecOp_GreaterEqual:
		return "GreaterEqual"
	case FlowSpecOp_Less:
		return "Less"
	case FlowSpecOp_LessEqual:
		return "LessEqual"
	case FlowSpecOp_NotEqual:
		return "NotEqual"
	case FlowSpecOp_TrueValue:
		return "TrueValue"
	}
	return fmt.Sprintf("FlowSpecOp(%d)", t)
}

type BgpflowSpecType uint8

const (
	BgpflowSpecType_Unknown      BgpflowSpecType = 0
	BgpflowSpecType_DstPrefix    BgpflowSpecType = 1
	BgpflowSpecType_SrcPrefix    BgpflowSpecType = 2
	BgpflowSpecType_IpProto      BgpflowSpecType = 3
	BgpflowSpecType_Port         BgpflowSpecType = 4
	BgpflowSpecType_DstPort      BgpflowSpecType = 5
	BgpflowSpecType_SrcPort      BgpflowSpecType = 6
	BgpflowSpecType_IcmpType     BgpflowSpecType = 7
	BgpflowSpecType_IcmpCode     BgpflowSpecType = 8
	BgpflowSpecType_TcpFlag      BgpflowSpecType = 9
	BgpflowSpecType_PktLen       BgpflowSpecType = 10
	BgpflowSpecType_Dscp         BgpflowSpecType = 11
	BgpflowSpecType_Fragment     BgpflowSpecType = 12
	BgpflowSpecType_Label        BgpflowSpecType = 13
	BgpflowSpecType_EthernetType BgpflowSpecType = 14
	BgpflowSpecType_SrcMac       BgpflowSpecType = 15
	BgpflowSpecType_DstMac       BgpflowSpecType = 16
	BgpflowSpecType_LlcDsap      BgpflowSpecType = 17
	BgpflowSpecType_LlcSsap      BgpflowSpecType = 18
	BgpflowSpecType_LlcControl   BgpflowSpecType = 19
	BgpflowSpecType_Snap         BgpflowSpecType = 20
	BgpflowSpecType_Vid          BgpflowSpecType = 21
	BgpflowSpecType_Cos          BgpflowSpecType = 22
	BgpflowSpecType_InnerVid     BgpflowSpecType = 23
	BgpflowSpecType_InnerCos     BgpflowSpecType = 24
)

func (t BgpflowSpecType) String() string {
	switch t {
	case BgpflowSpecType_Unknown:
		return "Unknown"
	case BgpflowSpecType_DstPrefix:
		return "DstPrefix"
	case BgpflowSpecType_SrcPrefix:
		return "SrcPrefix"
	case BgpflowSpecType_IpProto:
		return "IpProto"
	case BgpflowSpecType_Port:
		return "Port"
	case BgpflowSpecType_DstPort:
		return "DstPort"
	case BgpflowSpecType_SrcPort:
		return "SrcPort"
	case BgpflowSpecType_IcmpType:
		return "IcmpType"
	case BgpflowSpecType_IcmpCode:
		return "IcmpCode"
	case BgpflowSpecType_TcpFlag:
		return "TcpFlag"
	case BgpflowSpecType_PktLen:
		return "PktLen"
	case BgpflowSpecType_Dscp:
		return "Dscp"
	case BgpflowSpecType_Fragment:
		return "Fragment"
	case BgpflowSpecType_Label:
		return "Label"
	case BgpflowSpecType_EthernetType:
		return "EthernetType"
	case BgpflowSpecType_SrcMac:
		return "SrcMac"
	case BgpflowSpecType_DstMac:
		return "DstMac"
	case BgpflowSpecType_LlcDsap:
		return "LlcDsap"
	case BgpflowSpecType_LlcSsap:
		return "LlcSsap"
	case BgpflowSpecType_LlcControl:
		return "LlcControl"
	case BgpflowSpecType_Snap:
		return "Snap"
	case BgpflowSpecType_Vid:
		return "Vid"
	case BgpflowSpecType_Cos:
		return "Cos"
	case BgpflowSpecType_InnerVid:
		return "InnerVid"
	case BgpflowSpecType_InnerCos:
		return "InnerCos"
	}
	return fmt.Sprintf("BgpflowSpecType(%d)", t)
}

type EndpointBehavior uint16

const (
	EndpointBehavior_Reserved                   EndpointBehavior = 0
	EndpointBehavior_End                        EndpointBehavior = 1
	EndpointBehavior_EndWithPsp                 EndpointBehavior = 2
	EndpointBehavior_EndWithUsp                 EndpointBehavior = 3
	EndpointBehavior_EndWithPspAndUsp           EndpointBehavior = 4
	EndpointBehavior_EndX                       EndpointBehavior = 5
	EndpointBehavior_EndXwithPsp                EndpointBehavior = 6
	EndpointBehavior_EndXwithUsp                EndpointBehavior = 7
	EndpointBehavior_EndXwithPspAndUsp          EndpointBehavior = 8
	EndpointBehavior_EndT                       EndpointBehavior = 9
	EndpointBehavior_EndTwithPsp                EndpointBehavior = 10
	EndpointBehavior_EndTwithUsp                EndpointBehavior = 11
	EndpointBehavior_EndTwithPspAndUsp          EndpointBehavior = 12
	EndpointBehavior_Unassigned                 EndpointBehavior = 13
	EndpointBehavior_EndB6Encaps                EndpointBehavior = 14
	EndpointBehavior_EndBm                      EndpointBehavior = 15
	EndpointBehavior_EndDx6                     EndpointBehavior = 16
	EndpointBehavior_EndDx4                     EndpointBehavior = 17
	EndpointBehavior_EndDt6                     EndpointBehavior = 18
	EndpointBehavior_EndDt4                     EndpointBehavior = 19
	EndpointBehavior_EndDt46                    EndpointBehavior = 20
	EndpointBehavior_EndDx2                     EndpointBehavior = 21
	EndpointBehavior_EndDx2V                    EndpointBehavior = 22
	EndpointBehavior_EndDx2U                    EndpointBehavior = 23
	EndpointBehavior_EndDx2M                    EndpointBehavior = 24
	EndpointBehavior_Reserved2                  EndpointBehavior = 25
	EndpointBehavior_Unassigned2                EndpointBehavior = 26
	EndpointBehavior_EndB6EncapsRed             EndpointBehavior = 27
	EndpointBehavior_EndWithUsd                 EndpointBehavior = 28
	EndpointBehavior_EndWithPspAndUsd           EndpointBehavior = 29
	EndpointBehavior_EndWithUspAndUsd           EndpointBehavior = 30
	EndpointBehavior_EndXwithUsd                EndpointBehavior = 31
	EndpointBehavior_EndXwithPspAndUsd          EndpointBehavior = 32
	EndpointBehavior_EndXwithUspAndUsd          EndpointBehavior = 33
	EndpointBehavior_EndXwithPspUspAndUsd       EndpointBehavior = 34
	EndpointBehavior_EndTwithPspAndUsd          EndpointBehavior = 35
	EndpointBehavior_EndTwithUspAndUsd          EndpointBehavior = 36
	EndpointBehavior_EndTwithPspUspAndUsd       EndpointBehavior = 37
	EndpointBehavior_SidDefinedInRfc8754        EndpointBehavior = 0x7fff
	EndpointBehavior_ReservedForPrivateUseBegin EndpointBehavior = 0x8000
	EndpointBehavior_ReservedForPrivateUseEnd   EndpointBehavior = 0xfffe
	EndpointBehavior_Opaque                     EndpointBehavior = 0xffff
)

func (t EndpointBehavior) String() string {
	switch t {
	case EndpointBehavior_Reserved:
		return "Reserved"
	case EndpointBehavior_End:
		return "End"
	case EndpointBehavior_EndWithPsp:
		return "EndWithPsp"
	case EndpointBehavior_EndWithUsp:
		return "EndWithUsp"
	case EndpointBehavior_EndWithPspAndUsp:
		return "EndWithPspAndUsp"
	case EndpointBehavior_EndX:
		return "EndX"
	case EndpointBehavior_EndXwithPsp:
		return "EndXwithPsp"
	case EndpointBehavior_EndXwithUsp:
		return "EndXwithUsp"
	case EndpointBehavior_EndXwithPspAndUsp:
		return "EndXwithPspAndUsp"
	case EndpointBehavior_EndT:
		return "EndT"
	case EndpointBehavior_EndTwithPsp:
		return "EndTwithPsp"
	case EndpointBehavior_EndTwithUsp:
		return "EndTwithUsp"
	case EndpointBehavior_EndTwithPspAndUsp:
		return "EndTwithPspAndUsp"
	case EndpointBehavior_Unassigned:
		return "Unassigned"
	case EndpointBehavior_EndB6Encaps:
		return "EndB6Encaps"
	case EndpointBehavior_EndBm:
		return "EndBm"
	case EndpointBehavior_EndDx6:
		return "EndDx6"
	case EndpointBehavior_EndDx4:
		return "EndDx4"
	case EndpointBehavior_EndDt6:
		return "EndDt6"
	case EndpointBehavior_EndDt4:
		return "EndDt4"
	case EndpointBehavior_EndDt46:
		return "EndDt46"
	case EndpointBehavior_EndDx2:
		return "EndDx2"
	case EndpointBehavior_EndDx2V:
		return "EndDx2V"
	case EndpointBehavior_EndDx2U:
		return "EndDx2U"
	case EndpointBehavior_EndDx2M:
		return "EndDx2M"
	case EndpointBehavior_Reserved2:
		return "Reserved2"
	case EndpointBehavior_Unassigned2:
		return "Unassigned2"
	case EndpointBehavior_EndB6EncapsRed:
		return "EndB6EncapsRed"
	case EndpointBehavior_EndWithUsd:
		return "EndWithUsd"
	case EndpointBehavior_EndWithPspAndUsd:
		return "EndWithPspAndUsd"
	case EndpointBehavior_EndWithUspAndUsd:
		return "EndWithUspAndUsd"
	case EndpointBehavior_EndXwithUsd:
		return "EndXwithUsd"
	case EndpointBehavior_EndXwithPspAndUsd:
		return "EndXwithPspAndUsd"
	case EndpointBehavior_EndXwithUspAndUsd:
		return "EndXwithUspAndUsd"
	case EndpointBehavior_EndXwithPspUspAndUsd:
		return "EndXwithPspUspAndUsd"
	case EndpointBehavior_EndTwithPspAndUsd:
		return "EndTwithPspAndUsd"
	case EndpointBehavior_EndTwithUspAndUsd:
		return "EndTwithUspAndUsd"
	case EndpointBehavior_EndTwithPspUspAndUsd:
		return "EndTwithPspUspAndUsd"
	case EndpointBehavior_SidDefinedInRfc8754:
		return "SidDefinedInRfc8754"
	case EndpointBehavior_ReservedForPrivateUseBegin:
		return "ReservedForPrivateUseBegin"
	case EndpointBehavior_ReservedForPrivateUseEnd:
		return "ReservedForPrivateUseEnd"
	case EndpointBehavior_Opaque:
		return "Opaque"
	}
	return fmt.Sprintf("EndpointBehavior(%d)", t)
}

type union2_SegmentRoutingTlv interface {
	isunion1_()
}
type union_3_t struct {
	Len  uint8
	Data []uint8
}
type SegmentRoutingTlv struct {
	Type    uint8
	union1_ union2_SegmentRoutingTlv
}
type VisitorKEYKW interface {
	Visit(v VisitorKEYKW, name string, field any)
}
type VisitorKEYKWFunc func(v VisitorKEYKW, name string, field any)

func (f VisitorKEYKWFunc) Visit(v VisitorKEYKW, name string, field any) {
	f(v, name, field)
}

type VisitorKEYKWVisitable interface {
	Visit(v VisitorKEYKW)
}

func VisitorKEYKWToMap(v any) interface{} {
	if v == nil {
		return nil
	}
	if inter, ok := v.(VisitorKEYKWVisitable); ok {
		if p := reflect.ValueOf(inter); p.Kind() == reflect.Pointer && p.IsNil() {
			return nil
		}
		m := map[string]interface{}{}
		inter.Visit(VisitorKEYKWFunc(func(v VisitorKEYKW, name string, field any) {
			m[name] = VisitorKEYKWToMap(field)
		}))
		return m
	}
	if tf := reflect.TypeOf(v); (tf.Kind() == reflect.Slice || tf.Kind() == reflect.Array) && !(func() bool { k := tf.Elem().Kind().String(); return k[:3] == "int" || k[:3] == "uin" || k[:3] == "flo" })() {
		m := []interface{}{}
		vf := reflect.ValueOf(v)
		for i := 0; i < vf.Len(); i++ {
			index := vf.Index(i)
			if index.Kind() == reflect.Struct && index.CanAddr() {
				index = index.Addr()
			}
			m = append(m, VisitorKEYKWToMap(index.Interface()))
		}
		return m
	}
	if tf := reflect.TypeOf(v); tf.Kind() == reflect.Pointer {
		val := reflect.ValueOf(v)
		if val.IsNil() {
			return nil
		}
		return VisitorKEYKWToMap(val.Elem().Interface())
	}
	return v
}

type Ipv6ExtHeader struct {
	NextHeader ProtocolNumber
	HdrExtLen  uint8
}
type Ipv6Header struct {
	flags4     uint32
	PayloadLen uint16
	NextHeader ProtocolNumber
	HopLimit   uint8
	SrcAddr    [16]uint8
	DstAddr    [16]uint8
}
type Oui struct {
	flags7 uint8
	Low    [2]uint8
}
type union9_EthernetFrame interface {
	isunion8_()
}
type union_10_t struct {
	VlanTag    uint16
	EtherType2 uint16
}
type union_11_t struct {
	ServiceVlanTag uint16
	DummyEtherType uint16
	VlanTag        uint16
	EtherType2     uint16
}
type union13_EthernetFrame interface {
	isunion12_()
}
type union_14_t struct {
	Data []uint8
}
type union_15_t struct {
	Data []uint8
}
type EthernetFrame struct {
	DstMac    [6]uint8
	SrcMac    [6]uint8
	EtherType uint16
	union8_   union9_EthernetFrame
	union12_  union13_EthernetFrame
}
type Tcpflags struct {
	flags23 uint8
}
type SackBlock struct {
	Left  uint32
	Right uint32
}
type Timestamp struct {
	Value     uint32
	EchoReply uint32
}
type Icmpheader struct {
	Type     uint8
	Code     uint8
	Checksum uint16
}
type IcmptimeExceeded struct {
	Unused uint32
	Data   []uint8
}
type Icmpecho struct {
	Id   uint16
	Seq  uint16
	Data []uint8
}
type IcmpdestinationUnreachable struct {
	Unused     uint16
	NextHopMtu uint16
	Data       []uint8
}
type IcmppacketTooBig struct {
	Unused uint32
	Mtu    uint32
	Data   []uint8
}
type Icmpv6ParameterProblem struct {
	Pointer uint32
	Data    []uint8
}
type FloatMaximumResponseCode struct {
	flags37 uint16
}
type FloatQqic struct {
	flags39 uint8
}
type MulticastListenerQuery struct {
	MaxRespCode          uint16
	Reserved1            uint16
	McastAddr            [16]uint8
	flags40              uint8
	QuerierQueryInterval uint8
	NumberOfSources      uint16
	SourceAddr           [][16]uint8
}
type MulticastAddressRecord struct {
	RecordType      uint8
	AuxDataLen      uint8
	NumberOfSources uint16
	MulticastAddr   [16]uint8
	SourceAddr      [][16]uint8
	AuxData         []uint8
}
type PrefixInformation struct {
	PrefixLength      uint8
	flags49           uint8
	ValidLifetime     uint32
	PreferredLifetime uint32
	Reserved2         uint32
	Prefix            [16]uint8
}
type RedirectHeader struct {
	Reserved   [6]uint8
	HdrAndData []uint8
}
type Mtu struct {
	Reserved uint16
	Mtu      uint32
}
type Ipv6ChecksumPseudoHeader struct {
	SrcAddr          [16]uint8
	DstAddr          [16]uint8
	UpperLayerLength uint32
	Zero             uint32
	NextHeader       ProtocolNumber
}
type FlowSpecOpByte struct {
	flags56 uint8
}
type Udpheader struct {
	SrcPort  uint16
	DstPort  uint16
	Length   uint16
	Checksum uint16
}
type Ipv6ExtCommon struct {
	Header Ipv6ExtHeader
	Data   []uint8
}
type MacAddress struct {
	Oui Oui
	Nic [3]uint8
}
type Sack struct {
	Blocks []SackBlock
}
type union64_Tcpoption interface {
	isunion63_()
}
type union_65_t struct{}
type union_66_t struct{}
type union_67_t struct {
	Length uint8
	Mss    uint16
}
type union_68_t struct {
	Length     uint8
	ShiftCount uint8
}
type union_69_t struct {
	Length uint8
}
type union_70_t struct {
	Length uint8
	Sack   Sack
}
type union_71_t struct {
	Length    uint8
	Timestamp Timestamp
}
type union_72_t struct {
	Length uint8
	Data   []uint8
}
type Tcpoption struct {
	Kind     TcpoptionKind
	union63_ union64_Tcpoption
}
type Tcpheader struct {
	SrcPort       uint16
	DstPort       uint16
	SeqNum        uint32
	AckNum        uint32
	flags78       uint8
	Flags         Tcpflags
	WindowSize    uint16
	Checksum      uint16
	UrgentPointer uint16
	Options       []Tcpoption
}
type Tcpsegment struct {
	Hdr     Tcpheader
	Payload []uint8
}
type union90_Ndpoption interface {
	isunion89_()
}
type union_91_t struct {
	LinkLayerAddress []uint8
}
type union_92_t struct {
	LinkLayerAddress []uint8
}
type union_93_t struct {
	PrefixInformation PrefixInformation
}
type union_94_t struct {
	RedirectHeader RedirectHeader
}
type union_95_t struct {
	Mtu Mtu
}
type union_96_t struct {
	Data []uint8
}
type Ndpoption struct {
	Type     NdpoptionType
	Length   uint8
	union89_ union90_Ndpoption
}
type NdprouterSolicitation struct {
	Reserved uint32
	Options  []Ndpoption
}
type NdprouterAdvertisement struct {
	CurHopLimit    uint8
	flags106       uint8
	RouterLifetime uint16
	ReachableTime  uint32
	RetransTimer   uint32
	Options        []Ndpoption
}
type NdpneighborSolicitation struct {
	Reserved   uint32
	TargetAddr [16]uint8
	Options    []Ndpoption
}
type NdpneighborAdvertisement struct {
	flags115   uint32
	TargetAddr [16]uint8
	Options    []Ndpoption
}
type NdpredirectMessage struct {
	TargetAddr [16]uint8
	DestAddr   [16]uint8
	Options    []Ndpoption
}
type V2MulticastListernerReport struct {
	Reserved1       uint16
	NumberOfRecords uint16
	Records         []MulticastAddressRecord
}
type Udpdatagram struct {
	Header Udpheader
	Data   []uint8
}
type SegmentRouting struct {
	Header       Ipv6ExtHeader
	RoutingType  uint8
	SegmentsLeft uint8
	LastEntry    uint8
	flags125     uint8
	Tag          uint16
	SegmentList  [][16]uint8
	Options      []SegmentRoutingTlv
}
type union133_Icmpv6Packet interface {
	isunion132_()
}
type union_134_t struct {
	EchoRequest Icmpecho
}
type union_135_t struct {
	EchoReply Icmpecho
}
type union_136_t struct {
	TimeExceeded Icmpv6ParameterProblem
}
type union_137_t struct {
	PacketTooBig IcmppacketTooBig
}
type union_138_t struct {
	ParameterProblem Icmpv6ParameterProblem
}
type union_139_t struct {
	DestinationUnreachable IcmpdestinationUnreachable
}
type union_140_t struct {
	RouterSolicitation NdprouterSolicitation
}
type union_141_t struct {
	RouterAdvertisement NdprouterAdvertisement
}
type union_142_t struct {
	NeighborSolicitation NdpneighborSolicitation
}
type union_143_t struct {
	NeighborAdvertisement NdpneighborAdvertisement
}
type union_144_t struct {
	RedirectMessage NdpredirectMessage
}
type union_145_t struct {
	MulticastListenerQuery MulticastListenerQuery
}
type union_146_t struct {
	V2MulticastListenerReport V2MulticastListernerReport
}
type union_147_t struct {
	Data []uint8
}
type Icmpv6Packet struct {
	Header    Icmpheader
	union132_ union133_Icmpv6Packet
}

func (t *union_3_t) isunion1_() {}
func (t *SegmentRoutingTlv) Data() *[]uint8 {
	if true == (t.Type != 0) {
		if _, ok := t.union1_.(*union_3_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union1_.(*union_3_t).Data)
		return &tmp
	}
	return nil
}
func (t *SegmentRoutingTlv) SetData(v []uint8) bool {
	if true == (t.Type != 0) {
		if len(v) > int(^uint8(0)) {
			return false
		}
		if _, ok := t.union1_.(*union_3_t); !ok {
			t.union1_ = &union_3_t{}
		}
		t.union1_.(*union_3_t).Len = uint8(len(v))
		t.union1_.(*union_3_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *SegmentRoutingTlv) Len() *uint8 {
	if true == (t.Type != 0) {
		if _, ok := t.union1_.(*union_3_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union1_.(*union_3_t).Len)
		return &tmp
	}
	return nil
}
func (t *SegmentRoutingTlv) SetLen(v uint8) bool {
	if true == (t.Type != 0) {
		if _, ok := t.union1_.(*union_3_t); !ok {
			t.union1_ = &union_3_t{}
		}
		t.union1_.(*union_3_t).Len = uint8(v)
		return true
	}
	return false
}
func (t *SegmentRoutingTlv) Visit(v VisitorKEYKW) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "Len", (t.Len()))
}
func (t *SegmentRoutingTlv) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *SegmentRoutingTlv) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	if t.Type != 0 {
		if _, ok := t.union1_.(*union_3_t); !ok {
			return fmt.Errorf("encode t.union1_: union is not set to union_3_t")
		}
		if n, err := w.Write([]byte{byte(t.union1_.(*union_3_t).Len)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union1_.(*union_3_t).Len: %w", err)
		}
		len_Data := int(t.union1_.(*union_3_t).Len)
		if len(t.union1_.(*union_3_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union1_.(*union_3_t).Data))
		}
		if n, err := w.Write(t.union1_.(*union_3_t).Data); err != nil || n != len(t.union1_.(*union_3_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *SegmentRoutingTlv) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SegmentRoutingTlv) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SegmentRoutingTlv) Read(r io.Reader) (err error) {
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint8(tmpType[0])
	if t.Type != 0 {
		t.union1_ = &union_3_t{}
		tmpLen := [1]byte{}
		n_Len, err := io.ReadFull(r, tmpLen[:])
		if err != nil {
			return fmt.Errorf("read Len: expect 1 byte but read %d bytes: %w", n_Len, err)
		}
		t.union1_.(*union_3_t).Len = uint8(tmpLen[0])
		len_Data := int(t.union1_.(*union_3_t).Len)
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union1_.(*union_3_t).Data = tmpData[:]
		} else {
			t.union1_.(*union_3_t).Data = nil
		}
	}
	return nil
}

func (t *SegmentRoutingTlv) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SegmentRoutingTlv) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SegmentRoutingTlv: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Ipv6ExtHeader) Visit(v VisitorKEYKW) {
	v.Visit(v, "NextHeader", &t.NextHeader)
	v.Visit(v, "HdrExtLen", &t.HdrExtLen)
}
func (t *Ipv6ExtHeader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Ipv6ExtHeader) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.NextHeader)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.NextHeader: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.HdrExtLen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.HdrExtLen: %w", err)
	}
	return nil
}
func (t *Ipv6ExtHeader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Ipv6ExtHeader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Ipv6ExtHeader) Read(r io.Reader) (err error) {
	tmpNextHeader := [1]byte{}
	n_NextHeader, err := io.ReadFull(r, tmpNextHeader[:])
	if err != nil {
		return fmt.Errorf("read NextHeader: expect 1 byte but read %d bytes: %w", n_NextHeader, err)
	}
	t.NextHeader = ProtocolNumber(tmpNextHeader[0])
	tmpHdrExtLen := [1]byte{}
	n_HdrExtLen, err := io.ReadFull(r, tmpHdrExtLen[:])
	if err != nil {
		return fmt.Errorf("read HdrExtLen: expect 1 byte but read %d bytes: %w", n_HdrExtLen, err)
	}
	t.HdrExtLen = uint8(tmpHdrExtLen[0])
	return nil
}

func (t *Ipv6ExtHeader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Ipv6ExtHeader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Ipv6ExtHeader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Ipv6Header) Version() uint32 {
	return ((t.flags4 & 0xf0000000) >> 28)
}
func (t *Ipv6Header) SetVersion(v uint32) bool {
	if v > 15 {
		return false
	}
	t.flags4 = (t.flags4 & ^uint32(0xf0000000)) | ((v & 0xf) << 28)
	return true
}
func (t *Ipv6Header) TrafficClass() uint32 {
	return ((t.flags4 & 0x0ff00000) >> 20)
}
func (t *Ipv6Header) SetTrafficClass(v uint32) bool {
	if v > 255 {
		return false
	}
	t.flags4 = (t.flags4 & ^uint32(0xff00000)) | ((v & 0xff) << 20)
	return true
}
func (t *Ipv6Header) FlowLabel() uint32 {
	return ((t.flags4 & 0x000fffff) >> 0)
}
func (t *Ipv6Header) SetFlowLabel(v uint32) bool {
	if v > 1048575 {
		return false
	}
	t.flags4 = (t.flags4 & ^uint32(0xfffff)) | ((v & 0xfffff) << 0)
	return true
}
func (t *Ipv6Header) Visit(v VisitorKEYKW) {
	v.Visit(v, "Version", t.Version())
	v.Visit(v, "TrafficClass", t.TrafficClass())
	v.Visit(v, "FlowLabel", t.FlowLabel())
	v.Visit(v, "PayloadLen", &t.PayloadLen)
	v.Visit(v, "NextHeader", &t.NextHeader)
	v.Visit(v, "HopLimit", &t.HopLimit)
	v.Visit(v, "SrcAddr", &t.SrcAddr)
	v.Visit(v, "DstAddr", &t.DstAddr)
}
func (t *Ipv6Header) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Ipv6Header) Write(w io.Writer) (err error) {
	tmp5 := [4]byte{}
	binary.BigEndian.PutUint32(tmp5[:], uint32(t.flags4))
	if n, err := w.Write(tmp5[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.flags4: %w", err)
	}
	tmp6 := [2]byte{}
	binary.BigEndian.PutUint16(tmp6[:], uint16(t.PayloadLen))
	if n, err := w.Write(tmp6[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.PayloadLen: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.NextHeader)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.NextHeader: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.HopLimit)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.HopLimit: %w", err)
	}
	if n, err := w.Write(t.SrcAddr[:]); err != nil || n != len(t.SrcAddr) {
		return fmt.Errorf("encode SrcAddr: %w", err)
	}
	if n, err := w.Write(t.DstAddr[:]); err != nil || n != len(t.DstAddr) {
		return fmt.Errorf("encode DstAddr: %w", err)
	}
	return nil
}
func (t *Ipv6Header) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 40))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Ipv6Header) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Ipv6Header) Read(r io.Reader) (err error) {
	tmpflags4 := [4]byte{}
	n_flags4, err := io.ReadFull(r, tmpflags4[:])
	if err != nil {
		return fmt.Errorf("read flags4: expect 4 bytes but read %d bytes: %w", n_flags4, err)
	}
	t.flags4 = uint32(binary.BigEndian.Uint32(tmpflags4[:]))
	tmpPayloadLen := [2]byte{}
	n_PayloadLen, err := io.ReadFull(r, tmpPayloadLen[:])
	if err != nil {
		return fmt.Errorf("read PayloadLen: expect 2 bytes but read %d bytes: %w", n_PayloadLen, err)
	}
	t.PayloadLen = uint16(binary.BigEndian.Uint16(tmpPayloadLen[:]))
	tmpNextHeader := [1]byte{}
	n_NextHeader, err := io.ReadFull(r, tmpNextHeader[:])
	if err != nil {
		return fmt.Errorf("read NextHeader: expect 1 byte but read %d bytes: %w", n_NextHeader, err)
	}
	t.NextHeader = ProtocolNumber(tmpNextHeader[0])
	tmpHopLimit := [1]byte{}
	n_HopLimit, err := io.ReadFull(r, tmpHopLimit[:])
	if err != nil {
		return fmt.Errorf("read HopLimit: expect 1 byte but read %d bytes: %w", n_HopLimit, err)
	}
	t.HopLimit = uint8(tmpHopLimit[0])
	n_SrcAddr, err := io.ReadFull(r, t.SrcAddr[:])
	if err != nil {
		return fmt.Errorf("read SrcAddr: expect %d bytes but read %d bytes: %w", 16, n_SrcAddr, err)
	}
	n_DstAddr, err := io.ReadFull(r, t.DstAddr[:])
	if err != nil {
		return fmt.Errorf("read DstAddr: expect %d bytes but read %d bytes: %w", 16, n_DstAddr, err)
	}
	return nil
}

func (t *Ipv6Header) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Ipv6Header) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Ipv6Header: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Oui) High() uint8 {
	return ((t.flags7 & 0xfc) >> 2)
}
func (t *Oui) SetHigh(v uint8) bool {
	if v > 63 {
		return false
	}
	t.flags7 = (t.flags7 & ^uint8(0xfc)) | ((v & 0x3f) << 2)
	return true
}
func (t *Oui) Local() bool {
	return ((t.flags7 & 0x02) >> 1) == 1
}
func (t *Oui) SetLocal(v bool) {
	if v {
		t.flags7 |= uint8(0x2)
	} else {
		t.flags7 &= ^uint8(0x2)
	}
}
func (t *Oui) Multicast() bool {
	return ((t.flags7 & 0x01) >> 0) == 1
}
func (t *Oui) SetMulticast(v bool) {
	if v {
		t.flags7 |= uint8(0x1)
	} else {
		t.flags7 &= ^uint8(0x1)
	}
}
func (t *Oui) Visit(v VisitorKEYKW) {
	v.Visit(v, "High", t.High())
	v.Visit(v, "Local", (func() uint8 {
		if t.Local() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Multicast", (func() uint8 {
		if t.Multicast() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Low", &t.Low)
}
func (t *Oui) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Oui) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags7)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags7: %w", err)
	}
	if n, err := w.Write(t.Low[:]); err != nil || n != len(t.Low) {
		return fmt.Errorf("encode Low: %w", err)
	}
	return nil
}
func (t *Oui) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 3))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Oui) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Oui) Read(r io.Reader) (err error) {
	tmpflags7 := [1]byte{}
	n_flags7, err := io.ReadFull(r, tmpflags7[:])
	if err != nil {
		return fmt.Errorf("read flags7: expect 1 byte but read %d bytes: %w", n_flags7, err)
	}
	t.flags7 = uint8(tmpflags7[0])
	n_Low, err := io.ReadFull(r, t.Low[:])
	if err != nil {
		return fmt.Errorf("read Low: expect %d bytes but read %d bytes: %w", 2, n_Low, err)
	}
	return nil
}

func (t *Oui) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Oui) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Oui: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_10_t) isunion8_() {}
func (t *union_11_t) isunion8_() {}
func (t *EthernetFrame) DummyEtherType() *uint16 {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		return nil
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union8_.(*union_11_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union8_.(*union_11_t).DummyEtherType)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetDummyEtherType(v uint16) bool {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		return false
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union8_.(*union_11_t); !ok {
			t.union8_ = &union_11_t{}
		}
		t.union8_.(*union_11_t).DummyEtherType = uint16(v)
		return true
	}
	return false
}
func (t *EthernetFrame) EtherType2() *uint16 {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		if _, ok := t.union8_.(*union_10_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union8_.(*union_10_t).EtherType2)
		return &tmp
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union8_.(*union_11_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union8_.(*union_11_t).EtherType2)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetEtherType2(v uint16) bool {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		if _, ok := t.union8_.(*union_10_t); !ok {
			t.union8_ = &union_10_t{}
		}
		t.union8_.(*union_10_t).EtherType2 = uint16(v)
		return true
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union8_.(*union_11_t); !ok {
			t.union8_ = &union_11_t{}
		}
		t.union8_.(*union_11_t).EtherType2 = uint16(v)
		return true
	}
	return false
}
func (t *EthernetFrame) ServiceVlanTag() *uint16 {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		return nil
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union8_.(*union_11_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union8_.(*union_11_t).ServiceVlanTag)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetServiceVlanTag(v uint16) bool {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		return false
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union8_.(*union_11_t); !ok {
			t.union8_ = &union_11_t{}
		}
		t.union8_.(*union_11_t).ServiceVlanTag = uint16(v)
		return true
	}
	return false
}
func (t *EthernetFrame) VlanTag() *uint16 {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		if _, ok := t.union8_.(*union_10_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union8_.(*union_10_t).VlanTag)
		return &tmp
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union8_.(*union_11_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union8_.(*union_11_t).VlanTag)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetVlanTag(v uint16) bool {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		if _, ok := t.union8_.(*union_10_t); !ok {
			t.union8_ = &union_10_t{}
		}
		t.union8_.(*union_10_t).VlanTag = uint16(v)
		return true
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union8_.(*union_11_t); !ok {
			t.union8_ = &union_11_t{}
		}
		t.union8_.(*union_11_t).VlanTag = uint16(v)
		return true
	}
	return false
}
func (t *union_14_t) isunion12_() {}
func (t *union_15_t) isunion12_() {}
func (t *EthernetFrame) Data() *[]uint8 {
	Len := (func() uint16 {
		if func() bool {
			if true == (t.EtherType == uint16(EtherType_Vlan)) {
				return true
			} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
				return true
			}
			return false
		}() {
			return uint16((*t.EtherType2()))
		} else {
			return uint16(t.EtherType)
		}
	}())
	if true == (Len >= 0x600) {
		if _, ok := t.union12_.(*union_14_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union12_.(*union_14_t).Data)
		return &tmp
	} else if true {
		if _, ok := t.union12_.(*union_15_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union12_.(*union_15_t).Data)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetData(v []uint8) bool {
	Len := (func() uint16 {
		if func() bool {
			if true == (t.EtherType == uint16(EtherType_Vlan)) {
				return true
			} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
				return true
			}
			return false
		}() {
			return uint16((*t.EtherType2()))
		} else {
			return uint16(t.EtherType)
		}
	}())
	if true == (Len >= 0x600) {
		if _, ok := t.union12_.(*union_14_t); !ok {
			t.union12_ = &union_14_t{}
		}
		t.union12_.(*union_14_t).Data = []uint8(v)
		return true
	} else if true {
		if _, ok := t.union12_.(*union_15_t); !ok {
			t.union12_ = &union_15_t{}
		}
		t.union12_.(*union_15_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *EthernetFrame) Visit(v VisitorKEYKW) {
	v.Visit(v, "DstMac", &t.DstMac)
	v.Visit(v, "SrcMac", &t.SrcMac)
	v.Visit(v, "EtherType", &t.EtherType)
	v.Visit(v, "DummyEtherType", (t.DummyEtherType()))
	v.Visit(v, "EtherType2", (t.EtherType2()))
	v.Visit(v, "ServiceVlanTag", (t.ServiceVlanTag()))
	v.Visit(v, "VlanTag", (t.VlanTag()))
	v.Visit(v, "Data", (t.Data()))
}
func (t *EthernetFrame) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *EthernetFrame) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.DstMac[:]); err != nil || n != len(t.DstMac) {
		return fmt.Errorf("encode DstMac: %w", err)
	}
	if n, err := w.Write(t.SrcMac[:]); err != nil || n != len(t.SrcMac) {
		return fmt.Errorf("encode SrcMac: %w", err)
	}
	tmp16 := [2]byte{}
	binary.BigEndian.PutUint16(tmp16[:], uint16(t.EtherType))
	if n, err := w.Write(tmp16[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.EtherType: %w", err)
	}
	if t.EtherType == uint16(EtherType_Vlan) {
		if _, ok := t.union8_.(*union_10_t); !ok {
			return fmt.Errorf("encode t.union8_: union is not set to union_10_t")
		}
		tmp17 := [2]byte{}
		binary.BigEndian.PutUint16(tmp17[:], uint16(t.union8_.(*union_10_t).VlanTag))
		if n, err := w.Write(tmp17[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union8_.(*union_10_t).VlanTag: %w", err)
		}
		tmp18 := [2]byte{}
		binary.BigEndian.PutUint16(tmp18[:], uint16(t.union8_.(*union_10_t).EtherType2))
		if n, err := w.Write(tmp18[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union8_.(*union_10_t).EtherType2: %w", err)
		}
	} else if t.EtherType == uint16(EtherType_ServiceVlen) {
		if _, ok := t.union8_.(*union_11_t); !ok {
			return fmt.Errorf("encode t.union8_: union is not set to union_11_t")
		}
		tmp19 := [2]byte{}
		binary.BigEndian.PutUint16(tmp19[:], uint16(t.union8_.(*union_11_t).ServiceVlanTag))
		if n, err := w.Write(tmp19[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union8_.(*union_11_t).ServiceVlanTag: %w", err)
		}
		tmp20 := [2]byte{}
		binary.BigEndian.PutUint16(tmp20[:], uint16(t.union8_.(*union_11_t).DummyEtherType))
		if n, err := w.Write(tmp20[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union8_.(*union_11_t).DummyEtherType: %w", err)
		}
		tmp21 := [2]byte{}
		binary.BigEndian.PutUint16(tmp21[:], uint16(t.union8_.(*union_11_t).VlanTag))
		if n, err := w.Write(tmp21[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union8_.(*union_11_t).VlanTag: %w", err)
		}
		tmp22 := [2]byte{}
		binary.BigEndian.PutUint16(tmp22[:], uint16(t.union8_.(*union_11_t).EtherType2))
		if n, err := w.Write(tmp22[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union8_.(*union_11_t).EtherType2: %w", err)
		}
	}
	Len := (func() uint16 {
		if func() bool {
			if true == (t.EtherType == uint16(EtherType_Vlan)) {
				return true
			} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
				return true
			}
			return false
		}() {
			return uint16((*t.EtherType2()))
		} else {
			return uint16(t.EtherType)
		}
	}())
	if Len >= 0x600 {
		if _, ok := t.union12_.(*union_14_t); !ok {
			return fmt.Errorf("encode t.union12_: union is not set to union_14_t")
		}
		if n, err := w.Write(t.union12_.(*union_14_t).Data); err != nil || n != len(t.union12_.(*union_14_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	} else {
		if _, ok := t.union12_.(*union_15_t); !ok {
			return fmt.Errorf("encode t.union12_: union is not set to union_15_t")
		}
		len_Data := int(Len)
		if len(t.union12_.(*union_15_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union12_.(*union_15_t).Data))
		}
		if n, err := w.Write(t.union12_.(*union_15_t).Data); err != nil || n != len(t.union12_.(*union_15_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *EthernetFrame) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 14))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *EthernetFrame) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *EthernetFrame) Read(r io.Reader) (err error) {
	n_DstMac, err := io.ReadFull(r, t.DstMac[:])
	if err != nil {
		return fmt.Errorf("read DstMac: expect %d bytes but read %d bytes: %w", 6, n_DstMac, err)
	}
	n_SrcMac, err := io.ReadFull(r, t.SrcMac[:])
	if err != nil {
		return fmt.Errorf("read SrcMac: expect %d bytes but read %d bytes: %w", 6, n_SrcMac, err)
	}
	tmpEtherType := [2]byte{}
	n_EtherType, err := io.ReadFull(r, tmpEtherType[:])
	if err != nil {
		return fmt.Errorf("read EtherType: expect 2 bytes but read %d bytes: %w", n_EtherType, err)
	}
	t.EtherType = uint16(binary.BigEndian.Uint16(tmpEtherType[:]))
	if t.EtherType == uint16(EtherType_Vlan) {
		t.union8_ = &union_10_t{}
		tmpVlanTag := [2]byte{}
		n_VlanTag, err := io.ReadFull(r, tmpVlanTag[:])
		if err != nil {
			return fmt.Errorf("read VlanTag: expect 2 bytes but read %d bytes: %w", n_VlanTag, err)
		}
		t.union8_.(*union_10_t).VlanTag = uint16(binary.BigEndian.Uint16(tmpVlanTag[:]))
		tmpEtherType2 := [2]byte{}
		n_EtherType2, err := io.ReadFull(r, tmpEtherType2[:])
		if err != nil {
			return fmt.Errorf("read EtherType2: expect 2 bytes but read %d bytes: %w", n_EtherType2, err)
		}
		t.union8_.(*union_10_t).EtherType2 = uint16(binary.BigEndian.Uint16(tmpEtherType2[:]))
	} else if t.EtherType == uint16(EtherType_ServiceVlen) {
		t.union8_ = &union_11_t{}
		tmpServiceVlanTag := [2]byte{}
		n_ServiceVlanTag, err := io.ReadFull(r, tmpServiceVlanTag[:])
		if err != nil {
			return fmt.Errorf("read ServiceVlanTag: expect 2 bytes but read %d bytes: %w", n_ServiceVlanTag, err)
		}
		t.union8_.(*union_11_t).ServiceVlanTag = uint16(binary.BigEndian.Uint16(tmpServiceVlanTag[:]))
		tmpDummyEtherType := [2]byte{}
		n_DummyEtherType, err := io.ReadFull(r, tmpDummyEtherType[:])
		if err != nil {
			return fmt.Errorf("read DummyEtherType: expect 2 bytes but read %d bytes: %w", n_DummyEtherType, err)
		}
		t.union8_.(*union_11_t).DummyEtherType = uint16(binary.BigEndian.Uint16(tmpDummyEtherType[:]))
		tmpVlanTag := [2]byte{}
		n_VlanTag, err := io.ReadFull(r, tmpVlanTag[:])
		if err != nil {
			return fmt.Errorf("read VlanTag: expect 2 bytes but read %d bytes: %w", n_VlanTag, err)
		}
		t.union8_.(*union_11_t).VlanTag = uint16(binary.BigEndian.Uint16(tmpVlanTag[:]))
		tmpEtherType2 := [2]byte{}
		n_EtherType2, err := io.ReadFull(r, tmpEtherType2[:])
		if err != nil {
			return fmt.Errorf("read EtherType2: expect 2 bytes but read %d bytes: %w", n_EtherType2, err)
		}
		t.union8_.(*union_11_t).EtherType2 = uint16(binary.BigEndian.Uint16(tmpEtherType2[:]))
	}
	Len := (func() uint16 {
		if func() bool {
			if true == (t.EtherType == uint16(EtherType_Vlan)) {
				return true
			} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
				return true
			}
			return false
		}() {
			return uint16((*t.EtherType2()))
		} else {
			return uint16(t.EtherType)
		}
	}())
	if Len >= 0x600 {
		t.union12_ = &union_14_t{}
		bytes_buf_Data := &bytes.Buffer{}
		if _, err := io.Copy(bytes_buf_Data, r); err != nil {
			return err
		}
		t.union12_.(*union_14_t).Data = bytes_buf_Data.Bytes()
	} else {
		t.union12_ = &union_15_t{}
		len_Data := int(Len)
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union12_.(*union_15_t).Data = tmpData[:]
		} else {
			t.union12_.(*union_15_t).Data = nil
		}
	}
	return nil
}

func (t *EthernetFrame) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *EthernetFrame) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode EthernetFrame: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Tcpflags) Cwr() bool {
	return ((t.flags23 & 0x80) >> 7) == 1
}
func (t *Tcpflags) SetCwr(v bool) {
	if v {
		t.flags23 |= uint8(0x80)
	} else {
		t.flags23 &= ^uint8(0x80)
	}
}
func (t *Tcpflags) Ece() bool {
	return ((t.flags23 & 0x40) >> 6) == 1
}
func (t *Tcpflags) SetEce(v bool) {
	if v {
		t.flags23 |= uint8(0x40)
	} else {
		t.flags23 &= ^uint8(0x40)
	}
}
func (t *Tcpflags) Urg() bool {
	return ((t.flags23 & 0x20) >> 5) == 1
}
func (t *Tcpflags) SetUrg(v bool) {
	if v {
		t.flags23 |= uint8(0x20)
	} else {
		t.flags23 &= ^uint8(0x20)
	}
}
func (t *Tcpflags) Ack() bool {
	return ((t.flags23 & 0x10) >> 4) == 1
}
func (t *Tcpflags) SetAck(v bool) {
	if v {
		t.flags23 |= uint8(0x10)
	} else {
		t.flags23 &= ^uint8(0x10)
	}
}
func (t *Tcpflags) Psh() bool {
	return ((t.flags23 & 0x08) >> 3) == 1
}
func (t *Tcpflags) SetPsh(v bool) {
	if v {
		t.flags23 |= uint8(0x8)
	} else {
		t.flags23 &= ^uint8(0x8)
	}
}
func (t *Tcpflags) Rst() bool {
	return ((t.flags23 & 0x04) >> 2) == 1
}
func (t *Tcpflags) SetRst(v bool) {
	if v {
		t.flags23 |= uint8(0x4)
	} else {
		t.flags23 &= ^uint8(0x4)
	}
}
func (t *Tcpflags) Syn() bool {
	return ((t.flags23 & 0x02) >> 1) == 1
}
func (t *Tcpflags) SetSyn(v bool) {
	if v {
		t.flags23 |= uint8(0x2)
	} else {
		t.flags23 &= ^uint8(0x2)
	}
}
func (t *Tcpflags) Fin() bool {
	return ((t.flags23 & 0x01) >> 0) == 1
}
func (t *Tcpflags) SetFin(v bool) {
	if v {
		t.flags23 |= uint8(0x1)
	} else {
		t.flags23 &= ^uint8(0x1)
	}
}
func (t *Tcpflags) Visit(v VisitorKEYKW) {
	v.Visit(v, "Cwr", (func() uint8 {
		if t.Cwr() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Ece", (func() uint8 {
		if t.Ece() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Urg", (func() uint8 {
		if t.Urg() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Ack", (func() uint8 {
		if t.Ack() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Psh", (func() uint8 {
		if t.Psh() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Rst", (func() uint8 {
		if t.Rst() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Syn", (func() uint8 {
		if t.Syn() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Fin", (func() uint8 {
		if t.Fin() {
			return 1
		} else {
			return 0
		}
	}()))
}
func (t *Tcpflags) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Tcpflags) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags23)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags23: %w", err)
	}
	return nil
}
func (t *Tcpflags) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Tcpflags) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Tcpflags) Read(r io.Reader) (err error) {
	tmpflags23 := [1]byte{}
	n_flags23, err := io.ReadFull(r, tmpflags23[:])
	if err != nil {
		return fmt.Errorf("read flags23: expect 1 byte but read %d bytes: %w", n_flags23, err)
	}
	t.flags23 = uint8(tmpflags23[0])
	return nil
}

func (t *Tcpflags) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Tcpflags) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Tcpflags: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SackBlock) Visit(v VisitorKEYKW) {
	v.Visit(v, "Left", &t.Left)
	v.Visit(v, "Right", &t.Right)
}
func (t *SackBlock) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *SackBlock) Write(w io.Writer) (err error) {
	tmp24 := [4]byte{}
	binary.BigEndian.PutUint32(tmp24[:], uint32(t.Left))
	if n, err := w.Write(tmp24[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Left: %w", err)
	}
	tmp25 := [4]byte{}
	binary.BigEndian.PutUint32(tmp25[:], uint32(t.Right))
	if n, err := w.Write(tmp25[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Right: %w", err)
	}
	return nil
}
func (t *SackBlock) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SackBlock) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SackBlock) Read(r io.Reader) (err error) {
	tmpLeft := [4]byte{}
	n_Left, err := io.ReadFull(r, tmpLeft[:])
	if err != nil {
		return fmt.Errorf("read Left: expect 4 bytes but read %d bytes: %w", n_Left, err)
	}
	t.Left = uint32(binary.BigEndian.Uint32(tmpLeft[:]))
	tmpRight := [4]byte{}
	n_Right, err := io.ReadFull(r, tmpRight[:])
	if err != nil {
		return fmt.Errorf("read Right: expect 4 bytes but read %d bytes: %w", n_Right, err)
	}
	t.Right = uint32(binary.BigEndian.Uint32(tmpRight[:]))
	return nil
}

func (t *SackBlock) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SackBlock) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SackBlock: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Timestamp) Visit(v VisitorKEYKW) {
	v.Visit(v, "Value", &t.Value)
	v.Visit(v, "EchoReply", &t.EchoReply)
}
func (t *Timestamp) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Timestamp) Write(w io.Writer) (err error) {
	tmp26 := [4]byte{}
	binary.BigEndian.PutUint32(tmp26[:], uint32(t.Value))
	if n, err := w.Write(tmp26[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Value: %w", err)
	}
	tmp27 := [4]byte{}
	binary.BigEndian.PutUint32(tmp27[:], uint32(t.EchoReply))
	if n, err := w.Write(tmp27[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.EchoReply: %w", err)
	}
	return nil
}
func (t *Timestamp) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Timestamp) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Timestamp) Read(r io.Reader) (err error) {
	tmpValue := [4]byte{}
	n_Value, err := io.ReadFull(r, tmpValue[:])
	if err != nil {
		return fmt.Errorf("read Value: expect 4 bytes but read %d bytes: %w", n_Value, err)
	}
	t.Value = uint32(binary.BigEndian.Uint32(tmpValue[:]))
	tmpEchoReply := [4]byte{}
	n_EchoReply, err := io.ReadFull(r, tmpEchoReply[:])
	if err != nil {
		return fmt.Errorf("read EchoReply: expect 4 bytes but read %d bytes: %w", n_EchoReply, err)
	}
	t.EchoReply = uint32(binary.BigEndian.Uint32(tmpEchoReply[:]))
	return nil
}

func (t *Timestamp) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Timestamp) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Timestamp: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Icmpheader) Visit(v VisitorKEYKW) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Code", &t.Code)
	v.Visit(v, "Checksum", &t.Checksum)
}
func (t *Icmpheader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Icmpheader) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Code)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Code: %w", err)
	}
	tmp28 := [2]byte{}
	binary.BigEndian.PutUint16(tmp28[:], uint16(t.Checksum))
	if n, err := w.Write(tmp28[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Checksum: %w", err)
	}
	return nil
}
func (t *Icmpheader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Icmpheader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Icmpheader) Read(r io.Reader) (err error) {
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint8(tmpType[0])
	tmpCode := [1]byte{}
	n_Code, err := io.ReadFull(r, tmpCode[:])
	if err != nil {
		return fmt.Errorf("read Code: expect 1 byte but read %d bytes: %w", n_Code, err)
	}
	t.Code = uint8(tmpCode[0])
	tmpChecksum := [2]byte{}
	n_Checksum, err := io.ReadFull(r, tmpChecksum[:])
	if err != nil {
		return fmt.Errorf("read Checksum: expect 2 bytes but read %d bytes: %w", n_Checksum, err)
	}
	t.Checksum = uint16(binary.BigEndian.Uint16(tmpChecksum[:]))
	return nil
}

func (t *Icmpheader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Icmpheader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Icmpheader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *IcmptimeExceeded) Visit(v VisitorKEYKW) {
	v.Visit(v, "Unused", &t.Unused)
	v.Visit(v, "Data", &t.Data)
}
func (t *IcmptimeExceeded) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *IcmptimeExceeded) Write(w io.Writer) (err error) {
	tmp29 := [4]byte{}
	binary.BigEndian.PutUint32(tmp29[:], uint32(t.Unused))
	if n, err := w.Write(tmp29[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Unused: %w", err)
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *IcmptimeExceeded) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *IcmptimeExceeded) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *IcmptimeExceeded) Read(r io.Reader) (err error) {
	tmpUnused := [4]byte{}
	n_Unused, err := io.ReadFull(r, tmpUnused[:])
	if err != nil {
		return fmt.Errorf("read Unused: expect 4 bytes but read %d bytes: %w", n_Unused, err)
	}
	t.Unused = uint32(binary.BigEndian.Uint32(tmpUnused[:]))
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	return nil
}

func (t *IcmptimeExceeded) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *IcmptimeExceeded) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode IcmptimeExceeded: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Icmpecho) Visit(v VisitorKEYKW) {
	v.Visit(v, "Id", &t.Id)
	v.Visit(v, "Seq", &t.Seq)
	v.Visit(v, "Data", &t.Data)
}
func (t *Icmpecho) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Icmpecho) Write(w io.Writer) (err error) {
	tmp30 := [2]byte{}
	binary.BigEndian.PutUint16(tmp30[:], uint16(t.Id))
	if n, err := w.Write(tmp30[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Id: %w", err)
	}
	tmp31 := [2]byte{}
	binary.BigEndian.PutUint16(tmp31[:], uint16(t.Seq))
	if n, err := w.Write(tmp31[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Seq: %w", err)
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Icmpecho) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Icmpecho) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Icmpecho) Read(r io.Reader) (err error) {
	tmpId := [2]byte{}
	n_Id, err := io.ReadFull(r, tmpId[:])
	if err != nil {
		return fmt.Errorf("read Id: expect 2 bytes but read %d bytes: %w", n_Id, err)
	}
	t.Id = uint16(binary.BigEndian.Uint16(tmpId[:]))
	tmpSeq := [2]byte{}
	n_Seq, err := io.ReadFull(r, tmpSeq[:])
	if err != nil {
		return fmt.Errorf("read Seq: expect 2 bytes but read %d bytes: %w", n_Seq, err)
	}
	t.Seq = uint16(binary.BigEndian.Uint16(tmpSeq[:]))
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	return nil
}

func (t *Icmpecho) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Icmpecho) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Icmpecho: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *IcmpdestinationUnreachable) Visit(v VisitorKEYKW) {
	v.Visit(v, "Unused", &t.Unused)
	v.Visit(v, "NextHopMtu", &t.NextHopMtu)
	v.Visit(v, "Data", &t.Data)
}
func (t *IcmpdestinationUnreachable) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *IcmpdestinationUnreachable) Write(w io.Writer) (err error) {
	tmp32 := [2]byte{}
	binary.BigEndian.PutUint16(tmp32[:], uint16(t.Unused))
	if n, err := w.Write(tmp32[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Unused: %w", err)
	}
	tmp33 := [2]byte{}
	binary.BigEndian.PutUint16(tmp33[:], uint16(t.NextHopMtu))
	if n, err := w.Write(tmp33[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.NextHopMtu: %w", err)
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *IcmpdestinationUnreachable) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *IcmpdestinationUnreachable) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *IcmpdestinationUnreachable) Read(r io.Reader) (err error) {
	tmpUnused := [2]byte{}
	n_Unused, err := io.ReadFull(r, tmpUnused[:])
	if err != nil {
		return fmt.Errorf("read Unused: expect 2 bytes but read %d bytes: %w", n_Unused, err)
	}
	t.Unused = uint16(binary.BigEndian.Uint16(tmpUnused[:]))
	tmpNextHopMtu := [2]byte{}
	n_NextHopMtu, err := io.ReadFull(r, tmpNextHopMtu[:])
	if err != nil {
		return fmt.Errorf("read NextHopMtu: expect 2 bytes but read %d bytes: %w", n_NextHopMtu, err)
	}
	t.NextHopMtu = uint16(binary.BigEndian.Uint16(tmpNextHopMtu[:]))
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	return nil
}

func (t *IcmpdestinationUnreachable) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *IcmpdestinationUnreachable) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode IcmpdestinationUnreachable: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *IcmppacketTooBig) Visit(v VisitorKEYKW) {
	v.Visit(v, "Unused", &t.Unused)
	v.Visit(v, "Mtu", &t.Mtu)
	v.Visit(v, "Data", &t.Data)
}
func (t *IcmppacketTooBig) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *IcmppacketTooBig) Write(w io.Writer) (err error) {
	tmp34 := [4]byte{}
	binary.BigEndian.PutUint32(tmp34[:], uint32(t.Unused))
	if n, err := w.Write(tmp34[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Unused: %w", err)
	}
	tmp35 := [4]byte{}
	binary.BigEndian.PutUint32(tmp35[:], uint32(t.Mtu))
	if n, err := w.Write(tmp35[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Mtu: %w", err)
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *IcmppacketTooBig) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *IcmppacketTooBig) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *IcmppacketTooBig) Read(r io.Reader) (err error) {
	tmpUnused := [4]byte{}
	n_Unused, err := io.ReadFull(r, tmpUnused[:])
	if err != nil {
		return fmt.Errorf("read Unused: expect 4 bytes but read %d bytes: %w", n_Unused, err)
	}
	t.Unused = uint32(binary.BigEndian.Uint32(tmpUnused[:]))
	tmpMtu := [4]byte{}
	n_Mtu, err := io.ReadFull(r, tmpMtu[:])
	if err != nil {
		return fmt.Errorf("read Mtu: expect 4 bytes but read %d bytes: %w", n_Mtu, err)
	}
	t.Mtu = uint32(binary.BigEndian.Uint32(tmpMtu[:]))
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	return nil
}

func (t *IcmppacketTooBig) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *IcmppacketTooBig) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode IcmppacketTooBig: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Icmpv6ParameterProblem) Visit(v VisitorKEYKW) {
	v.Visit(v, "Pointer", &t.Pointer)
	v.Visit(v, "Data", &t.Data)
}
func (t *Icmpv6ParameterProblem) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Icmpv6ParameterProblem) Write(w io.Writer) (err error) {
	tmp36 := [4]byte{}
	binary.BigEndian.PutUint32(tmp36[:], uint32(t.Pointer))
	if n, err := w.Write(tmp36[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Pointer: %w", err)
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Icmpv6ParameterProblem) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Icmpv6ParameterProblem) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Icmpv6ParameterProblem) Read(r io.Reader) (err error) {
	tmpPointer := [4]byte{}
	n_Pointer, err := io.ReadFull(r, tmpPointer[:])
	if err != nil {
		return fmt.Errorf("read Pointer: expect 4 bytes but read %d bytes: %w", n_Pointer, err)
	}
	t.Pointer = uint32(binary.BigEndian.Uint32(tmpPointer[:]))
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	return nil
}

func (t *Icmpv6ParameterProblem) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Icmpv6ParameterProblem) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Icmpv6ParameterProblem: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *FloatMaximumResponseCode) One() bool {
	return ((t.flags37 & 0x8000) >> 15) == 1
}
func (t *FloatMaximumResponseCode) SetOne(v bool) {
	if v {
		t.flags37 |= uint16(0x8000)
	} else {
		t.flags37 &= ^uint16(0x8000)
	}
}
func (t *FloatMaximumResponseCode) Exp() uint16 {
	return ((t.flags37 & 0x7000) >> 12)
}
func (t *FloatMaximumResponseCode) SetExp(v uint16) bool {
	if v > 7 {
		return false
	}
	t.flags37 = (t.flags37 & ^uint16(0x7000)) | ((v & 0x7) << 12)
	return true
}
func (t *FloatMaximumResponseCode) Mant() uint16 {
	return ((t.flags37 & 0x0fff) >> 0)
}
func (t *FloatMaximumResponseCode) SetMant(v uint16) bool {
	if v > 4095 {
		return false
	}
	t.flags37 = (t.flags37 & ^uint16(0xfff)) | ((v & 0xfff) << 0)
	return true
}
func (t *FloatMaximumResponseCode) Visit(v VisitorKEYKW) {
	v.Visit(v, "One", (func() uint16 {
		if t.One() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Exp", t.Exp())
	v.Visit(v, "Mant", t.Mant())
}
func (t *FloatMaximumResponseCode) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *FloatMaximumResponseCode) Write(w io.Writer) (err error) {
	tmp38 := [2]byte{}
	binary.BigEndian.PutUint16(tmp38[:], uint16(t.flags37))
	if n, err := w.Write(tmp38[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.flags37: %w", err)
	}
	return nil
}
func (t *FloatMaximumResponseCode) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *FloatMaximumResponseCode) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *FloatMaximumResponseCode) Read(r io.Reader) (err error) {
	tmpflags37 := [2]byte{}
	n_flags37, err := io.ReadFull(r, tmpflags37[:])
	if err != nil {
		return fmt.Errorf("read flags37: expect 2 bytes but read %d bytes: %w", n_flags37, err)
	}
	t.flags37 = uint16(binary.BigEndian.Uint16(tmpflags37[:]))
	return nil
}

func (t *FloatMaximumResponseCode) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *FloatMaximumResponseCode) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode FloatMaximumResponseCode: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *FloatQqic) One() bool {
	return ((t.flags39 & 0x80) >> 7) == 1
}
func (t *FloatQqic) SetOne(v bool) {
	if v {
		t.flags39 |= uint8(0x80)
	} else {
		t.flags39 &= ^uint8(0x80)
	}
}
func (t *FloatQqic) Exp() uint8 {
	return ((t.flags39 & 0x70) >> 4)
}
func (t *FloatQqic) SetExp(v uint8) bool {
	if v > 7 {
		return false
	}
	t.flags39 = (t.flags39 & ^uint8(0x70)) | ((v & 0x7) << 4)
	return true
}
func (t *FloatQqic) Mant() uint8 {
	return ((t.flags39 & 0x0f) >> 0)
}
func (t *FloatQqic) SetMant(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags39 = (t.flags39 & ^uint8(0xf)) | ((v & 0xf) << 0)
	return true
}
func (t *FloatQqic) Visit(v VisitorKEYKW) {
	v.Visit(v, "One", (func() uint8 {
		if t.One() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Exp", t.Exp())
	v.Visit(v, "Mant", t.Mant())
}
func (t *FloatQqic) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *FloatQqic) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags39)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags39: %w", err)
	}
	return nil
}
func (t *FloatQqic) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *FloatQqic) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *FloatQqic) Read(r io.Reader) (err error) {
	tmpflags39 := [1]byte{}
	n_flags39, err := io.ReadFull(r, tmpflags39[:])
	if err != nil {
		return fmt.Errorf("read flags39: expect 1 byte but read %d bytes: %w", n_flags39, err)
	}
	t.flags39 = uint8(tmpflags39[0])
	return nil
}

func (t *FloatQqic) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *FloatQqic) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode FloatQqic: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *MulticastListenerQuery) Reserved2() uint8 {
	return ((t.flags40 & 0xf0) >> 4)
}
func (t *MulticastListenerQuery) SetReserved2(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags40 = (t.flags40 & ^uint8(0xf0)) | ((v & 0xf) << 4)
	return true
}
func (t *MulticastListenerQuery) SuppressRouterProcessing() bool {
	return ((t.flags40 & 0x08) >> 3) == 1
}
func (t *MulticastListenerQuery) SetSuppressRouterProcessing(v bool) {
	if v {
		t.flags40 |= uint8(0x8)
	} else {
		t.flags40 &= ^uint8(0x8)
	}
}
func (t *MulticastListenerQuery) QueriesRobustnessVar() uint8 {
	return ((t.flags40 & 0x07) >> 0)
}
func (t *MulticastListenerQuery) SetQueriesRobustnessVar(v uint8) bool {
	if v > 7 {
		return false
	}
	t.flags40 = (t.flags40 & ^uint8(0x7)) | ((v & 0x7) << 0)
	return true
}
func (t *MulticastListenerQuery) SetSourceAddr(v [][16]uint8) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.NumberOfSources = uint16(len(v))
	t.SourceAddr = v
	return true
}
func (t *MulticastListenerQuery) Visit(v VisitorKEYKW) {
	v.Visit(v, "MaxRespCode", &t.MaxRespCode)
	v.Visit(v, "Reserved1", &t.Reserved1)
	v.Visit(v, "McastAddr", &t.McastAddr)
	v.Visit(v, "Reserved2", t.Reserved2())
	v.Visit(v, "SuppressRouterProcessing", (func() uint8 {
		if t.SuppressRouterProcessing() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "QueriesRobustnessVar", t.QueriesRobustnessVar())
	v.Visit(v, "QuerierQueryInterval", &t.QuerierQueryInterval)
	v.Visit(v, "NumberOfSources", &t.NumberOfSources)
	v.Visit(v, "SourceAddr", &t.SourceAddr)
}
func (t *MulticastListenerQuery) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *MulticastListenerQuery) Write(w io.Writer) (err error) {
	tmp41 := [2]byte{}
	binary.BigEndian.PutUint16(tmp41[:], uint16(t.MaxRespCode))
	if n, err := w.Write(tmp41[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.MaxRespCode: %w", err)
	}
	tmp42 := [2]byte{}
	binary.BigEndian.PutUint16(tmp42[:], uint16(t.Reserved1))
	if n, err := w.Write(tmp42[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Reserved1: %w", err)
	}
	if n, err := w.Write(t.McastAddr[:]); err != nil || n != len(t.McastAddr) {
		return fmt.Errorf("encode McastAddr: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags40)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags40: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.QuerierQueryInterval)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.QuerierQueryInterval: %w", err)
	}
	tmp43 := [2]byte{}
	binary.BigEndian.PutUint16(tmp43[:], uint16(t.NumberOfSources))
	if n, err := w.Write(tmp43[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.NumberOfSources: %w", err)
	}
	len_SourceAddr := int(t.NumberOfSources)
	if len(t.SourceAddr) != len_SourceAddr {
		return fmt.Errorf("encode SourceAddr: expect %d but got %d for length", len_SourceAddr, len(t.SourceAddr))
	}
	for _, v := range t.SourceAddr {
		if n, err := w.Write(v[:]); err != nil || n != len(v) {
			return fmt.Errorf("encode SourceAddr: %w", err)
		}
	}
	return nil
}
func (t *MulticastListenerQuery) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 24))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *MulticastListenerQuery) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *MulticastListenerQuery) Read(r io.Reader) (err error) {
	tmpMaxRespCode := [2]byte{}
	n_MaxRespCode, err := io.ReadFull(r, tmpMaxRespCode[:])
	if err != nil {
		return fmt.Errorf("read MaxRespCode: expect 2 bytes but read %d bytes: %w", n_MaxRespCode, err)
	}
	t.MaxRespCode = uint16(binary.BigEndian.Uint16(tmpMaxRespCode[:]))
	tmpReserved1 := [2]byte{}
	n_Reserved1, err := io.ReadFull(r, tmpReserved1[:])
	if err != nil {
		return fmt.Errorf("read Reserved1: expect 2 bytes but read %d bytes: %w", n_Reserved1, err)
	}
	t.Reserved1 = uint16(binary.BigEndian.Uint16(tmpReserved1[:]))
	n_McastAddr, err := io.ReadFull(r, t.McastAddr[:])
	if err != nil {
		return fmt.Errorf("read McastAddr: expect %d bytes but read %d bytes: %w", 16, n_McastAddr, err)
	}
	tmpflags40 := [1]byte{}
	n_flags40, err := io.ReadFull(r, tmpflags40[:])
	if err != nil {
		return fmt.Errorf("read flags40: expect 1 byte but read %d bytes: %w", n_flags40, err)
	}
	t.flags40 = uint8(tmpflags40[0])
	tmpQuerierQueryInterval := [1]byte{}
	n_QuerierQueryInterval, err := io.ReadFull(r, tmpQuerierQueryInterval[:])
	if err != nil {
		return fmt.Errorf("read QuerierQueryInterval: expect 1 byte but read %d bytes: %w", n_QuerierQueryInterval, err)
	}
	t.QuerierQueryInterval = uint8(tmpQuerierQueryInterval[0])
	tmpNumberOfSources := [2]byte{}
	n_NumberOfSources, err := io.ReadFull(r, tmpNumberOfSources[:])
	if err != nil {
		return fmt.Errorf("read NumberOfSources: expect 2 bytes but read %d bytes: %w", n_NumberOfSources, err)
	}
	t.NumberOfSources = uint16(binary.BigEndian.Uint16(tmpNumberOfSources[:]))
	len_SourceAddr := int(t.NumberOfSources)
	for i_44 := 0; i_44 < len_SourceAddr; i_44++ {
		var tmp45_ [16]uint8
		n_SourceAddr, err := io.ReadFull(r, tmp45_[:])
		if err != nil {
			return fmt.Errorf("read SourceAddr: expect %d bytes but read %d bytes: %w", 16, n_SourceAddr, err)
		}
		t.SourceAddr = append(t.SourceAddr, tmp45_)
	}
	return nil
}

func (t *MulticastListenerQuery) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *MulticastListenerQuery) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode MulticastListenerQuery: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *MulticastAddressRecord) SetSourceAddr(v [][16]uint8) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.NumberOfSources = uint16(len(v))
	t.SourceAddr = v
	return true
}
func (t *MulticastAddressRecord) SetAuxData(v []uint8) bool {
	if len(v) > int(^uint8(0)) {
		return false
	}
	t.AuxDataLen = uint8(len(v))
	t.AuxData = v
	return true
}
func (t *MulticastAddressRecord) Visit(v VisitorKEYKW) {
	v.Visit(v, "RecordType", &t.RecordType)
	v.Visit(v, "AuxDataLen", &t.AuxDataLen)
	v.Visit(v, "NumberOfSources", &t.NumberOfSources)
	v.Visit(v, "MulticastAddr", &t.MulticastAddr)
	v.Visit(v, "SourceAddr", &t.SourceAddr)
	v.Visit(v, "AuxData", &t.AuxData)
}
func (t *MulticastAddressRecord) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *MulticastAddressRecord) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.RecordType)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.RecordType: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.AuxDataLen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.AuxDataLen: %w", err)
	}
	tmp46 := [2]byte{}
	binary.BigEndian.PutUint16(tmp46[:], uint16(t.NumberOfSources))
	if n, err := w.Write(tmp46[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.NumberOfSources: %w", err)
	}
	if n, err := w.Write(t.MulticastAddr[:]); err != nil || n != len(t.MulticastAddr) {
		return fmt.Errorf("encode MulticastAddr: %w", err)
	}
	len_SourceAddr := int(t.NumberOfSources)
	if len(t.SourceAddr) != len_SourceAddr {
		return fmt.Errorf("encode SourceAddr: expect %d but got %d for length", len_SourceAddr, len(t.SourceAddr))
	}
	for _, v := range t.SourceAddr {
		if n, err := w.Write(v[:]); err != nil || n != len(v) {
			return fmt.Errorf("encode SourceAddr: %w", err)
		}
	}
	len_AuxData := int(t.AuxDataLen)
	if len(t.AuxData) != len_AuxData {
		return fmt.Errorf("encode AuxData: expect %d bytes but got %d bytes", len_AuxData, len(t.AuxData))
	}
	if n, err := w.Write(t.AuxData); err != nil || n != len(t.AuxData) {
		return fmt.Errorf("encode AuxData: %w", err)
	}
	return nil
}
func (t *MulticastAddressRecord) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 20))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *MulticastAddressRecord) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *MulticastAddressRecord) Read(r io.Reader) (err error) {
	tmpRecordType := [1]byte{}
	n_RecordType, err := io.ReadFull(r, tmpRecordType[:])
	if err != nil {
		return fmt.Errorf("read RecordType: expect 1 byte but read %d bytes: %w", n_RecordType, err)
	}
	t.RecordType = uint8(tmpRecordType[0])
	tmpAuxDataLen := [1]byte{}
	n_AuxDataLen, err := io.ReadFull(r, tmpAuxDataLen[:])
	if err != nil {
		return fmt.Errorf("read AuxDataLen: expect 1 byte but read %d bytes: %w", n_AuxDataLen, err)
	}
	t.AuxDataLen = uint8(tmpAuxDataLen[0])
	tmpNumberOfSources := [2]byte{}
	n_NumberOfSources, err := io.ReadFull(r, tmpNumberOfSources[:])
	if err != nil {
		return fmt.Errorf("read NumberOfSources: expect 2 bytes but read %d bytes: %w", n_NumberOfSources, err)
	}
	t.NumberOfSources = uint16(binary.BigEndian.Uint16(tmpNumberOfSources[:]))
	n_MulticastAddr, err := io.ReadFull(r, t.MulticastAddr[:])
	if err != nil {
		return fmt.Errorf("read MulticastAddr: expect %d bytes but read %d bytes: %w", 16, n_MulticastAddr, err)
	}
	len_SourceAddr := int(t.NumberOfSources)
	for i_47 := 0; i_47 < len_SourceAddr; i_47++ {
		var tmp48_ [16]uint8
		n_SourceAddr, err := io.ReadFull(r, tmp48_[:])
		if err != nil {
			return fmt.Errorf("read SourceAddr: expect %d bytes but read %d bytes: %w", 16, n_SourceAddr, err)
		}
		t.SourceAddr = append(t.SourceAddr, tmp48_)
	}
	len_AuxData := int(t.AuxDataLen)
	if len_AuxData != 0 {
		tmpAuxData := make([]byte, len_AuxData)
		n_AuxData, err := io.ReadFull(r, tmpAuxData[:])
		if err != nil {
			return fmt.Errorf("read AuxData: expect %d bytes but read %d bytes: %w", len_AuxData, n_AuxData, err)
		}
		t.AuxData = tmpAuxData[:]
	} else {
		t.AuxData = nil
	}
	return nil
}

func (t *MulticastAddressRecord) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *MulticastAddressRecord) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode MulticastAddressRecord: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *PrefixInformation) OnLink() bool {
	return ((t.flags49 & 0x80) >> 7) == 1
}
func (t *PrefixInformation) SetOnLink(v bool) {
	if v {
		t.flags49 |= uint8(0x80)
	} else {
		t.flags49 &= ^uint8(0x80)
	}
}
func (t *PrefixInformation) Autoconfig() bool {
	return ((t.flags49 & 0x40) >> 6) == 1
}
func (t *PrefixInformation) SetAutoconfig(v bool) {
	if v {
		t.flags49 |= uint8(0x40)
	} else {
		t.flags49 &= ^uint8(0x40)
	}
}
func (t *PrefixInformation) Reserved1() uint8 {
	return ((t.flags49 & 0x3f) >> 0)
}
func (t *PrefixInformation) SetReserved1(v uint8) bool {
	if v > 63 {
		return false
	}
	t.flags49 = (t.flags49 & ^uint8(0x3f)) | ((v & 0x3f) << 0)
	return true
}
func (t *PrefixInformation) Visit(v VisitorKEYKW) {
	v.Visit(v, "PrefixLength", &t.PrefixLength)
	v.Visit(v, "OnLink", (func() uint8 {
		if t.OnLink() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Autoconfig", (func() uint8 {
		if t.Autoconfig() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved1", t.Reserved1())
	v.Visit(v, "ValidLifetime", &t.ValidLifetime)
	v.Visit(v, "PreferredLifetime", &t.PreferredLifetime)
	v.Visit(v, "Reserved2", &t.Reserved2)
	v.Visit(v, "Prefix", &t.Prefix)
}
func (t *PrefixInformation) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *PrefixInformation) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.PrefixLength)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.PrefixLength: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags49)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags49: %w", err)
	}
	tmp50 := [4]byte{}
	binary.BigEndian.PutUint32(tmp50[:], uint32(t.ValidLifetime))
	if n, err := w.Write(tmp50[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.ValidLifetime: %w", err)
	}
	tmp51 := [4]byte{}
	binary.BigEndian.PutUint32(tmp51[:], uint32(t.PreferredLifetime))
	if n, err := w.Write(tmp51[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.PreferredLifetime: %w", err)
	}
	tmp52 := [4]byte{}
	binary.BigEndian.PutUint32(tmp52[:], uint32(t.Reserved2))
	if n, err := w.Write(tmp52[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Reserved2: %w", err)
	}
	if n, err := w.Write(t.Prefix[:]); err != nil || n != len(t.Prefix) {
		return fmt.Errorf("encode Prefix: %w", err)
	}
	return nil
}
func (t *PrefixInformation) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 30))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *PrefixInformation) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *PrefixInformation) Read(r io.Reader) (err error) {
	tmpPrefixLength := [1]byte{}
	n_PrefixLength, err := io.ReadFull(r, tmpPrefixLength[:])
	if err != nil {
		return fmt.Errorf("read PrefixLength: expect 1 byte but read %d bytes: %w", n_PrefixLength, err)
	}
	t.PrefixLength = uint8(tmpPrefixLength[0])
	tmpflags49 := [1]byte{}
	n_flags49, err := io.ReadFull(r, tmpflags49[:])
	if err != nil {
		return fmt.Errorf("read flags49: expect 1 byte but read %d bytes: %w", n_flags49, err)
	}
	t.flags49 = uint8(tmpflags49[0])
	tmpValidLifetime := [4]byte{}
	n_ValidLifetime, err := io.ReadFull(r, tmpValidLifetime[:])
	if err != nil {
		return fmt.Errorf("read ValidLifetime: expect 4 bytes but read %d bytes: %w", n_ValidLifetime, err)
	}
	t.ValidLifetime = uint32(binary.BigEndian.Uint32(tmpValidLifetime[:]))
	tmpPreferredLifetime := [4]byte{}
	n_PreferredLifetime, err := io.ReadFull(r, tmpPreferredLifetime[:])
	if err != nil {
		return fmt.Errorf("read PreferredLifetime: expect 4 bytes but read %d bytes: %w", n_PreferredLifetime, err)
	}
	t.PreferredLifetime = uint32(binary.BigEndian.Uint32(tmpPreferredLifetime[:]))
	tmpReserved2 := [4]byte{}
	n_Reserved2, err := io.ReadFull(r, tmpReserved2[:])
	if err != nil {
		return fmt.Errorf("read Reserved2: expect 4 bytes but read %d bytes: %w", n_Reserved2, err)
	}
	t.Reserved2 = uint32(binary.BigEndian.Uint32(tmpReserved2[:]))
	n_Prefix, err := io.ReadFull(r, t.Prefix[:])
	if err != nil {
		return fmt.Errorf("read Prefix: expect %d bytes but read %d bytes: %w", 16, n_Prefix, err)
	}
	return nil
}

func (t *PrefixInformation) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *PrefixInformation) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode PrefixInformation: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *RedirectHeader) Visit(v VisitorKEYKW) {
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "HdrAndData", &t.HdrAndData)
}
func (t *RedirectHeader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *RedirectHeader) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.Reserved[:]); err != nil || n != len(t.Reserved) {
		return fmt.Errorf("encode Reserved: %w", err)
	}
	if n, err := w.Write(t.HdrAndData); err != nil || n != len(t.HdrAndData) {
		return fmt.Errorf("encode HdrAndData: %w", err)
	}
	return nil
}
func (t *RedirectHeader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 6))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *RedirectHeader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *RedirectHeader) Read(r io.Reader) (err error) {
	n_Reserved, err := io.ReadFull(r, t.Reserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect %d bytes but read %d bytes: %w", 6, n_Reserved, err)
	}
	bytes_buf_HdrAndData := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_HdrAndData, r); err != nil {
		return err
	}
	t.HdrAndData = bytes_buf_HdrAndData.Bytes()
	return nil
}

func (t *RedirectHeader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *RedirectHeader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode RedirectHeader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Mtu) Visit(v VisitorKEYKW) {
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "Mtu", &t.Mtu)
}
func (t *Mtu) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Mtu) Write(w io.Writer) (err error) {
	tmp53 := [2]byte{}
	binary.BigEndian.PutUint16(tmp53[:], uint16(t.Reserved))
	if n, err := w.Write(tmp53[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	tmp54 := [4]byte{}
	binary.BigEndian.PutUint32(tmp54[:], uint32(t.Mtu))
	if n, err := w.Write(tmp54[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Mtu: %w", err)
	}
	return nil
}
func (t *Mtu) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 6))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Mtu) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Mtu) Read(r io.Reader) (err error) {
	tmpReserved := [2]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 2 bytes but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint16(binary.BigEndian.Uint16(tmpReserved[:]))
	tmpMtu := [4]byte{}
	n_Mtu, err := io.ReadFull(r, tmpMtu[:])
	if err != nil {
		return fmt.Errorf("read Mtu: expect 4 bytes but read %d bytes: %w", n_Mtu, err)
	}
	t.Mtu = uint32(binary.BigEndian.Uint32(tmpMtu[:]))
	return nil
}

func (t *Mtu) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Mtu) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Mtu: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Ipv6ChecksumPseudoHeader) Visit(v VisitorKEYKW) {
	v.Visit(v, "SrcAddr", &t.SrcAddr)
	v.Visit(v, "DstAddr", &t.DstAddr)
	v.Visit(v, "UpperLayerLength", &t.UpperLayerLength)
	v.Visit(v, "Zero", &t.Zero)
	v.Visit(v, "NextHeader", &t.NextHeader)
}
func (t *Ipv6ChecksumPseudoHeader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Ipv6ChecksumPseudoHeader) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.SrcAddr[:]); err != nil || n != len(t.SrcAddr) {
		return fmt.Errorf("encode SrcAddr: %w", err)
	}
	if n, err := w.Write(t.DstAddr[:]); err != nil || n != len(t.DstAddr) {
		return fmt.Errorf("encode DstAddr: %w", err)
	}
	tmp55 := [4]byte{}
	binary.BigEndian.PutUint32(tmp55[:], uint32(t.UpperLayerLength))
	if n, err := w.Write(tmp55[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.UpperLayerLength: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Zero >> 16), byte(t.Zero >> 8), byte(t.Zero)}); err != nil || n != 3 {
		return fmt.Errorf("encode t.Zero: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.NextHeader)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.NextHeader: %w", err)
	}
	return nil
}
func (t *Ipv6ChecksumPseudoHeader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 40))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Ipv6ChecksumPseudoHeader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Ipv6ChecksumPseudoHeader) Read(r io.Reader) (err error) {
	n_SrcAddr, err := io.ReadFull(r, t.SrcAddr[:])
	if err != nil {
		return fmt.Errorf("read SrcAddr: expect %d bytes but read %d bytes: %w", 16, n_SrcAddr, err)
	}
	n_DstAddr, err := io.ReadFull(r, t.DstAddr[:])
	if err != nil {
		return fmt.Errorf("read DstAddr: expect %d bytes but read %d bytes: %w", 16, n_DstAddr, err)
	}
	tmpUpperLayerLength := [4]byte{}
	n_UpperLayerLength, err := io.ReadFull(r, tmpUpperLayerLength[:])
	if err != nil {
		return fmt.Errorf("read UpperLayerLength: expect 4 bytes but read %d bytes: %w", n_UpperLayerLength, err)
	}
	t.UpperLayerLength = uint32(binary.BigEndian.Uint32(tmpUpperLayerLength[:]))
	tmpZero := [3]byte{}
	n_Zero, err := io.ReadFull(r, tmpZero[:])
	if err != nil {
		return fmt.Errorf("read Zero: expect 3 bytes but read %d bytes: %w", n_Zero, err)
	}
	t.Zero = uint32(uint32(tmpZero[0])<<16 | uint32(tmpZero[1])<<8 | uint32(tmpZero[2]))
	tmpNextHeader := [1]byte{}
	n_NextHeader, err := io.ReadFull(r, tmpNextHeader[:])
	if err != nil {
		return fmt.Errorf("read NextHeader: expect 1 byte but read %d bytes: %w", n_NextHeader, err)
	}
	t.NextHeader = ProtocolNumber(tmpNextHeader[0])
	return nil
}

func (t *Ipv6ChecksumPseudoHeader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Ipv6ChecksumPseudoHeader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Ipv6ChecksumPseudoHeader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *FlowSpecOpByte) End() bool {
	return ((t.flags56 & 0x80) >> 7) == 1
}
func (t *FlowSpecOpByte) SetEnd(v bool) {
	if v {
		t.flags56 |= uint8(0x80)
	} else {
		t.flags56 &= ^uint8(0x80)
	}
}
func (t *FlowSpecOpByte) AndBit() bool {
	return ((t.flags56 & 0x40) >> 6) == 1
}
func (t *FlowSpecOpByte) SetAndBit(v bool) {
	if v {
		t.flags56 |= uint8(0x40)
	} else {
		t.flags56 &= ^uint8(0x40)
	}
}
func (t *FlowSpecOpByte) Len() uint8 {
	return ((t.flags56 & 0x30) >> 4)
}
func (t *FlowSpecOpByte) SetLen(v uint8) bool {
	if v > 3 {
		return false
	}
	t.flags56 = (t.flags56 & ^uint8(0x30)) | ((v & 0x3) << 4)
	return true
}
func (t *FlowSpecOpByte) Reserved() bool {
	return ((t.flags56 & 0x08) >> 3) == 1
}
func (t *FlowSpecOpByte) SetReserved(v bool) {
	if v {
		t.flags56 |= uint8(0x8)
	} else {
		t.flags56 &= ^uint8(0x8)
	}
}
func (t *FlowSpecOpByte) Op() FlowSpecOp {
	return FlowSpecOp(((t.flags56 & 0x07) >> 0))
}
func (t *FlowSpecOpByte) SetOp(v FlowSpecOp) bool {
	if v > 7 {
		return false
	}
	t.flags56 = (t.flags56 & ^uint8(0x7)) | ((uint8(v) & 0x7) << 0)
	return true
}
func (t *FlowSpecOpByte) Visit(v VisitorKEYKW) {
	v.Visit(v, "End", (func() uint8 {
		if t.End() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "AndBit", (func() uint8 {
		if t.AndBit() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Len", t.Len())
	v.Visit(v, "Reserved", (func() uint8 {
		if t.Reserved() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Op", t.Op())
}
func (t *FlowSpecOpByte) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *FlowSpecOpByte) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags56)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags56: %w", err)
	}
	return nil
}
func (t *FlowSpecOpByte) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *FlowSpecOpByte) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *FlowSpecOpByte) Read(r io.Reader) (err error) {
	tmpflags56 := [1]byte{}
	n_flags56, err := io.ReadFull(r, tmpflags56[:])
	if err != nil {
		return fmt.Errorf("read flags56: expect 1 byte but read %d bytes: %w", n_flags56, err)
	}
	t.flags56 = uint8(tmpflags56[0])
	return nil
}

func (t *FlowSpecOpByte) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *FlowSpecOpByte) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode FlowSpecOpByte: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Udpheader) Visit(v VisitorKEYKW) {
	v.Visit(v, "SrcPort", &t.SrcPort)
	v.Visit(v, "DstPort", &t.DstPort)
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Checksum", &t.Checksum)
}
func (t *Udpheader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Udpheader) Write(w io.Writer) (err error) {
	tmp57 := [2]byte{}
	binary.BigEndian.PutUint16(tmp57[:], uint16(t.SrcPort))
	if n, err := w.Write(tmp57[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.SrcPort: %w", err)
	}
	tmp58 := [2]byte{}
	binary.BigEndian.PutUint16(tmp58[:], uint16(t.DstPort))
	if n, err := w.Write(tmp58[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.DstPort: %w", err)
	}
	tmp59 := [2]byte{}
	binary.BigEndian.PutUint16(tmp59[:], uint16(t.Length))
	if n, err := w.Write(tmp59[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	tmp60 := [2]byte{}
	binary.BigEndian.PutUint16(tmp60[:], uint16(t.Checksum))
	if n, err := w.Write(tmp60[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Checksum: %w", err)
	}
	return nil
}
func (t *Udpheader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Udpheader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Udpheader) Read(r io.Reader) (err error) {
	tmpSrcPort := [2]byte{}
	n_SrcPort, err := io.ReadFull(r, tmpSrcPort[:])
	if err != nil {
		return fmt.Errorf("read SrcPort: expect 2 bytes but read %d bytes: %w", n_SrcPort, err)
	}
	t.SrcPort = uint16(binary.BigEndian.Uint16(tmpSrcPort[:]))
	tmpDstPort := [2]byte{}
	n_DstPort, err := io.ReadFull(r, tmpDstPort[:])
	if err != nil {
		return fmt.Errorf("read DstPort: expect 2 bytes but read %d bytes: %w", n_DstPort, err)
	}
	t.DstPort = uint16(binary.BigEndian.Uint16(tmpDstPort[:]))
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	tmpChecksum := [2]byte{}
	n_Checksum, err := io.ReadFull(r, tmpChecksum[:])
	if err != nil {
		return fmt.Errorf("read Checksum: expect 2 bytes but read %d bytes: %w", n_Checksum, err)
	}
	t.Checksum = uint16(binary.BigEndian.Uint16(tmpChecksum[:]))
	return nil
}

func (t *Udpheader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Udpheader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Udpheader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Ipv6ExtCommon) SetData(v []uint8) bool {
	t.Data = v
	return true
}
func (t *Ipv6ExtCommon) Visit(v VisitorKEYKW) {
	v.Visit(v, "Header", &t.Header)
	v.Visit(v, "Data", &t.Data)
}
func (t *Ipv6ExtCommon) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Ipv6ExtCommon) Write(w io.Writer) (err error) {
	if err := t.Header.Write(w); err != nil {
		return fmt.Errorf("encode Header: %w", err)
	}
	len_Data := int((6 + (t.Header.HdrExtLen * 8)))
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.Data))
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Ipv6ExtCommon) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Ipv6ExtCommon) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Ipv6ExtCommon) Read(r io.Reader) (err error) {
	if err := t.Header.Read(r); err != nil {
		return fmt.Errorf("read Header: %w", err)
	}
	len_Data := int((6 + (t.Header.HdrExtLen * 8)))
	if len_Data != 0 {
		tmpData := make([]byte, len_Data)
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
		}
		t.Data = tmpData[:]
	} else {
		t.Data = nil
	}
	return nil
}

func (t *Ipv6ExtCommon) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Ipv6ExtCommon) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Ipv6ExtCommon: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *MacAddress) Visit(v VisitorKEYKW) {
	v.Visit(v, "Oui", &t.Oui)
	v.Visit(v, "Nic", &t.Nic)
}
func (t *MacAddress) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *MacAddress) Write(w io.Writer) (err error) {
	if err := t.Oui.Write(w); err != nil {
		return fmt.Errorf("encode Oui: %w", err)
	}
	if n, err := w.Write(t.Nic[:]); err != nil || n != len(t.Nic) {
		return fmt.Errorf("encode Nic: %w", err)
	}
	return nil
}
func (t *MacAddress) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 6))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *MacAddress) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *MacAddress) Read(r io.Reader) (err error) {
	if err := t.Oui.Read(r); err != nil {
		return fmt.Errorf("read Oui: %w", err)
	}
	n_Nic, err := io.ReadFull(r, t.Nic[:])
	if err != nil {
		return fmt.Errorf("read Nic: expect %d bytes but read %d bytes: %w", 3, n_Nic, err)
	}
	return nil
}

func (t *MacAddress) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *MacAddress) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode MacAddress: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Sack) Visit(v VisitorKEYKW) {
	v.Visit(v, "Blocks", &t.Blocks)
}
func (t *Sack) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Sack) Write(w io.Writer) (err error) {
	for _, v := range t.Blocks {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Blocks: %w", err)
		}
	}
	return nil
}
func (t *Sack) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Sack) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Sack) Read(r io.Reader) (err error) {
	tmp_byte_scanner61_ := bufio.NewReaderSize(r, 1)
	old_r_Blocks := r
	r = tmp_byte_scanner61_
	for {
		_, err := tmp_byte_scanner61_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Blocks: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner61_.UnreadByte(); err != nil {
			return fmt.Errorf("read Blocks: unexpected unread error: %w", err)
		}
		var tmp62_ SackBlock
		if err := tmp62_.Read(r); err != nil {
			return fmt.Errorf("read Blocks: %w", err)
		}
		t.Blocks = append(t.Blocks, tmp62_)
	}
	r = old_r_Blocks
	return nil
}

func (t *Sack) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Sack) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Sack: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_65_t) isunion63_() {}
func (t *union_66_t) isunion63_() {}
func (t *union_67_t) isunion63_() {}
func (t *union_68_t) isunion63_() {}
func (t *union_69_t) isunion63_() {}
func (t *union_70_t) isunion63_() {}
func (t *union_71_t) isunion63_() {}
func (t *union_72_t) isunion63_() {}
func (t *Tcpoption) Data() *[]uint8 {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return nil
	} else if t.Kind == TcpoptionKind_WindowScale {
		return nil
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return nil
	} else if t.Kind == TcpoptionKind_Sack {
		return nil
	} else if t.Kind == TcpoptionKind_Timestamp {
		return nil
	} else if true {
		if _, ok := t.union63_.(*union_72_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union63_.(*union_72_t).Data)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetData(v []uint8) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return false
	} else if t.Kind == TcpoptionKind_WindowScale {
		return false
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return false
	} else if t.Kind == TcpoptionKind_Sack {
		return false
	} else if t.Kind == TcpoptionKind_Timestamp {
		return false
	} else if true {
		if _, ok := t.union63_.(*union_72_t); !ok {
			t.union63_ = &union_72_t{}
		}
		t.union63_.(*union_72_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *Tcpoption) Length() *uint8 {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		if _, ok := t.union63_.(*union_67_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union63_.(*union_67_t).Length)
		return &tmp
	} else if t.Kind == TcpoptionKind_WindowScale {
		if _, ok := t.union63_.(*union_68_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union63_.(*union_68_t).Length)
		return &tmp
	} else if t.Kind == TcpoptionKind_SackPermitted {
		if _, ok := t.union63_.(*union_69_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union63_.(*union_69_t).Length)
		return &tmp
	} else if t.Kind == TcpoptionKind_Sack {
		if _, ok := t.union63_.(*union_70_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union63_.(*union_70_t).Length)
		return &tmp
	} else if t.Kind == TcpoptionKind_Timestamp {
		if _, ok := t.union63_.(*union_71_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union63_.(*union_71_t).Length)
		return &tmp
	} else if true {
		if _, ok := t.union63_.(*union_72_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union63_.(*union_72_t).Length)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetLength(v uint8) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		if _, ok := t.union63_.(*union_67_t); !ok {
			t.union63_ = &union_67_t{}
		}
		t.union63_.(*union_67_t).Length = uint8(v)
		return true
	} else if t.Kind == TcpoptionKind_WindowScale {
		if _, ok := t.union63_.(*union_68_t); !ok {
			t.union63_ = &union_68_t{}
		}
		t.union63_.(*union_68_t).Length = uint8(v)
		return true
	} else if t.Kind == TcpoptionKind_SackPermitted {
		if _, ok := t.union63_.(*union_69_t); !ok {
			t.union63_ = &union_69_t{}
		}
		t.union63_.(*union_69_t).Length = uint8(v)
		return true
	} else if t.Kind == TcpoptionKind_Sack {
		if _, ok := t.union63_.(*union_70_t); !ok {
			t.union63_ = &union_70_t{}
		}
		t.union63_.(*union_70_t).Length = uint8(v)
		return true
	} else if t.Kind == TcpoptionKind_Timestamp {
		if _, ok := t.union63_.(*union_71_t); !ok {
			t.union63_ = &union_71_t{}
		}
		t.union63_.(*union_71_t).Length = uint8(v)
		return true
	} else if true {
		if _, ok := t.union63_.(*union_72_t); !ok {
			t.union63_ = &union_72_t{}
		}
		t.union63_.(*union_72_t).Length = uint8(v)
		return true
	}
	return false
}
func (t *Tcpoption) Mss() *uint16 {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		if _, ok := t.union63_.(*union_67_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union63_.(*union_67_t).Mss)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetMss(v uint16) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		if _, ok := t.union63_.(*union_67_t); !ok {
			t.union63_ = &union_67_t{}
		}
		t.union63_.(*union_67_t).Mss = uint16(v)
		return true
	}
	return false
}
func (t *Tcpoption) Sack() *Sack {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return nil
	} else if t.Kind == TcpoptionKind_WindowScale {
		return nil
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return nil
	} else if t.Kind == TcpoptionKind_Sack {
		if _, ok := t.union63_.(*union_70_t); !ok {
			return nil // not set
		}
		tmp := Sack(t.union63_.(*union_70_t).Sack)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetSack(v Sack) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return false
	} else if t.Kind == TcpoptionKind_WindowScale {
		return false
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return false
	} else if t.Kind == TcpoptionKind_Sack {
		if _, ok := t.union63_.(*union_70_t); !ok {
			t.union63_ = &union_70_t{}
		}
		t.union63_.(*union_70_t).Sack = Sack(v)
		return true
	}
	return false
}
func (t *Tcpoption) ShiftCount() *uint8 {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return nil
	} else if t.Kind == TcpoptionKind_WindowScale {
		if _, ok := t.union63_.(*union_68_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union63_.(*union_68_t).ShiftCount)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetShiftCount(v uint8) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return false
	} else if t.Kind == TcpoptionKind_WindowScale {
		if _, ok := t.union63_.(*union_68_t); !ok {
			t.union63_ = &union_68_t{}
		}
		t.union63_.(*union_68_t).ShiftCount = uint8(v)
		return true
	}
	return false
}
func (t *Tcpoption) Timestamp() *Timestamp {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return nil
	} else if t.Kind == TcpoptionKind_WindowScale {
		return nil
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return nil
	} else if t.Kind == TcpoptionKind_Sack {
		return nil
	} else if t.Kind == TcpoptionKind_Timestamp {
		if _, ok := t.union63_.(*union_71_t); !ok {
			return nil // not set
		}
		tmp := Timestamp(t.union63_.(*union_71_t).Timestamp)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetTimestamp(v Timestamp) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return false
	} else if t.Kind == TcpoptionKind_WindowScale {
		return false
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return false
	} else if t.Kind == TcpoptionKind_Sack {
		return false
	} else if t.Kind == TcpoptionKind_Timestamp {
		if _, ok := t.union63_.(*union_71_t); !ok {
			t.union63_ = &union_71_t{}
		}
		t.union63_.(*union_71_t).Timestamp = Timestamp(v)
		return true
	}
	return false
}
func (t *Tcpoption) Visit(v VisitorKEYKW) {
	v.Visit(v, "Kind", &t.Kind)
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "Length", (t.Length()))
	v.Visit(v, "Mss", (t.Mss()))
	v.Visit(v, "Sack", (t.Sack()))
	v.Visit(v, "ShiftCount", (t.ShiftCount()))
	v.Visit(v, "Timestamp", (t.Timestamp()))
}
func (t *Tcpoption) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Tcpoption) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Kind)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Kind: %w", err)
	}
	switch {
	case (t.Kind == TcpoptionKind_EndOfOptionsList):
	case (t.Kind == TcpoptionKind_Nop):
	case (t.Kind == TcpoptionKind_MaximumSegmentSize):
		if _, ok := t.union63_.(*union_67_t); !ok {
			return fmt.Errorf("encode t.union63_: union is not set to union_67_t")
		}
		if n, err := w.Write([]byte{byte(t.union63_.(*union_67_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union63_.(*union_67_t).Length: %w", err)
		}
		tmp73 := [2]byte{}
		binary.BigEndian.PutUint16(tmp73[:], uint16(t.union63_.(*union_67_t).Mss))
		if n, err := w.Write(tmp73[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union63_.(*union_67_t).Mss: %w", err)
		}
	case (t.Kind == TcpoptionKind_WindowScale):
		if _, ok := t.union63_.(*union_68_t); !ok {
			return fmt.Errorf("encode t.union63_: union is not set to union_68_t")
		}
		if n, err := w.Write([]byte{byte(t.union63_.(*union_68_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union63_.(*union_68_t).Length: %w", err)
		}
		if n, err := w.Write([]byte{byte(t.union63_.(*union_68_t).ShiftCount)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union63_.(*union_68_t).ShiftCount: %w", err)
		}
	case (t.Kind == TcpoptionKind_SackPermitted):
		if _, ok := t.union63_.(*union_69_t); !ok {
			return fmt.Errorf("encode t.union63_: union is not set to union_69_t")
		}
		if n, err := w.Write([]byte{byte(t.union63_.(*union_69_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union63_.(*union_69_t).Length: %w", err)
		}
	case (t.Kind == TcpoptionKind_Sack):
		if _, ok := t.union63_.(*union_70_t); !ok {
			return fmt.Errorf("encode t.union63_: union is not set to union_70_t")
		}
		if n, err := w.Write([]byte{byte(t.union63_.(*union_70_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union63_.(*union_70_t).Length: %w", err)
		}
		new_buf_74 := bytes.NewBuffer(nil)
		old_buf_74_w := w
		w = new_buf_74
		if err := t.union63_.(*union_70_t).Sack.Write(w); err != nil {
			return fmt.Errorf("encode Sack: %w", err)
		}
		if new_buf_74.Len() != int((t.union63_.(*union_70_t).Length - 2)) {
			return fmt.Errorf("encode Sack: expect %d bytes but got %d bytes", new_buf_74.Len(), int((t.union63_.(*union_70_t).Length - 2)))
		}
		_, err = new_buf_74.WriteTo(old_buf_74_w)
		if err != nil {
			return err
		}
		w = old_buf_74_w
	case (t.Kind == TcpoptionKind_Timestamp):
		if _, ok := t.union63_.(*union_71_t); !ok {
			return fmt.Errorf("encode t.union63_: union is not set to union_71_t")
		}
		if n, err := w.Write([]byte{byte(t.union63_.(*union_71_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union63_.(*union_71_t).Length: %w", err)
		}
		new_buf_75 := bytes.NewBuffer(nil)
		old_buf_75_w := w
		w = new_buf_75
		if err := t.union63_.(*union_71_t).Timestamp.Write(w); err != nil {
			return fmt.Errorf("encode Timestamp: %w", err)
		}
		if new_buf_75.Len() != int((t.union63_.(*union_71_t).Length - 2)) {
			return fmt.Errorf("encode Timestamp: expect %d bytes but got %d bytes", new_buf_75.Len(), int((t.union63_.(*union_71_t).Length - 2)))
		}
		_, err = new_buf_75.WriteTo(old_buf_75_w)
		if err != nil {
			return err
		}
		w = old_buf_75_w
	default:
		if _, ok := t.union63_.(*union_72_t); !ok {
			return fmt.Errorf("encode t.union63_: union is not set to union_72_t")
		}
		if n, err := w.Write([]byte{byte(t.union63_.(*union_72_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union63_.(*union_72_t).Length: %w", err)
		}
		len_Data := int((t.union63_.(*union_72_t).Length - 2))
		if len(t.union63_.(*union_72_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union63_.(*union_72_t).Data))
		}
		if n, err := w.Write(t.union63_.(*union_72_t).Data); err != nil || n != len(t.union63_.(*union_72_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *Tcpoption) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Tcpoption) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Tcpoption) Read(r io.Reader) (err error) {
	tmpKind := [1]byte{}
	n_Kind, err := io.ReadFull(r, tmpKind[:])
	if err != nil {
		return fmt.Errorf("read Kind: expect 1 byte but read %d bytes: %w", n_Kind, err)
	}
	t.Kind = TcpoptionKind(tmpKind[0])
	switch {
	case (t.Kind == TcpoptionKind_EndOfOptionsList):
	case (t.Kind == TcpoptionKind_Nop):
	case (t.Kind == TcpoptionKind_MaximumSegmentSize):
		t.union63_ = &union_67_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union63_.(*union_67_t).Length = uint8(tmpLength[0])
		tmpMss := [2]byte{}
		n_Mss, err := io.ReadFull(r, tmpMss[:])
		if err != nil {
			return fmt.Errorf("read Mss: expect 2 bytes but read %d bytes: %w", n_Mss, err)
		}
		t.union63_.(*union_67_t).Mss = uint16(binary.BigEndian.Uint16(tmpMss[:]))
	case (t.Kind == TcpoptionKind_WindowScale):
		t.union63_ = &union_68_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union63_.(*union_68_t).Length = uint8(tmpLength[0])
		tmpShiftCount := [1]byte{}
		n_ShiftCount, err := io.ReadFull(r, tmpShiftCount[:])
		if err != nil {
			return fmt.Errorf("read ShiftCount: expect 1 byte but read %d bytes: %w", n_ShiftCount, err)
		}
		t.union63_.(*union_68_t).ShiftCount = uint8(tmpShiftCount[0])
	case (t.Kind == TcpoptionKind_SackPermitted):
		t.union63_ = &union_69_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union63_.(*union_69_t).Length = uint8(tmpLength[0])
	case (t.Kind == TcpoptionKind_Sack):
		t.union63_ = &union_70_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union63_.(*union_70_t).Length = uint8(tmpLength[0])
		sub_byte_len_Sack := int64((t.union63_.(*union_70_t).Length - 2))
		sub_byte_r_Sack := io.LimitReader(r, int64(sub_byte_len_Sack))
		tmp_old_r_Sack_76 := r
		r = sub_byte_r_Sack
		if err := t.union63_.(*union_70_t).Sack.Read(r); err != nil {
			return fmt.Errorf("read Sack: %w", err)
		}
		if sub_byte_r_Sack.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Sack: expect %d bytes but got %d bytes", sub_byte_len_Sack, sub_byte_len_Sack-sub_byte_r_Sack.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Sack_76
	case (t.Kind == TcpoptionKind_Timestamp):
		t.union63_ = &union_71_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union63_.(*union_71_t).Length = uint8(tmpLength[0])
		sub_byte_len_Timestamp := int64((t.union63_.(*union_71_t).Length - 2))
		sub_byte_r_Timestamp := io.LimitReader(r, int64(sub_byte_len_Timestamp))
		tmp_old_r_Timestamp_77 := r
		r = sub_byte_r_Timestamp
		if err := t.union63_.(*union_71_t).Timestamp.Read(r); err != nil {
			return fmt.Errorf("read Timestamp: %w", err)
		}
		if sub_byte_r_Timestamp.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Timestamp: expect %d bytes but got %d bytes", sub_byte_len_Timestamp, sub_byte_len_Timestamp-sub_byte_r_Timestamp.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Timestamp_77
	default:
		t.union63_ = &union_72_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union63_.(*union_72_t).Length = uint8(tmpLength[0])
		len_Data := int((t.union63_.(*union_72_t).Length - 2))
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union63_.(*union_72_t).Data = tmpData[:]
		} else {
			t.union63_.(*union_72_t).Data = nil
		}
	}
	return nil
}

func (t *Tcpoption) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Tcpoption) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Tcpoption: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Tcpheader) DataOffset() uint8 {
	return ((t.flags78 & 0xf0) >> 4)
}
func (t *Tcpheader) SetDataOffset(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags78 = (t.flags78 & ^uint8(0xf0)) | ((v & 0xf) << 4)
	return true
}
func (t *Tcpheader) Reserved() uint8 {
	return ((t.flags78 & 0x0f) >> 0)
}
func (t *Tcpheader) SetReserved(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags78 = (t.flags78 & ^uint8(0xf)) | ((v & 0xf) << 0)
	return true
}
func (t *Tcpheader) Visit(v VisitorKEYKW) {
	v.Visit(v, "SrcPort", &t.SrcPort)
	v.Visit(v, "DstPort", &t.DstPort)
	v.Visit(v, "SeqNum", &t.SeqNum)
	v.Visit(v, "AckNum", &t.AckNum)
	v.Visit(v, "DataOffset", t.DataOffset())
	v.Visit(v, "Reserved", t.Reserved())
	v.Visit(v, "Flags", &t.Flags)
	v.Visit(v, "WindowSize", &t.WindowSize)
	v.Visit(v, "Checksum", &t.Checksum)
	v.Visit(v, "UrgentPointer", &t.UrgentPointer)
	v.Visit(v, "Options", &t.Options)
}
func (t *Tcpheader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Tcpheader) Write(w io.Writer) (err error) {
	tmp79 := [2]byte{}
	binary.BigEndian.PutUint16(tmp79[:], uint16(t.SrcPort))
	if n, err := w.Write(tmp79[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.SrcPort: %w", err)
	}
	tmp80 := [2]byte{}
	binary.BigEndian.PutUint16(tmp80[:], uint16(t.DstPort))
	if n, err := w.Write(tmp80[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.DstPort: %w", err)
	}
	tmp81 := [4]byte{}
	binary.BigEndian.PutUint32(tmp81[:], uint32(t.SeqNum))
	if n, err := w.Write(tmp81[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.SeqNum: %w", err)
	}
	tmp82 := [4]byte{}
	binary.BigEndian.PutUint32(tmp82[:], uint32(t.AckNum))
	if n, err := w.Write(tmp82[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.AckNum: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags78)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags78: %w", err)
	}
	if err := t.Flags.Write(w); err != nil {
		return fmt.Errorf("encode Flags: %w", err)
	}
	tmp83 := [2]byte{}
	binary.BigEndian.PutUint16(tmp83[:], uint16(t.WindowSize))
	if n, err := w.Write(tmp83[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.WindowSize: %w", err)
	}
	tmp84 := [2]byte{}
	binary.BigEndian.PutUint16(tmp84[:], uint16(t.Checksum))
	if n, err := w.Write(tmp84[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Checksum: %w", err)
	}
	tmp85 := [2]byte{}
	binary.BigEndian.PutUint16(tmp85[:], uint16(t.UrgentPointer))
	if n, err := w.Write(tmp85[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.UrgentPointer: %w", err)
	}
	new_buf_86 := bytes.NewBuffer(nil)
	old_buf_86_w := w
	w = new_buf_86
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	if new_buf_86.Len() != int((uint8((t.DataOffset() * 4)) - 20)) {
		return fmt.Errorf("encode Options: expect %d bytes but got %d bytes", new_buf_86.Len(), int((uint8((t.DataOffset() * 4)) - 20)))
	}
	_, err = new_buf_86.WriteTo(old_buf_86_w)
	if err != nil {
		return err
	}
	w = old_buf_86_w
	return nil
}
func (t *Tcpheader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 20))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Tcpheader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Tcpheader) Read(r io.Reader) (err error) {
	tmpSrcPort := [2]byte{}
	n_SrcPort, err := io.ReadFull(r, tmpSrcPort[:])
	if err != nil {
		return fmt.Errorf("read SrcPort: expect 2 bytes but read %d bytes: %w", n_SrcPort, err)
	}
	t.SrcPort = uint16(binary.BigEndian.Uint16(tmpSrcPort[:]))
	tmpDstPort := [2]byte{}
	n_DstPort, err := io.ReadFull(r, tmpDstPort[:])
	if err != nil {
		return fmt.Errorf("read DstPort: expect 2 bytes but read %d bytes: %w", n_DstPort, err)
	}
	t.DstPort = uint16(binary.BigEndian.Uint16(tmpDstPort[:]))
	tmpSeqNum := [4]byte{}
	n_SeqNum, err := io.ReadFull(r, tmpSeqNum[:])
	if err != nil {
		return fmt.Errorf("read SeqNum: expect 4 bytes but read %d bytes: %w", n_SeqNum, err)
	}
	t.SeqNum = uint32(binary.BigEndian.Uint32(tmpSeqNum[:]))
	tmpAckNum := [4]byte{}
	n_AckNum, err := io.ReadFull(r, tmpAckNum[:])
	if err != nil {
		return fmt.Errorf("read AckNum: expect 4 bytes but read %d bytes: %w", n_AckNum, err)
	}
	t.AckNum = uint32(binary.BigEndian.Uint32(tmpAckNum[:]))
	tmpflags78 := [1]byte{}
	n_flags78, err := io.ReadFull(r, tmpflags78[:])
	if err != nil {
		return fmt.Errorf("read flags78: expect 1 byte but read %d bytes: %w", n_flags78, err)
	}
	t.flags78 = uint8(tmpflags78[0])
	if err := t.Flags.Read(r); err != nil {
		return fmt.Errorf("read Flags: %w", err)
	}
	tmpWindowSize := [2]byte{}
	n_WindowSize, err := io.ReadFull(r, tmpWindowSize[:])
	if err != nil {
		return fmt.Errorf("read WindowSize: expect 2 bytes but read %d bytes: %w", n_WindowSize, err)
	}
	t.WindowSize = uint16(binary.BigEndian.Uint16(tmpWindowSize[:]))
	tmpChecksum := [2]byte{}
	n_Checksum, err := io.ReadFull(r, tmpChecksum[:])
	if err != nil {
		return fmt.Errorf("read Checksum: expect 2 bytes but read %d bytes: %w", n_Checksum, err)
	}
	t.Checksum = uint16(binary.BigEndian.Uint16(tmpChecksum[:]))
	tmpUrgentPointer := [2]byte{}
	n_UrgentPointer, err := io.ReadFull(r, tmpUrgentPointer[:])
	if err != nil {
		return fmt.Errorf("read UrgentPointer: expect 2 bytes but read %d bytes: %w", n_UrgentPointer, err)
	}
	t.UrgentPointer = uint16(binary.BigEndian.Uint16(tmpUrgentPointer[:]))
	sub_byte_len_Options := int64((uint8((t.DataOffset() * 4)) - 20))
	sub_byte_r_Options := io.LimitReader(r, int64(sub_byte_len_Options))
	tmp_old_r_Options_87 := r
	r = sub_byte_r_Options
	len_Options := int(r.(*io.LimitedReader).N)
	tmpOptions := make([]byte, len_Options)
	n_Options, err := io.ReadFull(r, tmpOptions[:])
	if err != nil {
		return fmt.Errorf("read Options: expect %d bytes but read %d bytes: %w", len_Options, n_Options, err)
	}
	range_tmp_Options := bytes.NewReader(tmpOptions[:])
	tmp_old_r_Options := r
	r = range_tmp_Options
	for range_tmp_Options.Len() > 0 {
		var tmp88_ Tcpoption
		if err := tmp88_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp88_)
	}
	r = tmp_old_r_Options
	if sub_byte_r_Options.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Options: expect %d bytes but got %d bytes", sub_byte_len_Options, sub_byte_len_Options-sub_byte_r_Options.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Options_87
	return nil
}

func (t *Tcpheader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Tcpheader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Tcpheader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Tcpsegment) Visit(v VisitorKEYKW) {
	v.Visit(v, "Hdr", &t.Hdr)
	v.Visit(v, "Payload", &t.Payload)
}
func (t *Tcpsegment) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Tcpsegment) Write(w io.Writer) (err error) {
	if err := t.Hdr.Write(w); err != nil {
		return fmt.Errorf("encode Hdr: %w", err)
	}
	if n, err := w.Write(t.Payload); err != nil || n != len(t.Payload) {
		return fmt.Errorf("encode Payload: %w", err)
	}
	return nil
}
func (t *Tcpsegment) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Tcpsegment) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Tcpsegment) Read(r io.Reader) (err error) {
	if err := t.Hdr.Read(r); err != nil {
		return fmt.Errorf("read Hdr: %w", err)
	}
	bytes_buf_Payload := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Payload, r); err != nil {
		return err
	}
	t.Payload = bytes_buf_Payload.Bytes()
	return nil
}

func (t *Tcpsegment) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Tcpsegment) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Tcpsegment: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_91_t) isunion89_() {}
func (t *union_92_t) isunion89_() {}
func (t *union_93_t) isunion89_() {}
func (t *union_94_t) isunion89_() {}
func (t *union_95_t) isunion89_() {}
func (t *union_96_t) isunion89_() {}
func (t *Ndpoption) Data() *[]uint8 {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_RedirectHeader {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_Mtu {
		return nil
	} else if true {
		if _, ok := t.union89_.(*union_96_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union89_.(*union_96_t).Data)
		return &tmp
	}
	return nil
}
func (t *Ndpoption) SetData(v []uint8) bool {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_RedirectHeader {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_Mtu {
		return false
	} else if true {
		if _, ok := t.union89_.(*union_96_t); !ok {
			t.union89_ = &union_96_t{}
		}
		t.union89_.(*union_96_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *Ndpoption) LinkLayerAddress() *[]uint8 {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		if _, ok := t.union89_.(*union_91_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union89_.(*union_91_t).LinkLayerAddress)
		return &tmp
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		if _, ok := t.union89_.(*union_92_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union89_.(*union_92_t).LinkLayerAddress)
		return &tmp
	}
	return nil
}
func (t *Ndpoption) SetLinkLayerAddress(v []uint8) bool {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		if _, ok := t.union89_.(*union_91_t); !ok {
			t.union89_ = &union_91_t{}
		}
		t.union89_.(*union_91_t).LinkLayerAddress = []uint8(v)
		return true
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		if _, ok := t.union89_.(*union_92_t); !ok {
			t.union89_ = &union_92_t{}
		}
		t.union89_.(*union_92_t).LinkLayerAddress = []uint8(v)
		return true
	}
	return false
}
func (t *Ndpoption) Mtu() *Mtu {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_RedirectHeader {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_Mtu {
		if _, ok := t.union89_.(*union_95_t); !ok {
			return nil // not set
		}
		tmp := Mtu(t.union89_.(*union_95_t).Mtu)
		return &tmp
	}
	return nil
}
func (t *Ndpoption) SetMtu(v Mtu) bool {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_RedirectHeader {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_Mtu {
		if _, ok := t.union89_.(*union_95_t); !ok {
			t.union89_ = &union_95_t{}
		}
		t.union89_.(*union_95_t).Mtu = Mtu(v)
		return true
	}
	return false
}
func (t *Ndpoption) PrefixInformation() *PrefixInformation {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		if _, ok := t.union89_.(*union_93_t); !ok {
			return nil // not set
		}
		tmp := PrefixInformation(t.union89_.(*union_93_t).PrefixInformation)
		return &tmp
	}
	return nil
}
func (t *Ndpoption) SetPrefixInformation(v PrefixInformation) bool {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		if _, ok := t.union89_.(*union_93_t); !ok {
			t.union89_ = &union_93_t{}
		}
		t.union89_.(*union_93_t).PrefixInformation = PrefixInformation(v)
		return true
	}
	return false
}
func (t *Ndpoption) RedirectHeader() *RedirectHeader {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_RedirectHeader {
		if _, ok := t.union89_.(*union_94_t); !ok {
			return nil // not set
		}
		tmp := RedirectHeader(t.union89_.(*union_94_t).RedirectHeader)
		return &tmp
	}
	return nil
}
func (t *Ndpoption) SetRedirectHeader(v RedirectHeader) bool {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_RedirectHeader {
		if _, ok := t.union89_.(*union_94_t); !ok {
			t.union89_ = &union_94_t{}
		}
		t.union89_.(*union_94_t).RedirectHeader = RedirectHeader(v)
		return true
	}
	return false
}
func (t *Ndpoption) Visit(v VisitorKEYKW) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "LinkLayerAddress", (t.LinkLayerAddress()))
	v.Visit(v, "Mtu", (t.Mtu()))
	v.Visit(v, "PrefixInformation", (t.PrefixInformation()))
	v.Visit(v, "RedirectHeader", (t.RedirectHeader()))
}
func (t *Ndpoption) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Ndpoption) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Length)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	switch {
	case (NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress):
		if _, ok := t.union89_.(*union_91_t); !ok {
			return fmt.Errorf("encode t.union89_: union is not set to union_91_t")
		}
		len_LinkLayerAddress := int(((t.Length * 8) - 2))
		if len(t.union89_.(*union_91_t).LinkLayerAddress) != len_LinkLayerAddress {
			return fmt.Errorf("encode LinkLayerAddress: expect %d bytes but got %d bytes", len_LinkLayerAddress, len(t.union89_.(*union_91_t).LinkLayerAddress))
		}
		if n, err := w.Write(t.union89_.(*union_91_t).LinkLayerAddress); err != nil || n != len(t.union89_.(*union_91_t).LinkLayerAddress) {
			return fmt.Errorf("encode LinkLayerAddress: %w", err)
		}
	case (NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress):
		if _, ok := t.union89_.(*union_92_t); !ok {
			return fmt.Errorf("encode t.union89_: union is not set to union_92_t")
		}
		len_LinkLayerAddress := int(((t.Length * 8) - 2))
		if len(t.union89_.(*union_92_t).LinkLayerAddress) != len_LinkLayerAddress {
			return fmt.Errorf("encode LinkLayerAddress: expect %d bytes but got %d bytes", len_LinkLayerAddress, len(t.union89_.(*union_92_t).LinkLayerAddress))
		}
		if n, err := w.Write(t.union89_.(*union_92_t).LinkLayerAddress); err != nil || n != len(t.union89_.(*union_92_t).LinkLayerAddress) {
			return fmt.Errorf("encode LinkLayerAddress: %w", err)
		}
	case (NdpoptionType(t.Type) == NdpoptionType_PrefixInformation):
		if _, ok := t.union89_.(*union_93_t); !ok {
			return fmt.Errorf("encode t.union89_: union is not set to union_93_t")
		}
		new_buf_97 := bytes.NewBuffer(nil)
		old_buf_97_w := w
		w = new_buf_97
		if err := t.union89_.(*union_93_t).PrefixInformation.Write(w); err != nil {
			return fmt.Errorf("encode PrefixInformation: %w", err)
		}
		if new_buf_97.Len() != int(((t.Length * 8) - 2)) {
			return fmt.Errorf("encode PrefixInformation: expect %d bytes but got %d bytes", new_buf_97.Len(), int(((t.Length * 8) - 2)))
		}
		_, err = new_buf_97.WriteTo(old_buf_97_w)
		if err != nil {
			return err
		}
		w = old_buf_97_w
	case (NdpoptionType(t.Type) == NdpoptionType_RedirectHeader):
		if _, ok := t.union89_.(*union_94_t); !ok {
			return fmt.Errorf("encode t.union89_: union is not set to union_94_t")
		}
		new_buf_98 := bytes.NewBuffer(nil)
		old_buf_98_w := w
		w = new_buf_98
		if err := t.union89_.(*union_94_t).RedirectHeader.Write(w); err != nil {
			return fmt.Errorf("encode RedirectHeader: %w", err)
		}
		if new_buf_98.Len() != int(((t.Length * 8) - 2)) {
			return fmt.Errorf("encode RedirectHeader: expect %d bytes but got %d bytes", new_buf_98.Len(), int(((t.Length * 8) - 2)))
		}
		_, err = new_buf_98.WriteTo(old_buf_98_w)
		if err != nil {
			return err
		}
		w = old_buf_98_w
	case (NdpoptionType(t.Type) == NdpoptionType_Mtu):
		if _, ok := t.union89_.(*union_95_t); !ok {
			return fmt.Errorf("encode t.union89_: union is not set to union_95_t")
		}
		new_buf_99 := bytes.NewBuffer(nil)
		old_buf_99_w := w
		w = new_buf_99
		if err := t.union89_.(*union_95_t).Mtu.Write(w); err != nil {
			return fmt.Errorf("encode Mtu: %w", err)
		}
		if new_buf_99.Len() != int(((t.Length * 8) - 2)) {
			return fmt.Errorf("encode Mtu: expect %d bytes but got %d bytes", new_buf_99.Len(), int(((t.Length * 8) - 2)))
		}
		_, err = new_buf_99.WriteTo(old_buf_99_w)
		if err != nil {
			return err
		}
		w = old_buf_99_w
	default:
		if _, ok := t.union89_.(*union_96_t); !ok {
			return fmt.Errorf("encode t.union89_: union is not set to union_96_t")
		}
		len_Data := int(((t.Length * 8) - 2))
		if len(t.union89_.(*union_96_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union89_.(*union_96_t).Data))
		}
		if n, err := w.Write(t.union89_.(*union_96_t).Data); err != nil || n != len(t.union89_.(*union_96_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *Ndpoption) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Ndpoption) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Ndpoption) Read(r io.Reader) (err error) {
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = NdpoptionType(tmpType[0])
	tmpLength := [1]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint8(tmpLength[0])
	switch {
	case (NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress):
		t.union89_ = &union_91_t{}
		len_LinkLayerAddress := int(((t.Length * 8) - 2))
		if len_LinkLayerAddress != 0 {
			tmpLinkLayerAddress := make([]byte, len_LinkLayerAddress)
			n_LinkLayerAddress, err := io.ReadFull(r, tmpLinkLayerAddress[:])
			if err != nil {
				return fmt.Errorf("read LinkLayerAddress: expect %d bytes but read %d bytes: %w", len_LinkLayerAddress, n_LinkLayerAddress, err)
			}
			t.union89_.(*union_91_t).LinkLayerAddress = tmpLinkLayerAddress[:]
		} else {
			t.union89_.(*union_91_t).LinkLayerAddress = nil
		}
	case (NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress):
		t.union89_ = &union_92_t{}
		len_LinkLayerAddress := int(((t.Length * 8) - 2))
		if len_LinkLayerAddress != 0 {
			tmpLinkLayerAddress := make([]byte, len_LinkLayerAddress)
			n_LinkLayerAddress, err := io.ReadFull(r, tmpLinkLayerAddress[:])
			if err != nil {
				return fmt.Errorf("read LinkLayerAddress: expect %d bytes but read %d bytes: %w", len_LinkLayerAddress, n_LinkLayerAddress, err)
			}
			t.union89_.(*union_92_t).LinkLayerAddress = tmpLinkLayerAddress[:]
		} else {
			t.union89_.(*union_92_t).LinkLayerAddress = nil
		}
	case (NdpoptionType(t.Type) == NdpoptionType_PrefixInformation):
		t.union89_ = &union_93_t{}
		sub_byte_len_PrefixInformation := int64(((t.Length * 8) - 2))
		sub_byte_r_PrefixInformation := io.LimitReader(r, int64(sub_byte_len_PrefixInformation))
		tmp_old_r_PrefixInformation_100 := r
		r = sub_byte_r_PrefixInformation
		if err := t.union89_.(*union_93_t).PrefixInformation.Read(r); err != nil {
			return fmt.Errorf("read PrefixInformation: %w", err)
		}
		if sub_byte_r_PrefixInformation.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read PrefixInformation: expect %d bytes but got %d bytes", sub_byte_len_PrefixInformation, sub_byte_len_PrefixInformation-sub_byte_r_PrefixInformation.(*io.LimitedReader).N)
		}
		r = tmp_old_r_PrefixInformation_100
	case (NdpoptionType(t.Type) == NdpoptionType_RedirectHeader):
		t.union89_ = &union_94_t{}
		sub_byte_len_RedirectHeader := int64(((t.Length * 8) - 2))
		sub_byte_r_RedirectHeader := io.LimitReader(r, int64(sub_byte_len_RedirectHeader))
		tmp_old_r_RedirectHeader_101 := r
		r = sub_byte_r_RedirectHeader
		if err := t.union89_.(*union_94_t).RedirectHeader.Read(r); err != nil {
			return fmt.Errorf("read RedirectHeader: %w", err)
		}
		if sub_byte_r_RedirectHeader.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read RedirectHeader: expect %d bytes but got %d bytes", sub_byte_len_RedirectHeader, sub_byte_len_RedirectHeader-sub_byte_r_RedirectHeader.(*io.LimitedReader).N)
		}
		r = tmp_old_r_RedirectHeader_101
	case (NdpoptionType(t.Type) == NdpoptionType_Mtu):
		t.union89_ = &union_95_t{}
		sub_byte_len_Mtu := int64(((t.Length * 8) - 2))
		sub_byte_r_Mtu := io.LimitReader(r, int64(sub_byte_len_Mtu))
		tmp_old_r_Mtu_102 := r
		r = sub_byte_r_Mtu
		if err := t.union89_.(*union_95_t).Mtu.Read(r); err != nil {
			return fmt.Errorf("read Mtu: %w", err)
		}
		if sub_byte_r_Mtu.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Mtu: expect %d bytes but got %d bytes", sub_byte_len_Mtu, sub_byte_len_Mtu-sub_byte_r_Mtu.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Mtu_102
	default:
		t.union89_ = &union_96_t{}
		len_Data := int(((t.Length * 8) - 2))
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union89_.(*union_96_t).Data = tmpData[:]
		} else {
			t.union89_.(*union_96_t).Data = nil
		}
	}
	return nil
}

func (t *Ndpoption) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Ndpoption) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Ndpoption: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NdprouterSolicitation) Visit(v VisitorKEYKW) {
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "Options", &t.Options)
}
func (t *NdprouterSolicitation) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *NdprouterSolicitation) Write(w io.Writer) (err error) {
	tmp103 := [4]byte{}
	binary.BigEndian.PutUint32(tmp103[:], uint32(t.Reserved))
	if n, err := w.Write(tmp103[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	return nil
}
func (t *NdprouterSolicitation) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NdprouterSolicitation) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NdprouterSolicitation) Read(r io.Reader) (err error) {
	tmpReserved := [4]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 4 bytes but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint32(binary.BigEndian.Uint32(tmpReserved[:]))
	tmp_byte_scanner104_ := bufio.NewReaderSize(r, 1)
	old_r_Options := r
	r = tmp_byte_scanner104_
	for {
		_, err := tmp_byte_scanner104_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Options: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner104_.UnreadByte(); err != nil {
			return fmt.Errorf("read Options: unexpected unread error: %w", err)
		}
		var tmp105_ Ndpoption
		if err := tmp105_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp105_)
	}
	r = old_r_Options
	return nil
}

func (t *NdprouterSolicitation) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NdprouterSolicitation) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NdprouterSolicitation: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NdprouterAdvertisement) ManagedAddrConfig() bool {
	return ((t.flags106 & 0x80) >> 7) == 1
}
func (t *NdprouterAdvertisement) SetManagedAddrConfig(v bool) {
	if v {
		t.flags106 |= uint8(0x80)
	} else {
		t.flags106 &= ^uint8(0x80)
	}
}
func (t *NdprouterAdvertisement) OtherStatefulConfig() bool {
	return ((t.flags106 & 0x40) >> 6) == 1
}
func (t *NdprouterAdvertisement) SetOtherStatefulConfig(v bool) {
	if v {
		t.flags106 |= uint8(0x40)
	} else {
		t.flags106 &= ^uint8(0x40)
	}
}
func (t *NdprouterAdvertisement) Reserved() uint8 {
	return ((t.flags106 & 0x3f) >> 0)
}
func (t *NdprouterAdvertisement) SetReserved(v uint8) bool {
	if v > 63 {
		return false
	}
	t.flags106 = (t.flags106 & ^uint8(0x3f)) | ((v & 0x3f) << 0)
	return true
}
func (t *NdprouterAdvertisement) Visit(v VisitorKEYKW) {
	v.Visit(v, "CurHopLimit", &t.CurHopLimit)
	v.Visit(v, "ManagedAddrConfig", (func() uint8 {
		if t.ManagedAddrConfig() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "OtherStatefulConfig", (func() uint8 {
		if t.OtherStatefulConfig() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved", t.Reserved())
	v.Visit(v, "RouterLifetime", &t.RouterLifetime)
	v.Visit(v, "ReachableTime", &t.ReachableTime)
	v.Visit(v, "RetransTimer", &t.RetransTimer)
	v.Visit(v, "Options", &t.Options)
}
func (t *NdprouterAdvertisement) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *NdprouterAdvertisement) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.CurHopLimit)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.CurHopLimit: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags106)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags106: %w", err)
	}
	tmp107 := [2]byte{}
	binary.BigEndian.PutUint16(tmp107[:], uint16(t.RouterLifetime))
	if n, err := w.Write(tmp107[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.RouterLifetime: %w", err)
	}
	tmp108 := [4]byte{}
	binary.BigEndian.PutUint32(tmp108[:], uint32(t.ReachableTime))
	if n, err := w.Write(tmp108[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.ReachableTime: %w", err)
	}
	tmp109 := [4]byte{}
	binary.BigEndian.PutUint32(tmp109[:], uint32(t.RetransTimer))
	if n, err := w.Write(tmp109[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.RetransTimer: %w", err)
	}
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	return nil
}
func (t *NdprouterAdvertisement) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 12))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NdprouterAdvertisement) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NdprouterAdvertisement) Read(r io.Reader) (err error) {
	tmpCurHopLimit := [1]byte{}
	n_CurHopLimit, err := io.ReadFull(r, tmpCurHopLimit[:])
	if err != nil {
		return fmt.Errorf("read CurHopLimit: expect 1 byte but read %d bytes: %w", n_CurHopLimit, err)
	}
	t.CurHopLimit = uint8(tmpCurHopLimit[0])
	tmpflags106 := [1]byte{}
	n_flags106, err := io.ReadFull(r, tmpflags106[:])
	if err != nil {
		return fmt.Errorf("read flags106: expect 1 byte but read %d bytes: %w", n_flags106, err)
	}
	t.flags106 = uint8(tmpflags106[0])
	tmpRouterLifetime := [2]byte{}
	n_RouterLifetime, err := io.ReadFull(r, tmpRouterLifetime[:])
	if err != nil {
		return fmt.Errorf("read RouterLifetime: expect 2 bytes but read %d bytes: %w", n_RouterLifetime, err)
	}
	t.RouterLifetime = uint16(binary.BigEndian.Uint16(tmpRouterLifetime[:]))
	tmpReachableTime := [4]byte{}
	n_ReachableTime, err := io.ReadFull(r, tmpReachableTime[:])
	if err != nil {
		return fmt.Errorf("read ReachableTime: expect 4 bytes but read %d bytes: %w", n_ReachableTime, err)
	}
	t.ReachableTime = uint32(binary.BigEndian.Uint32(tmpReachableTime[:]))
	tmpRetransTimer := [4]byte{}
	n_RetransTimer, err := io.ReadFull(r, tmpRetransTimer[:])
	if err != nil {
		return fmt.Errorf("read RetransTimer: expect 4 bytes but read %d bytes: %w", n_RetransTimer, err)
	}
	t.RetransTimer = uint32(binary.BigEndian.Uint32(tmpRetransTimer[:]))
	tmp_byte_scanner110_ := bufio.NewReaderSize(r, 1)
	old_r_Options := r
	r = tmp_byte_scanner110_
	for {
		_, err := tmp_byte_scanner110_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Options: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner110_.UnreadByte(); err != nil {
			return fmt.Errorf("read Options: unexpected unread error: %w", err)
		}
		var tmp111_ Ndpoption
		if err := tmp111_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp111_)
	}
	r = old_r_Options
	return nil
}

func (t *NdprouterAdvertisement) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NdprouterAdvertisement) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NdprouterAdvertisement: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NdpneighborSolicitation) Visit(v VisitorKEYKW) {
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "TargetAddr", &t.TargetAddr)
	v.Visit(v, "Options", &t.Options)
}
func (t *NdpneighborSolicitation) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *NdpneighborSolicitation) Write(w io.Writer) (err error) {
	tmp112 := [4]byte{}
	binary.BigEndian.PutUint32(tmp112[:], uint32(t.Reserved))
	if n, err := w.Write(tmp112[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	if n, err := w.Write(t.TargetAddr[:]); err != nil || n != len(t.TargetAddr) {
		return fmt.Errorf("encode TargetAddr: %w", err)
	}
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	return nil
}
func (t *NdpneighborSolicitation) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 20))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NdpneighborSolicitation) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NdpneighborSolicitation) Read(r io.Reader) (err error) {
	tmpReserved := [4]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 4 bytes but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint32(binary.BigEndian.Uint32(tmpReserved[:]))
	n_TargetAddr, err := io.ReadFull(r, t.TargetAddr[:])
	if err != nil {
		return fmt.Errorf("read TargetAddr: expect %d bytes but read %d bytes: %w", 16, n_TargetAddr, err)
	}
	tmp_byte_scanner113_ := bufio.NewReaderSize(r, 1)
	old_r_Options := r
	r = tmp_byte_scanner113_
	for {
		_, err := tmp_byte_scanner113_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Options: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner113_.UnreadByte(); err != nil {
			return fmt.Errorf("read Options: unexpected unread error: %w", err)
		}
		var tmp114_ Ndpoption
		if err := tmp114_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp114_)
	}
	r = old_r_Options
	return nil
}

func (t *NdpneighborSolicitation) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NdpneighborSolicitation) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NdpneighborSolicitation: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NdpneighborAdvertisement) Router() bool {
	return ((t.flags115 & 0x80000000) >> 31) == 1
}
func (t *NdpneighborAdvertisement) SetRouter(v bool) {
	if v {
		t.flags115 |= uint32(0x80000000)
	} else {
		t.flags115 &= ^uint32(0x80000000)
	}
}
func (t *NdpneighborAdvertisement) Solicited() bool {
	return ((t.flags115 & 0x40000000) >> 30) == 1
}
func (t *NdpneighborAdvertisement) SetSolicited(v bool) {
	if v {
		t.flags115 |= uint32(0x40000000)
	} else {
		t.flags115 &= ^uint32(0x40000000)
	}
}
func (t *NdpneighborAdvertisement) Override() bool {
	return ((t.flags115 & 0x20000000) >> 29) == 1
}
func (t *NdpneighborAdvertisement) SetOverride(v bool) {
	if v {
		t.flags115 |= uint32(0x20000000)
	} else {
		t.flags115 &= ^uint32(0x20000000)
	}
}
func (t *NdpneighborAdvertisement) Flags() uint32 {
	return ((t.flags115 & 0x1fffffff) >> 0)
}
func (t *NdpneighborAdvertisement) SetFlags(v uint32) bool {
	if v > 536870911 {
		return false
	}
	t.flags115 = (t.flags115 & ^uint32(0x1fffffff)) | ((v & 0x1fffffff) << 0)
	return true
}
func (t *NdpneighborAdvertisement) Visit(v VisitorKEYKW) {
	v.Visit(v, "Router", (func() uint32 {
		if t.Router() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Solicited", (func() uint32 {
		if t.Solicited() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Override", (func() uint32 {
		if t.Override() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Flags", t.Flags())
	v.Visit(v, "TargetAddr", &t.TargetAddr)
	v.Visit(v, "Options", &t.Options)
}
func (t *NdpneighborAdvertisement) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *NdpneighborAdvertisement) Write(w io.Writer) (err error) {
	tmp116 := [4]byte{}
	binary.BigEndian.PutUint32(tmp116[:], uint32(t.flags115))
	if n, err := w.Write(tmp116[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.flags115: %w", err)
	}
	if n, err := w.Write(t.TargetAddr[:]); err != nil || n != len(t.TargetAddr) {
		return fmt.Errorf("encode TargetAddr: %w", err)
	}
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	return nil
}
func (t *NdpneighborAdvertisement) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 20))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NdpneighborAdvertisement) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NdpneighborAdvertisement) Read(r io.Reader) (err error) {
	tmpflags115 := [4]byte{}
	n_flags115, err := io.ReadFull(r, tmpflags115[:])
	if err != nil {
		return fmt.Errorf("read flags115: expect 4 bytes but read %d bytes: %w", n_flags115, err)
	}
	t.flags115 = uint32(binary.BigEndian.Uint32(tmpflags115[:]))
	n_TargetAddr, err := io.ReadFull(r, t.TargetAddr[:])
	if err != nil {
		return fmt.Errorf("read TargetAddr: expect %d bytes but read %d bytes: %w", 16, n_TargetAddr, err)
	}
	tmp_byte_scanner117_ := bufio.NewReaderSize(r, 1)
	old_r_Options := r
	r = tmp_byte_scanner117_
	for {
		_, err := tmp_byte_scanner117_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Options: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner117_.UnreadByte(); err != nil {
			return fmt.Errorf("read Options: unexpected unread error: %w", err)
		}
		var tmp118_ Ndpoption
		if err := tmp118_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp118_)
	}
	r = old_r_Options
	return nil
}

func (t *NdpneighborAdvertisement) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NdpneighborAdvertisement) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NdpneighborAdvertisement: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NdpredirectMessage) Visit(v VisitorKEYKW) {
	v.Visit(v, "TargetAddr", &t.TargetAddr)
	v.Visit(v, "DestAddr", &t.DestAddr)
	v.Visit(v, "Options", &t.Options)
}
func (t *NdpredirectMessage) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *NdpredirectMessage) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.TargetAddr[:]); err != nil || n != len(t.TargetAddr) {
		return fmt.Errorf("encode TargetAddr: %w", err)
	}
	if n, err := w.Write(t.DestAddr[:]); err != nil || n != len(t.DestAddr) {
		return fmt.Errorf("encode DestAddr: %w", err)
	}
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	return nil
}
func (t *NdpredirectMessage) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 32))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NdpredirectMessage) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NdpredirectMessage) Read(r io.Reader) (err error) {
	n_TargetAddr, err := io.ReadFull(r, t.TargetAddr[:])
	if err != nil {
		return fmt.Errorf("read TargetAddr: expect %d bytes but read %d bytes: %w", 16, n_TargetAddr, err)
	}
	n_DestAddr, err := io.ReadFull(r, t.DestAddr[:])
	if err != nil {
		return fmt.Errorf("read DestAddr: expect %d bytes but read %d bytes: %w", 16, n_DestAddr, err)
	}
	tmp_byte_scanner119_ := bufio.NewReaderSize(r, 1)
	old_r_Options := r
	r = tmp_byte_scanner119_
	for {
		_, err := tmp_byte_scanner119_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Options: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner119_.UnreadByte(); err != nil {
			return fmt.Errorf("read Options: unexpected unread error: %w", err)
		}
		var tmp120_ Ndpoption
		if err := tmp120_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp120_)
	}
	r = old_r_Options
	return nil
}

func (t *NdpredirectMessage) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NdpredirectMessage) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NdpredirectMessage: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *V2MulticastListernerReport) SetRecords(v []MulticastAddressRecord) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.NumberOfRecords = uint16(len(v))
	t.Records = v
	return true
}
func (t *V2MulticastListernerReport) Visit(v VisitorKEYKW) {
	v.Visit(v, "Reserved1", &t.Reserved1)
	v.Visit(v, "NumberOfRecords", &t.NumberOfRecords)
	v.Visit(v, "Records", &t.Records)
}
func (t *V2MulticastListernerReport) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *V2MulticastListernerReport) Write(w io.Writer) (err error) {
	tmp121 := [2]byte{}
	binary.BigEndian.PutUint16(tmp121[:], uint16(t.Reserved1))
	if n, err := w.Write(tmp121[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Reserved1: %w", err)
	}
	tmp122 := [2]byte{}
	binary.BigEndian.PutUint16(tmp122[:], uint16(t.NumberOfRecords))
	if n, err := w.Write(tmp122[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.NumberOfRecords: %w", err)
	}
	len_Records := int(t.NumberOfRecords)
	if len(t.Records) != len_Records {
		return fmt.Errorf("encode Records: expect %d but got %d for length", len_Records, len(t.Records))
	}
	for _, v := range t.Records {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Records: %w", err)
		}
	}
	return nil
}
func (t *V2MulticastListernerReport) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *V2MulticastListernerReport) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *V2MulticastListernerReport) Read(r io.Reader) (err error) {
	tmpReserved1 := [2]byte{}
	n_Reserved1, err := io.ReadFull(r, tmpReserved1[:])
	if err != nil {
		return fmt.Errorf("read Reserved1: expect 2 bytes but read %d bytes: %w", n_Reserved1, err)
	}
	t.Reserved1 = uint16(binary.BigEndian.Uint16(tmpReserved1[:]))
	tmpNumberOfRecords := [2]byte{}
	n_NumberOfRecords, err := io.ReadFull(r, tmpNumberOfRecords[:])
	if err != nil {
		return fmt.Errorf("read NumberOfRecords: expect 2 bytes but read %d bytes: %w", n_NumberOfRecords, err)
	}
	t.NumberOfRecords = uint16(binary.BigEndian.Uint16(tmpNumberOfRecords[:]))
	len_Records := int(t.NumberOfRecords)
	for i_123 := 0; i_123 < len_Records; i_123++ {
		var tmp124_ MulticastAddressRecord
		if err := tmp124_.Read(r); err != nil {
			return fmt.Errorf("read Records: %w", err)
		}
		t.Records = append(t.Records, tmp124_)
	}
	return nil
}

func (t *V2MulticastListernerReport) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *V2MulticastListernerReport) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode V2MulticastListernerReport: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Udpdatagram) SetData(v []uint8) bool {
	t.Data = v
	return true
}
func (t *Udpdatagram) Visit(v VisitorKEYKW) {
	v.Visit(v, "Header", &t.Header)
	v.Visit(v, "Data", &t.Data)
}
func (t *Udpdatagram) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Udpdatagram) Write(w io.Writer) (err error) {
	if err := t.Header.Write(w); err != nil {
		return fmt.Errorf("encode Header: %w", err)
	}
	len_Data := int((t.Header.Length - 8))
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.Data))
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Udpdatagram) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Udpdatagram) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Udpdatagram) Read(r io.Reader) (err error) {
	if err := t.Header.Read(r); err != nil {
		return fmt.Errorf("read Header: %w", err)
	}
	len_Data := int((t.Header.Length - 8))
	if len_Data != 0 {
		tmpData := make([]byte, len_Data)
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
		}
		t.Data = tmpData[:]
	} else {
		t.Data = nil
	}
	return nil
}

func (t *Udpdatagram) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Udpdatagram) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Udpdatagram: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SegmentRouting) Reserved1() uint8 {
	return ((t.flags125 & 0xc0) >> 6)
}
func (t *SegmentRouting) SetReserved1(v uint8) bool {
	if v > 3 {
		return false
	}
	t.flags125 = (t.flags125 & ^uint8(0xc0)) | ((v & 0x3) << 6)
	return true
}
func (t *SegmentRouting) Oam() bool {
	return ((t.flags125 & 0x20) >> 5) == 1
}
func (t *SegmentRouting) SetOam(v bool) {
	if v {
		t.flags125 |= uint8(0x20)
	} else {
		t.flags125 &= ^uint8(0x20)
	}
}
func (t *SegmentRouting) Reserved2() uint8 {
	return ((t.flags125 & 0x1f) >> 0)
}
func (t *SegmentRouting) SetReserved2(v uint8) bool {
	if v > 31 {
		return false
	}
	t.flags125 = (t.flags125 & ^uint8(0x1f)) | ((v & 0x1f) << 0)
	return true
}
func (t *SegmentRouting) SetSegmentList(v [][16]uint8) bool {
	t.SegmentList = v
	return true
}
func (t *SegmentRouting) Visit(v VisitorKEYKW) {
	v.Visit(v, "Header", &t.Header)
	v.Visit(v, "RoutingType", &t.RoutingType)
	v.Visit(v, "SegmentsLeft", &t.SegmentsLeft)
	v.Visit(v, "LastEntry", &t.LastEntry)
	v.Visit(v, "Reserved1", t.Reserved1())
	v.Visit(v, "Oam", (func() uint8 {
		if t.Oam() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved2", t.Reserved2())
	v.Visit(v, "Tag", &t.Tag)
	v.Visit(v, "SegmentList", &t.SegmentList)
	v.Visit(v, "Options", &t.Options)
}
func (t *SegmentRouting) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *SegmentRouting) Write(w io.Writer) (err error) {
	if err := t.Header.Write(w); err != nil {
		return fmt.Errorf("encode Header: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.RoutingType)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.RoutingType: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.SegmentsLeft)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.SegmentsLeft: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.LastEntry)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.LastEntry: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags125)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags125: %w", err)
	}
	tmp126 := [2]byte{}
	binary.BigEndian.PutUint16(tmp126[:], uint16(t.Tag))
	if n, err := w.Write(tmp126[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Tag: %w", err)
	}
	len_SegmentList := int((t.LastEntry + 1))
	if len(t.SegmentList) != len_SegmentList {
		return fmt.Errorf("encode SegmentList: expect %d but got %d for length", len_SegmentList, len(t.SegmentList))
	}
	for _, v := range t.SegmentList {
		if n, err := w.Write(v[:]); err != nil || n != len(v) {
			return fmt.Errorf("encode SegmentList: %w", err)
		}
	}
	RemainingInByte := ((uint16(t.Header.HdrExtLen) * 8) - ((uint16(t.LastEntry) + 1) * 16))
	new_buf_127 := bytes.NewBuffer(nil)
	old_buf_127_w := w
	w = new_buf_127
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	if new_buf_127.Len() != int(RemainingInByte) {
		return fmt.Errorf("encode Options: expect %d bytes but got %d bytes", new_buf_127.Len(), int(RemainingInByte))
	}
	_, err = new_buf_127.WriteTo(old_buf_127_w)
	if err != nil {
		return err
	}
	w = old_buf_127_w
	return nil
}
func (t *SegmentRouting) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SegmentRouting) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SegmentRouting) Read(r io.Reader) (err error) {
	if err := t.Header.Read(r); err != nil {
		return fmt.Errorf("read Header: %w", err)
	}
	tmpRoutingType := [1]byte{}
	n_RoutingType, err := io.ReadFull(r, tmpRoutingType[:])
	if err != nil {
		return fmt.Errorf("read RoutingType: expect 1 byte but read %d bytes: %w", n_RoutingType, err)
	}
	t.RoutingType = uint8(tmpRoutingType[0])
	tmpSegmentsLeft := [1]byte{}
	n_SegmentsLeft, err := io.ReadFull(r, tmpSegmentsLeft[:])
	if err != nil {
		return fmt.Errorf("read SegmentsLeft: expect 1 byte but read %d bytes: %w", n_SegmentsLeft, err)
	}
	t.SegmentsLeft = uint8(tmpSegmentsLeft[0])
	tmpLastEntry := [1]byte{}
	n_LastEntry, err := io.ReadFull(r, tmpLastEntry[:])
	if err != nil {
		return fmt.Errorf("read LastEntry: expect 1 byte but read %d bytes: %w", n_LastEntry, err)
	}
	t.LastEntry = uint8(tmpLastEntry[0])
	tmpflags125 := [1]byte{}
	n_flags125, err := io.ReadFull(r, tmpflags125[:])
	if err != nil {
		return fmt.Errorf("read flags125: expect 1 byte but read %d bytes: %w", n_flags125, err)
	}
	t.flags125 = uint8(tmpflags125[0])
	tmpTag := [2]byte{}
	n_Tag, err := io.ReadFull(r, tmpTag[:])
	if err != nil {
		return fmt.Errorf("read Tag: expect 2 bytes but read %d bytes: %w", n_Tag, err)
	}
	t.Tag = uint16(binary.BigEndian.Uint16(tmpTag[:]))
	len_SegmentList := int((t.LastEntry + 1))
	for i_128 := 0; i_128 < len_SegmentList; i_128++ {
		var tmp129_ [16]uint8
		n_SegmentList, err := io.ReadFull(r, tmp129_[:])
		if err != nil {
			return fmt.Errorf("read SegmentList: expect %d bytes but read %d bytes: %w", 16, n_SegmentList, err)
		}
		t.SegmentList = append(t.SegmentList, tmp129_)
	}
	RemainingInByte := ((uint16(t.Header.HdrExtLen) * 8) - ((uint16(t.LastEntry) + 1) * 16))
	sub_byte_len_Options := int64(RemainingInByte)
	sub_byte_r_Options := io.LimitReader(r, int64(sub_byte_len_Options))
	tmp_old_r_Options_130 := r
	r = sub_byte_r_Options
	len_Options := int(r.(*io.LimitedReader).N)
	tmpOptions := make([]byte, len_Options)
	n_Options, err := io.ReadFull(r, tmpOptions[:])
	if err != nil {
		return fmt.Errorf("read Options: expect %d bytes but read %d bytes: %w", len_Options, n_Options, err)
	}
	range_tmp_Options := bytes.NewReader(tmpOptions[:])
	tmp_old_r_Options := r
	r = range_tmp_Options
	for range_tmp_Options.Len() > 0 {
		var tmp131_ SegmentRoutingTlv
		if err := tmp131_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp131_)
	}
	r = tmp_old_r_Options
	if sub_byte_r_Options.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Options: expect %d bytes but got %d bytes", sub_byte_len_Options, sub_byte_len_Options-sub_byte_r_Options.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Options_130
	return nil
}

func (t *SegmentRouting) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SegmentRouting) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SegmentRouting: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_134_t) isunion132_() {}
func (t *union_135_t) isunion132_() {}
func (t *union_136_t) isunion132_() {}
func (t *union_137_t) isunion132_() {}
func (t *union_138_t) isunion132_() {}
func (t *union_139_t) isunion132_() {}
func (t *union_140_t) isunion132_() {}
func (t *union_141_t) isunion132_() {}
func (t *union_142_t) isunion132_() {}
func (t *union_143_t) isunion132_() {}
func (t *union_144_t) isunion132_() {}
func (t *union_145_t) isunion132_() {}
func (t *union_146_t) isunion132_() {}
func (t *union_147_t) isunion132_() {}
func (t *Icmpv6Packet) Data() *[]uint8 {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_V2MulticastListenerReport {
		return nil
	} else if true {
		if _, ok := t.union132_.(*union_147_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union132_.(*union_147_t).Data)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetData(v []uint8) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_V2MulticastListenerReport {
		return false
	} else if true {
		if _, ok := t.union132_.(*union_147_t); !ok {
			t.union132_ = &union_147_t{}
		}
		t.union132_.(*union_147_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) DestinationUnreachable() *IcmpdestinationUnreachable {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		if _, ok := t.union132_.(*union_139_t); !ok {
			return nil // not set
		}
		tmp := IcmpdestinationUnreachable(t.union132_.(*union_139_t).DestinationUnreachable)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetDestinationUnreachable(v IcmpdestinationUnreachable) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		if _, ok := t.union132_.(*union_139_t); !ok {
			t.union132_ = &union_139_t{}
		}
		t.union132_.(*union_139_t).DestinationUnreachable = IcmpdestinationUnreachable(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) EchoReply() *Icmpecho {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		if _, ok := t.union132_.(*union_135_t); !ok {
			return nil // not set
		}
		tmp := Icmpecho(t.union132_.(*union_135_t).EchoReply)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetEchoReply(v Icmpecho) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		if _, ok := t.union132_.(*union_135_t); !ok {
			t.union132_ = &union_135_t{}
		}
		t.union132_.(*union_135_t).EchoReply = Icmpecho(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) EchoRequest() *Icmpecho {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		if _, ok := t.union132_.(*union_134_t); !ok {
			return nil // not set
		}
		tmp := Icmpecho(t.union132_.(*union_134_t).EchoRequest)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetEchoRequest(v Icmpecho) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		if _, ok := t.union132_.(*union_134_t); !ok {
			t.union132_ = &union_134_t{}
		}
		t.union132_.(*union_134_t).EchoRequest = Icmpecho(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) MulticastListenerQuery() *MulticastListenerQuery {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery {
		if _, ok := t.union132_.(*union_145_t); !ok {
			return nil // not set
		}
		tmp := MulticastListenerQuery(t.union132_.(*union_145_t).MulticastListenerQuery)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetMulticastListenerQuery(v MulticastListenerQuery) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery {
		if _, ok := t.union132_.(*union_145_t); !ok {
			t.union132_ = &union_145_t{}
		}
		t.union132_.(*union_145_t).MulticastListenerQuery = MulticastListenerQuery(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) NeighborAdvertisement() *NdpneighborAdvertisement {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		if _, ok := t.union132_.(*union_143_t); !ok {
			return nil // not set
		}
		tmp := NdpneighborAdvertisement(t.union132_.(*union_143_t).NeighborAdvertisement)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetNeighborAdvertisement(v NdpneighborAdvertisement) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		if _, ok := t.union132_.(*union_143_t); !ok {
			t.union132_ = &union_143_t{}
		}
		t.union132_.(*union_143_t).NeighborAdvertisement = NdpneighborAdvertisement(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) NeighborSolicitation() *NdpneighborSolicitation {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		if _, ok := t.union132_.(*union_142_t); !ok {
			return nil // not set
		}
		tmp := NdpneighborSolicitation(t.union132_.(*union_142_t).NeighborSolicitation)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetNeighborSolicitation(v NdpneighborSolicitation) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		if _, ok := t.union132_.(*union_142_t); !ok {
			t.union132_ = &union_142_t{}
		}
		t.union132_.(*union_142_t).NeighborSolicitation = NdpneighborSolicitation(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) PacketTooBig() *IcmppacketTooBig {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		if _, ok := t.union132_.(*union_137_t); !ok {
			return nil // not set
		}
		tmp := IcmppacketTooBig(t.union132_.(*union_137_t).PacketTooBig)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetPacketTooBig(v IcmppacketTooBig) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		if _, ok := t.union132_.(*union_137_t); !ok {
			t.union132_ = &union_137_t{}
		}
		t.union132_.(*union_137_t).PacketTooBig = IcmppacketTooBig(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) ParameterProblem() *Icmpv6ParameterProblem {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		if _, ok := t.union132_.(*union_138_t); !ok {
			return nil // not set
		}
		tmp := Icmpv6ParameterProblem(t.union132_.(*union_138_t).ParameterProblem)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetParameterProblem(v Icmpv6ParameterProblem) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		if _, ok := t.union132_.(*union_138_t); !ok {
			t.union132_ = &union_138_t{}
		}
		t.union132_.(*union_138_t).ParameterProblem = Icmpv6ParameterProblem(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) RedirectMessage() *NdpredirectMessage {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		if _, ok := t.union132_.(*union_144_t); !ok {
			return nil // not set
		}
		tmp := NdpredirectMessage(t.union132_.(*union_144_t).RedirectMessage)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetRedirectMessage(v NdpredirectMessage) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		if _, ok := t.union132_.(*union_144_t); !ok {
			t.union132_ = &union_144_t{}
		}
		t.union132_.(*union_144_t).RedirectMessage = NdpredirectMessage(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) RouterAdvertisement() *NdprouterAdvertisement {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		if _, ok := t.union132_.(*union_141_t); !ok {
			return nil // not set
		}
		tmp := NdprouterAdvertisement(t.union132_.(*union_141_t).RouterAdvertisement)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetRouterAdvertisement(v NdprouterAdvertisement) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		if _, ok := t.union132_.(*union_141_t); !ok {
			t.union132_ = &union_141_t{}
		}
		t.union132_.(*union_141_t).RouterAdvertisement = NdprouterAdvertisement(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) RouterSolicitation() *NdprouterSolicitation {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		if _, ok := t.union132_.(*union_140_t); !ok {
			return nil // not set
		}
		tmp := NdprouterSolicitation(t.union132_.(*union_140_t).RouterSolicitation)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetRouterSolicitation(v NdprouterSolicitation) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		if _, ok := t.union132_.(*union_140_t); !ok {
			t.union132_ = &union_140_t{}
		}
		t.union132_.(*union_140_t).RouterSolicitation = NdprouterSolicitation(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) TimeExceeded() *Icmpv6ParameterProblem {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		if _, ok := t.union132_.(*union_136_t); !ok {
			return nil // not set
		}
		tmp := Icmpv6ParameterProblem(t.union132_.(*union_136_t).TimeExceeded)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetTimeExceeded(v Icmpv6ParameterProblem) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		if _, ok := t.union132_.(*union_136_t); !ok {
			t.union132_ = &union_136_t{}
		}
		t.union132_.(*union_136_t).TimeExceeded = Icmpv6ParameterProblem(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) V2MulticastListenerReport() *V2MulticastListernerReport {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_V2MulticastListenerReport {
		if _, ok := t.union132_.(*union_146_t); !ok {
			return nil // not set
		}
		tmp := V2MulticastListernerReport(t.union132_.(*union_146_t).V2MulticastListenerReport)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetV2MulticastListenerReport(v V2MulticastListernerReport) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_V2MulticastListenerReport {
		if _, ok := t.union132_.(*union_146_t); !ok {
			t.union132_ = &union_146_t{}
		}
		t.union132_.(*union_146_t).V2MulticastListenerReport = V2MulticastListernerReport(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) Visit(v VisitorKEYKW) {
	v.Visit(v, "Header", &t.Header)
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "DestinationUnreachable", (t.DestinationUnreachable()))
	v.Visit(v, "EchoReply", (t.EchoReply()))
	v.Visit(v, "EchoRequest", (t.EchoRequest()))
	v.Visit(v, "MulticastListenerQuery", (t.MulticastListenerQuery()))
	v.Visit(v, "NeighborAdvertisement", (t.NeighborAdvertisement()))
	v.Visit(v, "NeighborSolicitation", (t.NeighborSolicitation()))
	v.Visit(v, "PacketTooBig", (t.PacketTooBig()))
	v.Visit(v, "ParameterProblem", (t.ParameterProblem()))
	v.Visit(v, "RedirectMessage", (t.RedirectMessage()))
	v.Visit(v, "RouterAdvertisement", (t.RouterAdvertisement()))
	v.Visit(v, "RouterSolicitation", (t.RouterSolicitation()))
	v.Visit(v, "TimeExceeded", (t.TimeExceeded()))
	v.Visit(v, "V2MulticastListenerReport", (t.V2MulticastListenerReport()))
}
func (t *Icmpv6Packet) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Icmpv6Packet) Write(w io.Writer) (err error) {
	if err := t.Header.Write(w); err != nil {
		return fmt.Errorf("encode Header: %w", err)
	}
	switch {
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest):
		if _, ok := t.union132_.(*union_134_t); !ok {
			return fmt.Errorf("encode t.union132_: union is not set to union_134_t")
		}
		if err := t.union132_.(*union_134_t).EchoRequest.Write(w); err != nil {
			return fmt.Errorf("encode EchoRequest: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply):
		if _, ok := t.union132_.(*union_135_t); !ok {
			return fmt.Errorf("encode t.union132_: union is not set to union_135_t")
		}
		if err := t.union132_.(*union_135_t).EchoReply.Write(w); err != nil {
			return fmt.Errorf("encode EchoReply: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded):
		if _, ok := t.union132_.(*union_136_t); !ok {
			return fmt.Errorf("encode t.union132_: union is not set to union_136_t")
		}
		if err := t.union132_.(*union_136_t).TimeExceeded.Write(w); err != nil {
			return fmt.Errorf("encode TimeExceeded: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig):
		if _, ok := t.union132_.(*union_137_t); !ok {
			return fmt.Errorf("encode t.union132_: union is not set to union_137_t")
		}
		if err := t.union132_.(*union_137_t).PacketTooBig.Write(w); err != nil {
			return fmt.Errorf("encode PacketTooBig: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem):
		if _, ok := t.union132_.(*union_138_t); !ok {
			return fmt.Errorf("encode t.union132_: union is not set to union_138_t")
		}
		if err := t.union132_.(*union_138_t).ParameterProblem.Write(w); err != nil {
			return fmt.Errorf("encode ParameterProblem: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable):
		if _, ok := t.union132_.(*union_139_t); !ok {
			return fmt.Errorf("encode t.union132_: union is not set to union_139_t")
		}
		if err := t.union132_.(*union_139_t).DestinationUnreachable.Write(w); err != nil {
			return fmt.Errorf("encode DestinationUnreachable: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation):
		if _, ok := t.union132_.(*union_140_t); !ok {
			return fmt.Errorf("encode t.union132_: union is not set to union_140_t")
		}
		if err := t.union132_.(*union_140_t).RouterSolicitation.Write(w); err != nil {
			return fmt.Errorf("encode RouterSolicitation: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement):
		if _, ok := t.union132_.(*union_141_t); !ok {
			return fmt.Errorf("encode t.union132_: union is not set to union_141_t")
		}
		if err := t.union132_.(*union_141_t).RouterAdvertisement.Write(w); err != nil {
			return fmt.Errorf("encode RouterAdvertisement: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation):
		if _, ok := t.union132_.(*union_142_t); !ok {
			return fmt.Errorf("encode t.union132_: union is not set to union_142_t")
		}
		if err := t.union132_.(*union_142_t).NeighborSolicitation.Write(w); err != nil {
			return fmt.Errorf("encode NeighborSolicitation: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement):
		if _, ok := t.union132_.(*union_143_t); !ok {
			return fmt.Errorf("encode t.union132_: union is not set to union_143_t")
		}
		if err := t.union132_.(*union_143_t).NeighborAdvertisement.Write(w); err != nil {
			return fmt.Errorf("encode NeighborAdvertisement: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage):
		if _, ok := t.union132_.(*union_144_t); !ok {
			return fmt.Errorf("encode t.union132_: union is not set to union_144_t")
		}
		if err := t.union132_.(*union_144_t).RedirectMessage.Write(w); err != nil {
			return fmt.Errorf("encode RedirectMessage: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery):
		if _, ok := t.union132_.(*union_145_t); !ok {
			return fmt.Errorf("encode t.union132_: union is not set to union_145_t")
		}
		if err := t.union132_.(*union_145_t).MulticastListenerQuery.Write(w); err != nil {
			return fmt.Errorf("encode MulticastListenerQuery: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_V2MulticastListenerReport):
		if _, ok := t.union132_.(*union_146_t); !ok {
			return fmt.Errorf("encode t.union132_: union is not set to union_146_t")
		}
		if err := t.union132_.(*union_146_t).V2MulticastListenerReport.Write(w); err != nil {
			return fmt.Errorf("encode V2MulticastListenerReport: %w", err)
		}
	default:
		if _, ok := t.union132_.(*union_147_t); !ok {
			return fmt.Errorf("encode t.union132_: union is not set to union_147_t")
		}
		if n, err := w.Write(t.union132_.(*union_147_t).Data); err != nil || n != len(t.union132_.(*union_147_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *Icmpv6Packet) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Icmpv6Packet) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Icmpv6Packet) Read(r io.Reader) (err error) {
	if err := t.Header.Read(r); err != nil {
		return fmt.Errorf("read Header: %w", err)
	}
	switch {
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest):
		t.union132_ = &union_134_t{}
		if err := t.union132_.(*union_134_t).EchoRequest.Read(r); err != nil {
			return fmt.Errorf("read EchoRequest: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply):
		t.union132_ = &union_135_t{}
		if err := t.union132_.(*union_135_t).EchoReply.Read(r); err != nil {
			return fmt.Errorf("read EchoReply: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded):
		t.union132_ = &union_136_t{}
		if err := t.union132_.(*union_136_t).TimeExceeded.Read(r); err != nil {
			return fmt.Errorf("read TimeExceeded: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig):
		t.union132_ = &union_137_t{}
		if err := t.union132_.(*union_137_t).PacketTooBig.Read(r); err != nil {
			return fmt.Errorf("read PacketTooBig: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem):
		t.union132_ = &union_138_t{}
		if err := t.union132_.(*union_138_t).ParameterProblem.Read(r); err != nil {
			return fmt.Errorf("read ParameterProblem: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable):
		t.union132_ = &union_139_t{}
		if err := t.union132_.(*union_139_t).DestinationUnreachable.Read(r); err != nil {
			return fmt.Errorf("read DestinationUnreachable: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation):
		t.union132_ = &union_140_t{}
		if err := t.union132_.(*union_140_t).RouterSolicitation.Read(r); err != nil {
			return fmt.Errorf("read RouterSolicitation: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement):
		t.union132_ = &union_141_t{}
		if err := t.union132_.(*union_141_t).RouterAdvertisement.Read(r); err != nil {
			return fmt.Errorf("read RouterAdvertisement: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation):
		t.union132_ = &union_142_t{}
		if err := t.union132_.(*union_142_t).NeighborSolicitation.Read(r); err != nil {
			return fmt.Errorf("read NeighborSolicitation: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement):
		t.union132_ = &union_143_t{}
		if err := t.union132_.(*union_143_t).NeighborAdvertisement.Read(r); err != nil {
			return fmt.Errorf("read NeighborAdvertisement: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage):
		t.union132_ = &union_144_t{}
		if err := t.union132_.(*union_144_t).RedirectMessage.Read(r); err != nil {
			return fmt.Errorf("read RedirectMessage: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery):
		t.union132_ = &union_145_t{}
		if err := t.union132_.(*union_145_t).MulticastListenerQuery.Read(r); err != nil {
			return fmt.Errorf("read MulticastListenerQuery: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_V2MulticastListenerReport):
		t.union132_ = &union_146_t{}
		if err := t.union132_.(*union_146_t).V2MulticastListenerReport.Read(r); err != nil {
			return fmt.Errorf("read V2MulticastListenerReport: %w", err)
		}
	default:
		t.union132_ = &union_147_t{}
		bytes_buf_Data := &bytes.Buffer{}
		if _, err := io.Copy(bytes_buf_Data, r); err != nil {
			return err
		}
		t.union132_.(*union_147_t).Data = bytes_buf_Data.Bytes()
	}
	return nil
}

func (t *Icmpv6Packet) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Icmpv6Packet) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Icmpv6Packet: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
