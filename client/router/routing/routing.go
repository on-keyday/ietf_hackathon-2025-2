// Code generated by json2go. DO NOT EDIT.
package routing

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"reflect"
)

const BgpPort = 179

type ProtocolNumber uint8

const (
	ProtocolNumber_Hopopt        ProtocolNumber = 0
	ProtocolNumber_Icmp          ProtocolNumber = 1
	ProtocolNumber_Igmp          ProtocolNumber = 2
	ProtocolNumber_Ggp           ProtocolNumber = 3
	ProtocolNumber_Ipv4          ProtocolNumber = 4
	ProtocolNumber_St            ProtocolNumber = 5
	ProtocolNumber_Tcp           ProtocolNumber = 6
	ProtocolNumber_Cbt           ProtocolNumber = 7
	ProtocolNumber_Egp           ProtocolNumber = 8
	ProtocolNumber_Igp           ProtocolNumber = 9
	ProtocolNumber_BbnRccMon     ProtocolNumber = 10
	ProtocolNumber_NvpIi         ProtocolNumber = 11
	ProtocolNumber_Pup           ProtocolNumber = 12
	ProtocolNumber_Argus         ProtocolNumber = 13
	ProtocolNumber_Emcon         ProtocolNumber = 14
	ProtocolNumber_Xnet          ProtocolNumber = 15
	ProtocolNumber_Chaos         ProtocolNumber = 16
	ProtocolNumber_Udp           ProtocolNumber = 17
	ProtocolNumber_Mux           ProtocolNumber = 18
	ProtocolNumber_DcnMeas       ProtocolNumber = 19
	ProtocolNumber_Hmp           ProtocolNumber = 20
	ProtocolNumber_Prm           ProtocolNumber = 21
	ProtocolNumber_XnsIdp        ProtocolNumber = 22
	ProtocolNumber_Trunk1        ProtocolNumber = 23
	ProtocolNumber_Trunk2        ProtocolNumber = 24
	ProtocolNumber_RoutingHeader ProtocolNumber = 43
	ProtocolNumber_Icmpv6        ProtocolNumber = 58
	ProtocolNumber_Ethernet      ProtocolNumber = 143
)

func (t ProtocolNumber) String() string {
	switch t {
	case ProtocolNumber_Hopopt:
		return "Hopopt"
	case ProtocolNumber_Icmp:
		return "Icmp"
	case ProtocolNumber_Igmp:
		return "Igmp"
	case ProtocolNumber_Ggp:
		return "Ggp"
	case ProtocolNumber_Ipv4:
		return "Ipv4"
	case ProtocolNumber_St:
		return "St"
	case ProtocolNumber_Tcp:
		return "Tcp"
	case ProtocolNumber_Cbt:
		return "Cbt"
	case ProtocolNumber_Egp:
		return "Egp"
	case ProtocolNumber_Igp:
		return "Igp"
	case ProtocolNumber_BbnRccMon:
		return "BbnRccMon"
	case ProtocolNumber_NvpIi:
		return "NvpIi"
	case ProtocolNumber_Pup:
		return "Pup"
	case ProtocolNumber_Argus:
		return "Argus"
	case ProtocolNumber_Emcon:
		return "Emcon"
	case ProtocolNumber_Xnet:
		return "Xnet"
	case ProtocolNumber_Chaos:
		return "Chaos"
	case ProtocolNumber_Udp:
		return "Udp"
	case ProtocolNumber_Mux:
		return "Mux"
	case ProtocolNumber_DcnMeas:
		return "DcnMeas"
	case ProtocolNumber_Hmp:
		return "Hmp"
	case ProtocolNumber_Prm:
		return "Prm"
	case ProtocolNumber_XnsIdp:
		return "XnsIdp"
	case ProtocolNumber_Trunk1:
		return "Trunk1"
	case ProtocolNumber_Trunk2:
		return "Trunk2"
	case ProtocolNumber_RoutingHeader:
		return "RoutingHeader"
	case ProtocolNumber_Icmpv6:
		return "Icmpv6"
	case ProtocolNumber_Ethernet:
		return "Ethernet"
	}
	return fmt.Sprintf("ProtocolNumber(%d)", t)
}

type Bgptype uint8

const (
	Bgptype_Open         Bgptype = 1
	Bgptype_Update       Bgptype = 2
	Bgptype_Notification Bgptype = 3
	Bgptype_Keepalive    Bgptype = 4
)

func (t Bgptype) String() string {
	switch t {
	case Bgptype_Open:
		return "Open"
	case Bgptype_Update:
		return "Update"
	case Bgptype_Notification:
		return "Notification"
	case Bgptype_Keepalive:
		return "Keepalive"
	}
	return fmt.Sprintf("Bgptype(%d)", t)
}

type BgpoptionType uint8

const (
	BgpoptionType_Capability BgpoptionType = 2
)

func (t BgpoptionType) String() string {
	switch t {
	case BgpoptionType_Capability:
		return "Capability"
	}
	return fmt.Sprintf("BgpoptionType(%d)", t)
}

type AttributeCode uint8

const (
	AttributeCode_Origin                               AttributeCode = 1
	AttributeCode_AsPath                               AttributeCode = 2
	AttributeCode_NextHop                              AttributeCode = 3
	AttributeCode_MultiExitDisc                        AttributeCode = 4
	AttributeCode_LocalPref                            AttributeCode = 5
	AttributeCode_AtomicAggregate                      AttributeCode = 6
	AttributeCode_Aggregator                           AttributeCode = 7
	AttributeCode_Communities                          AttributeCode = 8
	AttributeCode_OriginatorId                         AttributeCode = 9
	AttributeCode_ClusterList                          AttributeCode = 10
	AttributeCode_DpaDeprecated                        AttributeCode = 11
	AttributeCode_AdvertiserDeprecated                 AttributeCode = 12
	AttributeCode_RcidPathDeprecated                   AttributeCode = 13
	AttributeCode_MpReachNlri                          AttributeCode = 14
	AttributeCode_MpUnreachNlri                        AttributeCode = 15
	AttributeCode_ExtendedCommunities                  AttributeCode = 16
	AttributeCode_As4Path                              AttributeCode = 17
	AttributeCode_As4Aggregator                        AttributeCode = 18
	AttributeCode_SsaDeprecated                        AttributeCode = 19
	AttributeCode_ConnectorAttributeDeprecated         AttributeCode = 20
	AttributeCode_AsPathlimitDeprecated                AttributeCode = 21
	AttributeCode_PmsiTunnel                           AttributeCode = 22
	AttributeCode_TunnelEncap                          AttributeCode = 23
	AttributeCode_TrafficEngineering                   AttributeCode = 24
	AttributeCode_Ipv6AddressSpecificExtendedCommunity AttributeCode = 25
	AttributeCode_Aigp                                 AttributeCode = 26
	AttributeCode_PeDistinguisherLabel                 AttributeCode = 27
	AttributeCode_BgpLs                                AttributeCode = 29
	AttributeCode_LargeCommunity                       AttributeCode = 32
	AttributeCode_BgpsecPath                           AttributeCode = 33
	AttributeCode_OnlyForOrf                           AttributeCode = 35
	AttributeCode_BgpDomainPath                        AttributeCode = 36
	AttributeCode_SfpAttribute                         AttributeCode = 37
	AttributeCode_BfdDiscriminator                     AttributeCode = 38
	AttributeCode_BgpPrefixSid                         AttributeCode = 40
	AttributeCode_Bier                                 AttributeCode = 41
	AttributeCode_AttrSet                              AttributeCode = 128
	AttributeCode_ReservedForDevelopment               AttributeCode = 255
)

func (t AttributeCode) String() string {
	switch t {
	case AttributeCode_Origin:
		return "Origin"
	case AttributeCode_AsPath:
		return "AsPath"
	case AttributeCode_NextHop:
		return "NextHop"
	case AttributeCode_MultiExitDisc:
		return "MultiExitDisc"
	case AttributeCode_LocalPref:
		return "LocalPref"
	case AttributeCode_AtomicAggregate:
		return "AtomicAggregate"
	case AttributeCode_Aggregator:
		return "Aggregator"
	case AttributeCode_Communities:
		return "Communities"
	case AttributeCode_OriginatorId:
		return "OriginatorId"
	case AttributeCode_ClusterList:
		return "ClusterList"
	case AttributeCode_DpaDeprecated:
		return "DpaDeprecated"
	case AttributeCode_AdvertiserDeprecated:
		return "AdvertiserDeprecated"
	case AttributeCode_RcidPathDeprecated:
		return "RcidPathDeprecated"
	case AttributeCode_MpReachNlri:
		return "MpReachNlri"
	case AttributeCode_MpUnreachNlri:
		return "MpUnreachNlri"
	case AttributeCode_ExtendedCommunities:
		return "ExtendedCommunities"
	case AttributeCode_As4Path:
		return "As4Path"
	case AttributeCode_As4Aggregator:
		return "As4Aggregator"
	case AttributeCode_SsaDeprecated:
		return "SsaDeprecated"
	case AttributeCode_ConnectorAttributeDeprecated:
		return "ConnectorAttributeDeprecated"
	case AttributeCode_AsPathlimitDeprecated:
		return "AsPathlimitDeprecated"
	case AttributeCode_PmsiTunnel:
		return "PmsiTunnel"
	case AttributeCode_TunnelEncap:
		return "TunnelEncap"
	case AttributeCode_TrafficEngineering:
		return "TrafficEngineering"
	case AttributeCode_Ipv6AddressSpecificExtendedCommunity:
		return "Ipv6AddressSpecificExtendedCommunity"
	case AttributeCode_Aigp:
		return "Aigp"
	case AttributeCode_PeDistinguisherLabel:
		return "PeDistinguisherLabel"
	case AttributeCode_BgpLs:
		return "BgpLs"
	case AttributeCode_LargeCommunity:
		return "LargeCommunity"
	case AttributeCode_BgpsecPath:
		return "BgpsecPath"
	case AttributeCode_OnlyForOrf:
		return "OnlyForOrf"
	case AttributeCode_BgpDomainPath:
		return "BgpDomainPath"
	case AttributeCode_SfpAttribute:
		return "SfpAttribute"
	case AttributeCode_BfdDiscriminator:
		return "BfdDiscriminator"
	case AttributeCode_BgpPrefixSid:
		return "BgpPrefixSid"
	case AttributeCode_Bier:
		return "Bier"
	case AttributeCode_AttrSet:
		return "AttrSet"
	case AttributeCode_ReservedForDevelopment:
		return "ReservedForDevelopment"
	}
	return fmt.Sprintf("AttributeCode(%d)", t)
}

type EtherType uint16

const (
	EtherType_Ipv4           EtherType = 0x0800
	EtherType_Arp            EtherType = 0x0806
	EtherType_Vlan           EtherType = 0x8100
	EtherType_Ipv6           EtherType = 0x86DD
	EtherType_ServiceVlen    EtherType = 0x88A8
	EtherType_PppoeDiscovery EtherType = 0x8863
	EtherType_PppoeSession   EtherType = 0x8864
)

func (t EtherType) String() string {
	switch t {
	case EtherType_Ipv4:
		return "Ipv4"
	case EtherType_Arp:
		return "Arp"
	case EtherType_Vlan:
		return "Vlan"
	case EtherType_Ipv6:
		return "Ipv6"
	case EtherType_ServiceVlen:
		return "ServiceVlen"
	case EtherType_PppoeDiscovery:
		return "PppoeDiscovery"
	case EtherType_PppoeSession:
		return "PppoeSession"
	}
	return fmt.Sprintf("EtherType(%d)", t)
}

type Tcpstate int

const (
	Tcpstate_Closed      Tcpstate = 0
	Tcpstate_Listen      Tcpstate = 1
	Tcpstate_SynSent     Tcpstate = 2
	Tcpstate_SynRcvd     Tcpstate = 3
	Tcpstate_Established Tcpstate = 4
	Tcpstate_FinWait1    Tcpstate = 5
	Tcpstate_FinWait2    Tcpstate = 6
	Tcpstate_CloseWait   Tcpstate = 7
	Tcpstate_Closing     Tcpstate = 8
	Tcpstate_LastAck     Tcpstate = 9
	Tcpstate_TimeWait    Tcpstate = 10
)

func (t Tcpstate) String() string {
	switch t {
	case Tcpstate_Closed:
		return "Closed"
	case Tcpstate_Listen:
		return "Listen"
	case Tcpstate_SynSent:
		return "SynSent"
	case Tcpstate_SynRcvd:
		return "SynRcvd"
	case Tcpstate_Established:
		return "Established"
	case Tcpstate_FinWait1:
		return "FinWait1"
	case Tcpstate_FinWait2:
		return "FinWait2"
	case Tcpstate_CloseWait:
		return "CloseWait"
	case Tcpstate_Closing:
		return "Closing"
	case Tcpstate_LastAck:
		return "LastAck"
	case Tcpstate_TimeWait:
		return "TimeWait"
	}
	return fmt.Sprintf("Tcpstate(%d)", t)
}

type TcpoptionKind uint8

const (
	TcpoptionKind_EndOfOptionsList   TcpoptionKind = 0
	TcpoptionKind_Nop                TcpoptionKind = 1
	TcpoptionKind_MaximumSegmentSize TcpoptionKind = 2
	TcpoptionKind_WindowScale        TcpoptionKind = 3
	TcpoptionKind_SackPermitted      TcpoptionKind = 4
	TcpoptionKind_Sack               TcpoptionKind = 5
	TcpoptionKind_Timestamp          TcpoptionKind = 8
	TcpoptionKind_Mptcp              TcpoptionKind = 30
)

func (t TcpoptionKind) String() string {
	switch t {
	case TcpoptionKind_EndOfOptionsList:
		return "EndOfOptionsList"
	case TcpoptionKind_Nop:
		return "Nop"
	case TcpoptionKind_MaximumSegmentSize:
		return "MaximumSegmentSize"
	case TcpoptionKind_WindowScale:
		return "WindowScale"
	case TcpoptionKind_SackPermitted:
		return "SackPermitted"
	case TcpoptionKind_Sack:
		return "Sack"
	case TcpoptionKind_Timestamp:
		return "Timestamp"
	case TcpoptionKind_Mptcp:
		return "Mptcp"
	}
	return fmt.Sprintf("TcpoptionKind(%d)", t)
}

type Icmpv6Type uint8

const (
	Icmpv6Type_DestinationUnreachable                Icmpv6Type = 1
	Icmpv6Type_PacketTooBig                          Icmpv6Type = 2
	Icmpv6Type_TimeExceeded                          Icmpv6Type = 3
	Icmpv6Type_ParameterProblem                      Icmpv6Type = 4
	Icmpv6Type_EchoRequest                           Icmpv6Type = 128
	Icmpv6Type_EchoReply                             Icmpv6Type = 129
	Icmpv6Type_MulticastListenerQuery                Icmpv6Type = 130
	Icmpv6Type_MulticastListenerReport               Icmpv6Type = 131
	Icmpv6Type_MulticastListenerDone                 Icmpv6Type = 132
	Icmpv6Type_RouterSolicitation                    Icmpv6Type = 133
	Icmpv6Type_RouterAdvertisement                   Icmpv6Type = 134
	Icmpv6Type_NeighborSolicitation                  Icmpv6Type = 135
	Icmpv6Type_NeighborAdvertisement                 Icmpv6Type = 136
	Icmpv6Type_RedirectMessage                       Icmpv6Type = 137
	Icmpv6Type_RouterRenumbering                     Icmpv6Type = 138
	Icmpv6Type_NodeInformationQuery                  Icmpv6Type = 139
	Icmpv6Type_NodeInformationResponse               Icmpv6Type = 140
	Icmpv6Type_InverseNeighborDiscoverySolicitation  Icmpv6Type = 141
	Icmpv6Type_InverseNeighborDiscoveryAdvertisement Icmpv6Type = 142
	Icmpv6Type_V2MulticastListenerReport             Icmpv6Type = 143
	Icmpv6Type_HomeAgentAddressDiscoveryRequest      Icmpv6Type = 144
	Icmpv6Type_HomeAgentAddressDiscoveryReply        Icmpv6Type = 145
	Icmpv6Type_MobilePrefixSolicitation              Icmpv6Type = 146
	Icmpv6Type_MobilePrefixAdvertisement             Icmpv6Type = 147
	Icmpv6Type_CertificationPathSolicitation         Icmpv6Type = 148
	Icmpv6Type_CertificationPathAdvertisement        Icmpv6Type = 149
	Icmpv6Type_ExperimentalMobilityProtocols         Icmpv6Type = 253
	Icmpv6Type_ExperimentalMobilityProtocols2        Icmpv6Type = 254
	Icmpv6Type_Reserved                              Icmpv6Type = 255
)

func (t Icmpv6Type) String() string {
	switch t {
	case Icmpv6Type_DestinationUnreachable:
		return "DestinationUnreachable"
	case Icmpv6Type_PacketTooBig:
		return "PacketTooBig"
	case Icmpv6Type_TimeExceeded:
		return "TimeExceeded"
	case Icmpv6Type_ParameterProblem:
		return "ParameterProblem"
	case Icmpv6Type_EchoRequest:
		return "EchoRequest"
	case Icmpv6Type_EchoReply:
		return "EchoReply"
	case Icmpv6Type_MulticastListenerQuery:
		return "MulticastListenerQuery"
	case Icmpv6Type_MulticastListenerReport:
		return "MulticastListenerReport"
	case Icmpv6Type_MulticastListenerDone:
		return "MulticastListenerDone"
	case Icmpv6Type_RouterSolicitation:
		return "RouterSolicitation"
	case Icmpv6Type_RouterAdvertisement:
		return "RouterAdvertisement"
	case Icmpv6Type_NeighborSolicitation:
		return "NeighborSolicitation"
	case Icmpv6Type_NeighborAdvertisement:
		return "NeighborAdvertisement"
	case Icmpv6Type_RedirectMessage:
		return "RedirectMessage"
	case Icmpv6Type_RouterRenumbering:
		return "RouterRenumbering"
	case Icmpv6Type_NodeInformationQuery:
		return "NodeInformationQuery"
	case Icmpv6Type_NodeInformationResponse:
		return "NodeInformationResponse"
	case Icmpv6Type_InverseNeighborDiscoverySolicitation:
		return "InverseNeighborDiscoverySolicitation"
	case Icmpv6Type_InverseNeighborDiscoveryAdvertisement:
		return "InverseNeighborDiscoveryAdvertisement"
	case Icmpv6Type_V2MulticastListenerReport:
		return "V2MulticastListenerReport"
	case Icmpv6Type_HomeAgentAddressDiscoveryRequest:
		return "HomeAgentAddressDiscoveryRequest"
	case Icmpv6Type_HomeAgentAddressDiscoveryReply:
		return "HomeAgentAddressDiscoveryReply"
	case Icmpv6Type_MobilePrefixSolicitation:
		return "MobilePrefixSolicitation"
	case Icmpv6Type_MobilePrefixAdvertisement:
		return "MobilePrefixAdvertisement"
	case Icmpv6Type_CertificationPathSolicitation:
		return "CertificationPathSolicitation"
	case Icmpv6Type_CertificationPathAdvertisement:
		return "CertificationPathAdvertisement"
	case Icmpv6Type_ExperimentalMobilityProtocols:
		return "ExperimentalMobilityProtocols"
	case Icmpv6Type_ExperimentalMobilityProtocols2:
		return "ExperimentalMobilityProtocols2"
	case Icmpv6Type_Reserved:
		return "Reserved"
	}
	return fmt.Sprintf("Icmpv6Type(%d)", t)
}

type NdpoptionType uint8

const (
	NdpoptionType_SourceLinkLayerAddress NdpoptionType = 1
	NdpoptionType_TargetLinkLayerAddress NdpoptionType = 2
	NdpoptionType_PrefixInformation      NdpoptionType = 3
	NdpoptionType_RedirectHeader         NdpoptionType = 4
	NdpoptionType_Mtu                    NdpoptionType = 5
)

func (t NdpoptionType) String() string {
	switch t {
	case NdpoptionType_SourceLinkLayerAddress:
		return "SourceLinkLayerAddress"
	case NdpoptionType_TargetLinkLayerAddress:
		return "TargetLinkLayerAddress"
	case NdpoptionType_PrefixInformation:
		return "PrefixInformation"
	case NdpoptionType_RedirectHeader:
		return "RedirectHeader"
	case NdpoptionType_Mtu:
		return "Mtu"
	}
	return fmt.Sprintf("NdpoptionType(%d)", t)
}

type union2_SegmentRoutingTlv interface {
	isunion1_()
}
type union_3_t struct {
	Len  uint8
	Data []uint8
}
type SegmentRoutingTlv struct {
	Type    uint8
	union1_ union2_SegmentRoutingTlv
}
type VisitorKEYKW interface {
	Visit(v VisitorKEYKW, name string, field any)
}
type VisitorKEYKWFunc func(v VisitorKEYKW, name string, field any)

func (f VisitorKEYKWFunc) Visit(v VisitorKEYKW, name string, field any) {
	f(v, name, field)
}

type VisitorKEYKWVisitable interface {
	Visit(v VisitorKEYKW)
}

func VisitorKEYKWToMap(v any) interface{} {
	if v == nil {
		return nil
	}
	if inter, ok := v.(VisitorKEYKWVisitable); ok {
		if p := reflect.ValueOf(inter); p.Kind() == reflect.Pointer && p.IsNil() {
			return nil
		}
		m := map[string]interface{}{}
		inter.Visit(VisitorKEYKWFunc(func(v VisitorKEYKW, name string, field any) {
			m[name] = VisitorKEYKWToMap(field)
		}))
		return m
	}
	if tf := reflect.TypeOf(v); (tf.Kind() == reflect.Slice || tf.Kind() == reflect.Array) && !(func() bool { k := tf.Elem().Kind().String(); return k[:3] == "int" || k[:3] == "uin" || k[:3] == "flo" })() {
		m := []interface{}{}
		vf := reflect.ValueOf(v)
		for i := 0; i < vf.Len(); i++ {
			index := vf.Index(i)
			if index.Kind() == reflect.Struct && index.CanAddr() {
				index = index.Addr()
			}
			m = append(m, VisitorKEYKWToMap(index.Interface()))
		}
		return m
	}
	if tf := reflect.TypeOf(v); tf.Kind() == reflect.Pointer {
		val := reflect.ValueOf(v)
		if val.IsNil() {
			return nil
		}
		return VisitorKEYKWToMap(val.Elem().Interface())
	}
	return v
}

type Ipv6ExtHeader struct {
	NextHeader ProtocolNumber
	HdrExtLen  uint8
}
type Ipv6Header struct {
	flags4     uint32
	PayloadLen uint16
	NextHeader ProtocolNumber
	HopLimit   uint8
	SrcAddr    [16]uint8
	DstAddr    [16]uint8
}
type Bgpheader struct {
	// "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" (16 byte)
	Length uint16
	Type   Bgptype
}
type Bgpoption struct {
	Type BgpoptionType
	Len  uint8
	Data []uint8
}
type WithdrawnRoutes struct {
	Len  uint16
	Data []uint8
}
type Withdrawn struct {
	Len  uint16
	Data []uint8
}
type AttributeType struct {
	flags13 uint8
	Code    AttributeCode
}
type NetWorkReachabilityInfo struct {
	Prefixlen uint8
	Prefix    []uint8
}
type Notification struct {
	Code    uint8
	Subcode uint8
	Data    []uint8
}
type Oui struct {
	flags14 uint8
	Low     [2]uint8
}
type union16_EthernetFrame interface {
	isunion15_()
}
type union_17_t struct {
	VlanTag    uint16
	EtherType2 uint16
}
type union_18_t struct {
	ServiceVlanTag uint16
	DummyEtherType uint16
	VlanTag        uint16
	EtherType2     uint16
}
type union20_EthernetFrame interface {
	isunion19_()
}
type union_21_t struct {
	Data []uint8
}
type union_22_t struct {
	Data []uint8
}
type EthernetFrame struct {
	DstMac    [6]uint8
	SrcMac    [6]uint8
	EtherType uint16
	union15_  union16_EthernetFrame
	union19_  union20_EthernetFrame
}
type Tcpflags struct {
	flags30 uint8
}
type SackBlock struct {
	Left  uint32
	Right uint32
}
type Timestamp struct {
	Value     uint32
	EchoReply uint32
}
type Icmpheader struct {
	Type     uint8
	Code     uint8
	Checksum uint16
}
type IcmptimeExceeded struct {
	Unused uint32
	Data   []uint8
}
type Icmpecho struct {
	Id   uint16
	Seq  uint16
	Data []uint8
}
type IcmpdestinationUnreachable struct {
	Unused     uint16
	NextHopMtu uint16
	Data       []uint8
}
type IcmppacketTooBig struct {
	Unused uint32
	Mtu    uint32
	Data   []uint8
}
type Icmpv6ParameterProblem struct {
	Pointer uint32
	Data    []uint8
}
type FloatMaximumResponseCode struct {
	flags44 uint16
}
type FloatQqic struct {
	flags46 uint8
}
type MulticastListenerQuery struct {
	MaxRespCode          uint16
	Reserved1            uint16
	McastAddr            [16]uint8
	flags47              uint8
	QuerierQueryInterval uint8
	NumberOfSources      uint16
	SourceAddr           [][16]uint8
}
type MulticastAddressRecord struct {
	RecordType      uint8
	AuxDataLen      uint8
	NumberOfSources uint16
	MulticastAddr   [16]uint8
	SourceAddr      [][16]uint8
	AuxData         []uint8
}
type PrefixInformation struct {
	PrefixLength      uint8
	flags56           uint8
	ValidLifetime     uint32
	PreferredLifetime uint32
	Reserved2         uint32
	Prefix            [16]uint8
}
type RedirectHeader struct {
	Reserved   [6]uint8
	HdrAndData []uint8
}
type Mtu struct {
	Reserved uint16
	Mtu      uint32
}
type Ipv6ChecksumPseudoHeader struct {
	SrcAddr          [16]uint8
	DstAddr          [16]uint8
	UpperLayerLength uint32
	Zero             uint32
	NextHeader       ProtocolNumber
}
type Ipv6ExtCommon struct {
	Header Ipv6ExtHeader
	Data   []uint8
}
type Open struct {
	Version uint8
	As      uint16
	Hold    uint16
	Id      uint32
	Optlen  uint8
	Options []Bgpoption
}
type union70_PathAttribute interface {
	isunion69_()
}
type union_71_t struct {
	Len uint16
}
type union_72_t struct {
	Len uint8
}
type PathAttribute struct {
	Type     AttributeType
	union69_ union70_PathAttribute
	Data     []uint8
}
type PathAttrs struct {
	Len  uint16
	Data []PathAttribute
}
type MacAddress struct {
	Oui Oui
	Nic [3]uint8
}
type Sack struct {
	Blocks []SackBlock
}
type union81_Tcpoption interface {
	isunion80_()
}
type union_82_t struct{}
type union_83_t struct{}
type union_84_t struct {
	Length uint8
	Mss    uint16
}
type union_85_t struct {
	Length     uint8
	ShiftCount uint8
}
type union_86_t struct {
	Length uint8
}
type union_87_t struct {
	Length uint8
	Sack   Sack
}
type union_88_t struct {
	Length    uint8
	Timestamp Timestamp
}
type union_89_t struct {
	Length uint8
	Data   []uint8
}
type Tcpoption struct {
	Kind     TcpoptionKind
	union80_ union81_Tcpoption
}
type Tcpheader struct {
	SrcPort       uint16
	DstPort       uint16
	SeqNum        uint32
	AckNum        uint32
	flags95       uint8
	Flags         Tcpflags
	WindowSize    uint16
	Checksum      uint16
	UrgentPointer uint16
	Options       []Tcpoption
}
type Tcpsegment struct {
	Hdr     Tcpheader
	Payload []uint8
}
type union107_Ndpoption interface {
	isunion106_()
}
type union_108_t struct {
	LinkLayerAddress []uint8
}
type union_109_t struct {
	LinkLayerAddress []uint8
}
type union_110_t struct {
	PrefixInformation PrefixInformation
}
type union_111_t struct {
	RedirectHeader RedirectHeader
}
type union_112_t struct {
	Mtu Mtu
}
type union_113_t struct {
	Data []uint8
}
type Ndpoption struct {
	Type      NdpoptionType
	Length    uint8
	union106_ union107_Ndpoption
}
type NdprouterSolicitation struct {
	Reserved uint32
	Options  []Ndpoption
}
type NdprouterAdvertisement struct {
	CurHopLimit    uint8
	flags123       uint8
	RouterLifetime uint16
	ReachableTime  uint32
	RetransTimer   uint32
	Options        []Ndpoption
}
type NdpneighborSolicitation struct {
	Reserved   uint32
	TargetAddr [16]uint8
	Options    []Ndpoption
}
type NdpneighborAdvertisement struct {
	flags132   uint32
	TargetAddr [16]uint8
	Options    []Ndpoption
}
type NdpredirectMessage struct {
	TargetAddr [16]uint8
	DestAddr   [16]uint8
	Options    []Ndpoption
}
type V2MulticastListernerReport struct {
	Reserved1       uint16
	NumberOfRecords uint16
	Records         []MulticastAddressRecord
}
type SegmentRouting struct {
	Header       Ipv6ExtHeader
	RoutingType  uint8
	SegmentsLeft uint8
	LastEntry    uint8
	Flags        uint8
	Tag          uint16
	SegmentList  [][16]uint8
	Options      []SegmentRoutingTlv
}
type Update struct {
	WithdrawnRoutes         WithdrawnRoutes
	PathAttr                PathAttrs
	NetworkReachabilityInfo []NetWorkReachabilityInfo
}
type union151_Bgppacket interface {
	isunion150_()
}
type union_152_t struct {
	Open Open
}
type union_153_t struct {
	Update Update
}
type union_154_t struct {
	Notification Notification
}
type union_155_t struct{}
type Bgppacket struct {
	Header    Bgpheader
	union150_ union151_Bgppacket
}
type union163_Icmpv6Packet interface {
	isunion162_()
}
type union_164_t struct {
	EchoRequest Icmpecho
}
type union_165_t struct {
	EchoReply Icmpecho
}
type union_166_t struct {
	TimeExceeded Icmpv6ParameterProblem
}
type union_167_t struct {
	PacketTooBig IcmppacketTooBig
}
type union_168_t struct {
	ParameterProblem Icmpv6ParameterProblem
}
type union_169_t struct {
	DestinationUnreachable IcmpdestinationUnreachable
}
type union_170_t struct {
	RouterSolicitation NdprouterSolicitation
}
type union_171_t struct {
	RouterAdvertisement NdprouterAdvertisement
}
type union_172_t struct {
	NeighborSolicitation NdpneighborSolicitation
}
type union_173_t struct {
	NeighborAdvertisement NdpneighborAdvertisement
}
type union_174_t struct {
	RedirectMessage NdpredirectMessage
}
type union_175_t struct {
	MulticastListenerQuery MulticastListenerQuery
}
type union_176_t struct {
	V2MulticastListenerReport V2MulticastListernerReport
}
type union_177_t struct {
	Data []uint8
}
type Icmpv6Packet struct {
	Header    Icmpheader
	union162_ union163_Icmpv6Packet
}

func (t *union_3_t) isunion1_() {}
func (t *SegmentRoutingTlv) Data() *[]uint8 {
	if true == (t.Type != 0) {
		if _, ok := t.union1_.(*union_3_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union1_.(*union_3_t).Data)
		return &tmp
	}
	return nil
}
func (t *SegmentRoutingTlv) SetData(v []uint8) bool {
	if true == (t.Type != 0) {
		if len(v) > int(^uint8(0)) {
			return false
		}
		if _, ok := t.union1_.(*union_3_t); !ok {
			t.union1_ = &union_3_t{}
		}
		t.union1_.(*union_3_t).Len = uint8(len(v))
		t.union1_.(*union_3_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *SegmentRoutingTlv) Len() *uint8 {
	if true == (t.Type != 0) {
		if _, ok := t.union1_.(*union_3_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union1_.(*union_3_t).Len)
		return &tmp
	}
	return nil
}
func (t *SegmentRoutingTlv) SetLen(v uint8) bool {
	if true == (t.Type != 0) {
		if _, ok := t.union1_.(*union_3_t); !ok {
			t.union1_ = &union_3_t{}
		}
		t.union1_.(*union_3_t).Len = uint8(v)
		return true
	}
	return false
}
func (t *SegmentRoutingTlv) Visit(v VisitorKEYKW) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "Len", (t.Len()))
}
func (t *SegmentRoutingTlv) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *SegmentRoutingTlv) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	if t.Type != 0 {
		if _, ok := t.union1_.(*union_3_t); !ok {
			return fmt.Errorf("encode t.union1_: union is not set to union_3_t")
		}
		if n, err := w.Write([]byte{byte(t.union1_.(*union_3_t).Len)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union1_.(*union_3_t).Len: %w", err)
		}
		len_Data := int(t.union1_.(*union_3_t).Len)
		if len(t.union1_.(*union_3_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union1_.(*union_3_t).Data))
		}
		if n, err := w.Write(t.union1_.(*union_3_t).Data); err != nil || n != len(t.union1_.(*union_3_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *SegmentRoutingTlv) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SegmentRoutingTlv) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SegmentRoutingTlv) Read(r io.Reader) (err error) {
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint8(tmpType[0])
	if t.Type != 0 {
		t.union1_ = &union_3_t{}
		tmpLen := [1]byte{}
		n_Len, err := io.ReadFull(r, tmpLen[:])
		if err != nil {
			return fmt.Errorf("read Len: expect 1 byte but read %d bytes: %w", n_Len, err)
		}
		t.union1_.(*union_3_t).Len = uint8(tmpLen[0])
		len_Data := int(t.union1_.(*union_3_t).Len)
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union1_.(*union_3_t).Data = tmpData[:]
		} else {
			t.union1_.(*union_3_t).Data = nil
		}
	}
	return nil
}

func (t *SegmentRoutingTlv) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SegmentRoutingTlv) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SegmentRoutingTlv: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Ipv6ExtHeader) Visit(v VisitorKEYKW) {
	v.Visit(v, "NextHeader", &t.NextHeader)
	v.Visit(v, "HdrExtLen", &t.HdrExtLen)
}
func (t *Ipv6ExtHeader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Ipv6ExtHeader) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.NextHeader)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.NextHeader: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.HdrExtLen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.HdrExtLen: %w", err)
	}
	return nil
}
func (t *Ipv6ExtHeader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Ipv6ExtHeader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Ipv6ExtHeader) Read(r io.Reader) (err error) {
	tmpNextHeader := [1]byte{}
	n_NextHeader, err := io.ReadFull(r, tmpNextHeader[:])
	if err != nil {
		return fmt.Errorf("read NextHeader: expect 1 byte but read %d bytes: %w", n_NextHeader, err)
	}
	t.NextHeader = ProtocolNumber(tmpNextHeader[0])
	tmpHdrExtLen := [1]byte{}
	n_HdrExtLen, err := io.ReadFull(r, tmpHdrExtLen[:])
	if err != nil {
		return fmt.Errorf("read HdrExtLen: expect 1 byte but read %d bytes: %w", n_HdrExtLen, err)
	}
	t.HdrExtLen = uint8(tmpHdrExtLen[0])
	return nil
}

func (t *Ipv6ExtHeader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Ipv6ExtHeader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Ipv6ExtHeader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Ipv6Header) Version() uint32 {
	return ((t.flags4 & 0xf0000000) >> 28)
}
func (t *Ipv6Header) SetVersion(v uint32) bool {
	if v > 15 {
		return false
	}
	t.flags4 = (t.flags4 & ^uint32(0xf0000000)) | ((v & 0xf) << 28)
	return true
}
func (t *Ipv6Header) TrafficClass() uint32 {
	return ((t.flags4 & 0x0ff00000) >> 20)
}
func (t *Ipv6Header) SetTrafficClass(v uint32) bool {
	if v > 255 {
		return false
	}
	t.flags4 = (t.flags4 & ^uint32(0xff00000)) | ((v & 0xff) << 20)
	return true
}
func (t *Ipv6Header) FlowLabel() uint32 {
	return ((t.flags4 & 0x000fffff) >> 0)
}
func (t *Ipv6Header) SetFlowLabel(v uint32) bool {
	if v > 1048575 {
		return false
	}
	t.flags4 = (t.flags4 & ^uint32(0xfffff)) | ((v & 0xfffff) << 0)
	return true
}
func (t *Ipv6Header) Visit(v VisitorKEYKW) {
	v.Visit(v, "Version", t.Version())
	v.Visit(v, "TrafficClass", t.TrafficClass())
	v.Visit(v, "FlowLabel", t.FlowLabel())
	v.Visit(v, "PayloadLen", &t.PayloadLen)
	v.Visit(v, "NextHeader", &t.NextHeader)
	v.Visit(v, "HopLimit", &t.HopLimit)
	v.Visit(v, "SrcAddr", &t.SrcAddr)
	v.Visit(v, "DstAddr", &t.DstAddr)
}
func (t *Ipv6Header) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Ipv6Header) Write(w io.Writer) (err error) {
	tmp5 := [4]byte{}
	binary.BigEndian.PutUint32(tmp5[:], uint32(t.flags4))
	if n, err := w.Write(tmp5[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.flags4: %w", err)
	}
	tmp6 := [2]byte{}
	binary.BigEndian.PutUint16(tmp6[:], uint16(t.PayloadLen))
	if n, err := w.Write(tmp6[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.PayloadLen: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.NextHeader)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.NextHeader: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.HopLimit)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.HopLimit: %w", err)
	}
	if n, err := w.Write(t.SrcAddr[:]); err != nil || n != len(t.SrcAddr) {
		return fmt.Errorf("encode SrcAddr: %w", err)
	}
	if n, err := w.Write(t.DstAddr[:]); err != nil || n != len(t.DstAddr) {
		return fmt.Errorf("encode DstAddr: %w", err)
	}
	return nil
}
func (t *Ipv6Header) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 40))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Ipv6Header) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Ipv6Header) Read(r io.Reader) (err error) {
	tmpflags4 := [4]byte{}
	n_flags4, err := io.ReadFull(r, tmpflags4[:])
	if err != nil {
		return fmt.Errorf("read flags4: expect 4 bytes but read %d bytes: %w", n_flags4, err)
	}
	t.flags4 = uint32(binary.BigEndian.Uint32(tmpflags4[:]))
	tmpPayloadLen := [2]byte{}
	n_PayloadLen, err := io.ReadFull(r, tmpPayloadLen[:])
	if err != nil {
		return fmt.Errorf("read PayloadLen: expect 2 bytes but read %d bytes: %w", n_PayloadLen, err)
	}
	t.PayloadLen = uint16(binary.BigEndian.Uint16(tmpPayloadLen[:]))
	tmpNextHeader := [1]byte{}
	n_NextHeader, err := io.ReadFull(r, tmpNextHeader[:])
	if err != nil {
		return fmt.Errorf("read NextHeader: expect 1 byte but read %d bytes: %w", n_NextHeader, err)
	}
	t.NextHeader = ProtocolNumber(tmpNextHeader[0])
	tmpHopLimit := [1]byte{}
	n_HopLimit, err := io.ReadFull(r, tmpHopLimit[:])
	if err != nil {
		return fmt.Errorf("read HopLimit: expect 1 byte but read %d bytes: %w", n_HopLimit, err)
	}
	t.HopLimit = uint8(tmpHopLimit[0])
	n_SrcAddr, err := io.ReadFull(r, t.SrcAddr[:])
	if err != nil {
		return fmt.Errorf("read SrcAddr: expect %d bytes but read %d bytes: %w", 16, n_SrcAddr, err)
	}
	n_DstAddr, err := io.ReadFull(r, t.DstAddr[:])
	if err != nil {
		return fmt.Errorf("read DstAddr: expect %d bytes but read %d bytes: %w", 16, n_DstAddr, err)
	}
	return nil
}

func (t *Ipv6Header) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Ipv6Header) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Ipv6Header: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Bgpheader) Visit(v VisitorKEYKW) {
	v.Visit(v, "Marker", "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF")
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Type", &t.Type)
}
func (t *Bgpheader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Bgpheader) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF")); err != nil || n != len("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF") {
		return fmt.Errorf("encode Marker: %w", err)
	}
	tmp7 := [2]byte{}
	binary.BigEndian.PutUint16(tmp7[:], uint16(t.Length))
	if n, err := w.Write(tmp7[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	return nil
}
func (t *Bgpheader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 19))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Bgpheader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Bgpheader) Read(r io.Reader) (err error) {
	tmp8_ := [16]byte{}
	n_tmp8_, err := io.ReadFull(r, tmp8_[:])
	if err != nil {
		return fmt.Errorf("read Marker: expect 16 bytes but read %d bytes: %w", n_tmp8_, err)
	}
	if string(tmp8_[:]) != "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" {
		return fmt.Errorf("read Marker: expect %s but got %s", "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", tmp8_[:])
	}
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = Bgptype(tmpType[0])
	return nil
}

func (t *Bgpheader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Bgpheader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Bgpheader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Bgpoption) SetData(v []uint8) bool {
	if len(v) > int(^uint8(0)) {
		return false
	}
	t.Len = uint8(len(v))
	t.Data = v
	return true
}
func (t *Bgpoption) Visit(v VisitorKEYKW) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Len", &t.Len)
	v.Visit(v, "Data", &t.Data)
}
func (t *Bgpoption) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Bgpoption) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Len)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Len: %w", err)
	}
	len_Data := int(t.Len)
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.Data))
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Bgpoption) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Bgpoption) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Bgpoption) Read(r io.Reader) (err error) {
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = BgpoptionType(tmpType[0])
	tmpLen := [1]byte{}
	n_Len, err := io.ReadFull(r, tmpLen[:])
	if err != nil {
		return fmt.Errorf("read Len: expect 1 byte but read %d bytes: %w", n_Len, err)
	}
	t.Len = uint8(tmpLen[0])
	len_Data := int(t.Len)
	if len_Data != 0 {
		tmpData := make([]byte, len_Data)
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
		}
		t.Data = tmpData[:]
	} else {
		t.Data = nil
	}
	return nil
}

func (t *Bgpoption) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Bgpoption) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Bgpoption: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *WithdrawnRoutes) Visit(v VisitorKEYKW) {
	v.Visit(v, "Len", &t.Len)
	v.Visit(v, "Data", &t.Data)
}
func (t *WithdrawnRoutes) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *WithdrawnRoutes) Write(w io.Writer) (err error) {
	tmp9 := [2]byte{}
	binary.BigEndian.PutUint16(tmp9[:], uint16(t.Len))
	if n, err := w.Write(tmp9[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Len: %w", err)
	}
	new_buf_10 := bytes.NewBuffer(nil)
	old_buf_10_w := w
	w = new_buf_10
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	if new_buf_10.Len() != int(t.Len) {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", new_buf_10.Len(), int(t.Len))
	}
	_, err = new_buf_10.WriteTo(old_buf_10_w)
	if err != nil {
		return err
	}
	w = old_buf_10_w
	return nil
}
func (t *WithdrawnRoutes) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *WithdrawnRoutes) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *WithdrawnRoutes) Read(r io.Reader) (err error) {
	tmpLen := [2]byte{}
	n_Len, err := io.ReadFull(r, tmpLen[:])
	if err != nil {
		return fmt.Errorf("read Len: expect 2 bytes but read %d bytes: %w", n_Len, err)
	}
	t.Len = uint16(binary.BigEndian.Uint16(tmpLen[:]))
	sub_byte_len_Data := int64(t.Len)
	sub_byte_r_Data := io.LimitReader(r, int64(sub_byte_len_Data))
	tmp_old_r_Data_11 := r
	r = sub_byte_r_Data
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	if sub_byte_r_Data.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Data: expect %d bytes but got %d bytes", sub_byte_len_Data, sub_byte_len_Data-sub_byte_r_Data.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Data_11
	return nil
}

func (t *WithdrawnRoutes) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *WithdrawnRoutes) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode WithdrawnRoutes: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Withdrawn) SetData(v []uint8) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.Len = uint16(len(v))
	t.Data = v
	return true
}
func (t *Withdrawn) Visit(v VisitorKEYKW) {
	v.Visit(v, "Len", &t.Len)
	v.Visit(v, "Data", &t.Data)
}
func (t *Withdrawn) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Withdrawn) Write(w io.Writer) (err error) {
	tmp12 := [2]byte{}
	binary.BigEndian.PutUint16(tmp12[:], uint16(t.Len))
	if n, err := w.Write(tmp12[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Len: %w", err)
	}
	len_Data := int(t.Len)
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.Data))
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Withdrawn) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Withdrawn) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Withdrawn) Read(r io.Reader) (err error) {
	tmpLen := [2]byte{}
	n_Len, err := io.ReadFull(r, tmpLen[:])
	if err != nil {
		return fmt.Errorf("read Len: expect 2 bytes but read %d bytes: %w", n_Len, err)
	}
	t.Len = uint16(binary.BigEndian.Uint16(tmpLen[:]))
	len_Data := int(t.Len)
	if len_Data != 0 {
		tmpData := make([]byte, len_Data)
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
		}
		t.Data = tmpData[:]
	} else {
		t.Data = nil
	}
	return nil
}

func (t *Withdrawn) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Withdrawn) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Withdrawn: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *AttributeType) Option() bool {
	return ((t.flags13 & 0x80) >> 7) == 1
}
func (t *AttributeType) SetOption(v bool) {
	if v {
		t.flags13 |= uint8(0x80)
	} else {
		t.flags13 &= ^uint8(0x80)
	}
}
func (t *AttributeType) Transitive() bool {
	return ((t.flags13 & 0x40) >> 6) == 1
}
func (t *AttributeType) SetTransitive(v bool) {
	if v {
		t.flags13 |= uint8(0x40)
	} else {
		t.flags13 &= ^uint8(0x40)
	}
}
func (t *AttributeType) Partial() bool {
	return ((t.flags13 & 0x20) >> 5) == 1
}
func (t *AttributeType) SetPartial(v bool) {
	if v {
		t.flags13 |= uint8(0x20)
	} else {
		t.flags13 &= ^uint8(0x20)
	}
}
func (t *AttributeType) Extended() bool {
	return ((t.flags13 & 0x10) >> 4) == 1
}
func (t *AttributeType) SetExtended(v bool) {
	if v {
		t.flags13 |= uint8(0x10)
	} else {
		t.flags13 &= ^uint8(0x10)
	}
}
func (t *AttributeType) Reserved() uint8 {
	return ((t.flags13 & 0x0f) >> 0)
}
func (t *AttributeType) SetReserved(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags13 = (t.flags13 & ^uint8(0xf)) | ((v & 0xf) << 0)
	return true
}
func (t *AttributeType) Visit(v VisitorKEYKW) {
	v.Visit(v, "Option", (func() uint8 {
		if t.Option() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Transitive", (func() uint8 {
		if t.Transitive() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Partial", (func() uint8 {
		if t.Partial() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Extended", (func() uint8 {
		if t.Extended() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved", t.Reserved())
	v.Visit(v, "Code", &t.Code)
}
func (t *AttributeType) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *AttributeType) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags13)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags13: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Code)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Code: %w", err)
	}
	return nil
}
func (t *AttributeType) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *AttributeType) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *AttributeType) Read(r io.Reader) (err error) {
	tmpflags13 := [1]byte{}
	n_flags13, err := io.ReadFull(r, tmpflags13[:])
	if err != nil {
		return fmt.Errorf("read flags13: expect 1 byte but read %d bytes: %w", n_flags13, err)
	}
	t.flags13 = uint8(tmpflags13[0])
	tmpCode := [1]byte{}
	n_Code, err := io.ReadFull(r, tmpCode[:])
	if err != nil {
		return fmt.Errorf("read Code: expect 1 byte but read %d bytes: %w", n_Code, err)
	}
	t.Code = AttributeCode(tmpCode[0])
	return nil
}

func (t *AttributeType) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *AttributeType) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode AttributeType: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NetWorkReachabilityInfo) SetPrefix(v []uint8) bool {
	if len(v) > int(^uint8(0)) {
		return false
	}
	t.Prefixlen = uint8(len(v))
	t.Prefix = v
	return true
}
func (t *NetWorkReachabilityInfo) Visit(v VisitorKEYKW) {
	v.Visit(v, "Prefixlen", &t.Prefixlen)
	v.Visit(v, "Prefix", &t.Prefix)
}
func (t *NetWorkReachabilityInfo) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *NetWorkReachabilityInfo) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Prefixlen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Prefixlen: %w", err)
	}
	len_Prefix := int(t.Prefixlen)
	if len(t.Prefix) != len_Prefix {
		return fmt.Errorf("encode Prefix: expect %d bytes but got %d bytes", len_Prefix, len(t.Prefix))
	}
	if n, err := w.Write(t.Prefix); err != nil || n != len(t.Prefix) {
		return fmt.Errorf("encode Prefix: %w", err)
	}
	return nil
}
func (t *NetWorkReachabilityInfo) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NetWorkReachabilityInfo) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NetWorkReachabilityInfo) Read(r io.Reader) (err error) {
	tmpPrefixlen := [1]byte{}
	n_Prefixlen, err := io.ReadFull(r, tmpPrefixlen[:])
	if err != nil {
		return fmt.Errorf("read Prefixlen: expect 1 byte but read %d bytes: %w", n_Prefixlen, err)
	}
	t.Prefixlen = uint8(tmpPrefixlen[0])
	len_Prefix := int(t.Prefixlen)
	if len_Prefix != 0 {
		tmpPrefix := make([]byte, len_Prefix)
		n_Prefix, err := io.ReadFull(r, tmpPrefix[:])
		if err != nil {
			return fmt.Errorf("read Prefix: expect %d bytes but read %d bytes: %w", len_Prefix, n_Prefix, err)
		}
		t.Prefix = tmpPrefix[:]
	} else {
		t.Prefix = nil
	}
	return nil
}

func (t *NetWorkReachabilityInfo) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NetWorkReachabilityInfo) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NetWorkReachabilityInfo: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Notification) Visit(v VisitorKEYKW) {
	v.Visit(v, "Code", &t.Code)
	v.Visit(v, "Subcode", &t.Subcode)
	v.Visit(v, "Data", &t.Data)
}
func (t *Notification) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Notification) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Code)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Code: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Subcode)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Subcode: %w", err)
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Notification) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Notification) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Notification) Read(r io.Reader) (err error) {
	tmpCode := [1]byte{}
	n_Code, err := io.ReadFull(r, tmpCode[:])
	if err != nil {
		return fmt.Errorf("read Code: expect 1 byte but read %d bytes: %w", n_Code, err)
	}
	t.Code = uint8(tmpCode[0])
	tmpSubcode := [1]byte{}
	n_Subcode, err := io.ReadFull(r, tmpSubcode[:])
	if err != nil {
		return fmt.Errorf("read Subcode: expect 1 byte but read %d bytes: %w", n_Subcode, err)
	}
	t.Subcode = uint8(tmpSubcode[0])
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	return nil
}

func (t *Notification) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Notification) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Notification: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Oui) High() uint8 {
	return ((t.flags14 & 0xfc) >> 2)
}
func (t *Oui) SetHigh(v uint8) bool {
	if v > 63 {
		return false
	}
	t.flags14 = (t.flags14 & ^uint8(0xfc)) | ((v & 0x3f) << 2)
	return true
}
func (t *Oui) Local() bool {
	return ((t.flags14 & 0x02) >> 1) == 1
}
func (t *Oui) SetLocal(v bool) {
	if v {
		t.flags14 |= uint8(0x2)
	} else {
		t.flags14 &= ^uint8(0x2)
	}
}
func (t *Oui) Multicast() bool {
	return ((t.flags14 & 0x01) >> 0) == 1
}
func (t *Oui) SetMulticast(v bool) {
	if v {
		t.flags14 |= uint8(0x1)
	} else {
		t.flags14 &= ^uint8(0x1)
	}
}
func (t *Oui) Visit(v VisitorKEYKW) {
	v.Visit(v, "High", t.High())
	v.Visit(v, "Local", (func() uint8 {
		if t.Local() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Multicast", (func() uint8 {
		if t.Multicast() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Low", &t.Low)
}
func (t *Oui) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Oui) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags14)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags14: %w", err)
	}
	if n, err := w.Write(t.Low[:]); err != nil || n != len(t.Low) {
		return fmt.Errorf("encode Low: %w", err)
	}
	return nil
}
func (t *Oui) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 3))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Oui) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Oui) Read(r io.Reader) (err error) {
	tmpflags14 := [1]byte{}
	n_flags14, err := io.ReadFull(r, tmpflags14[:])
	if err != nil {
		return fmt.Errorf("read flags14: expect 1 byte but read %d bytes: %w", n_flags14, err)
	}
	t.flags14 = uint8(tmpflags14[0])
	n_Low, err := io.ReadFull(r, t.Low[:])
	if err != nil {
		return fmt.Errorf("read Low: expect %d bytes but read %d bytes: %w", 2, n_Low, err)
	}
	return nil
}

func (t *Oui) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Oui) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Oui: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_17_t) isunion15_() {}
func (t *union_18_t) isunion15_() {}
func (t *EthernetFrame) DummyEtherType() *uint16 {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		return nil
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union15_.(*union_18_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union15_.(*union_18_t).DummyEtherType)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetDummyEtherType(v uint16) bool {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		return false
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union15_.(*union_18_t); !ok {
			t.union15_ = &union_18_t{}
		}
		t.union15_.(*union_18_t).DummyEtherType = uint16(v)
		return true
	}
	return false
}
func (t *EthernetFrame) EtherType2() *uint16 {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		if _, ok := t.union15_.(*union_17_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union15_.(*union_17_t).EtherType2)
		return &tmp
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union15_.(*union_18_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union15_.(*union_18_t).EtherType2)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetEtherType2(v uint16) bool {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		if _, ok := t.union15_.(*union_17_t); !ok {
			t.union15_ = &union_17_t{}
		}
		t.union15_.(*union_17_t).EtherType2 = uint16(v)
		return true
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union15_.(*union_18_t); !ok {
			t.union15_ = &union_18_t{}
		}
		t.union15_.(*union_18_t).EtherType2 = uint16(v)
		return true
	}
	return false
}
func (t *EthernetFrame) ServiceVlanTag() *uint16 {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		return nil
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union15_.(*union_18_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union15_.(*union_18_t).ServiceVlanTag)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetServiceVlanTag(v uint16) bool {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		return false
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union15_.(*union_18_t); !ok {
			t.union15_ = &union_18_t{}
		}
		t.union15_.(*union_18_t).ServiceVlanTag = uint16(v)
		return true
	}
	return false
}
func (t *EthernetFrame) VlanTag() *uint16 {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		if _, ok := t.union15_.(*union_17_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union15_.(*union_17_t).VlanTag)
		return &tmp
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union15_.(*union_18_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union15_.(*union_18_t).VlanTag)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetVlanTag(v uint16) bool {
	if true == (t.EtherType == uint16(EtherType_Vlan)) {
		if _, ok := t.union15_.(*union_17_t); !ok {
			t.union15_ = &union_17_t{}
		}
		t.union15_.(*union_17_t).VlanTag = uint16(v)
		return true
	} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
		if _, ok := t.union15_.(*union_18_t); !ok {
			t.union15_ = &union_18_t{}
		}
		t.union15_.(*union_18_t).VlanTag = uint16(v)
		return true
	}
	return false
}
func (t *union_21_t) isunion19_() {}
func (t *union_22_t) isunion19_() {}
func (t *EthernetFrame) Data() *[]uint8 {
	Len := (func() uint16 {
		if func() bool {
			if true == (t.EtherType == uint16(EtherType_Vlan)) {
				return true
			} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
				return true
			}
			return false
		}() {
			return uint16((*t.EtherType2()))
		} else {
			return uint16(t.EtherType)
		}
	}())
	if true == (Len >= 0x600) {
		if _, ok := t.union19_.(*union_21_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union19_.(*union_21_t).Data)
		return &tmp
	} else if true {
		if _, ok := t.union19_.(*union_22_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union19_.(*union_22_t).Data)
		return &tmp
	}
	return nil
}
func (t *EthernetFrame) SetData(v []uint8) bool {
	Len := (func() uint16 {
		if func() bool {
			if true == (t.EtherType == uint16(EtherType_Vlan)) {
				return true
			} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
				return true
			}
			return false
		}() {
			return uint16((*t.EtherType2()))
		} else {
			return uint16(t.EtherType)
		}
	}())
	if true == (Len >= 0x600) {
		if _, ok := t.union19_.(*union_21_t); !ok {
			t.union19_ = &union_21_t{}
		}
		t.union19_.(*union_21_t).Data = []uint8(v)
		return true
	} else if true {
		if _, ok := t.union19_.(*union_22_t); !ok {
			t.union19_ = &union_22_t{}
		}
		t.union19_.(*union_22_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *EthernetFrame) Visit(v VisitorKEYKW) {
	v.Visit(v, "DstMac", &t.DstMac)
	v.Visit(v, "SrcMac", &t.SrcMac)
	v.Visit(v, "EtherType", &t.EtherType)
	v.Visit(v, "DummyEtherType", (t.DummyEtherType()))
	v.Visit(v, "EtherType2", (t.EtherType2()))
	v.Visit(v, "ServiceVlanTag", (t.ServiceVlanTag()))
	v.Visit(v, "VlanTag", (t.VlanTag()))
	v.Visit(v, "Data", (t.Data()))
}
func (t *EthernetFrame) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *EthernetFrame) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.DstMac[:]); err != nil || n != len(t.DstMac) {
		return fmt.Errorf("encode DstMac: %w", err)
	}
	if n, err := w.Write(t.SrcMac[:]); err != nil || n != len(t.SrcMac) {
		return fmt.Errorf("encode SrcMac: %w", err)
	}
	tmp23 := [2]byte{}
	binary.BigEndian.PutUint16(tmp23[:], uint16(t.EtherType))
	if n, err := w.Write(tmp23[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.EtherType: %w", err)
	}
	if t.EtherType == uint16(EtherType_Vlan) {
		if _, ok := t.union15_.(*union_17_t); !ok {
			return fmt.Errorf("encode t.union15_: union is not set to union_17_t")
		}
		tmp24 := [2]byte{}
		binary.BigEndian.PutUint16(tmp24[:], uint16(t.union15_.(*union_17_t).VlanTag))
		if n, err := w.Write(tmp24[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union15_.(*union_17_t).VlanTag: %w", err)
		}
		tmp25 := [2]byte{}
		binary.BigEndian.PutUint16(tmp25[:], uint16(t.union15_.(*union_17_t).EtherType2))
		if n, err := w.Write(tmp25[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union15_.(*union_17_t).EtherType2: %w", err)
		}
	} else if t.EtherType == uint16(EtherType_ServiceVlen) {
		if _, ok := t.union15_.(*union_18_t); !ok {
			return fmt.Errorf("encode t.union15_: union is not set to union_18_t")
		}
		tmp26 := [2]byte{}
		binary.BigEndian.PutUint16(tmp26[:], uint16(t.union15_.(*union_18_t).ServiceVlanTag))
		if n, err := w.Write(tmp26[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union15_.(*union_18_t).ServiceVlanTag: %w", err)
		}
		tmp27 := [2]byte{}
		binary.BigEndian.PutUint16(tmp27[:], uint16(t.union15_.(*union_18_t).DummyEtherType))
		if n, err := w.Write(tmp27[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union15_.(*union_18_t).DummyEtherType: %w", err)
		}
		tmp28 := [2]byte{}
		binary.BigEndian.PutUint16(tmp28[:], uint16(t.union15_.(*union_18_t).VlanTag))
		if n, err := w.Write(tmp28[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union15_.(*union_18_t).VlanTag: %w", err)
		}
		tmp29 := [2]byte{}
		binary.BigEndian.PutUint16(tmp29[:], uint16(t.union15_.(*union_18_t).EtherType2))
		if n, err := w.Write(tmp29[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union15_.(*union_18_t).EtherType2: %w", err)
		}
	}
	Len := (func() uint16 {
		if func() bool {
			if true == (t.EtherType == uint16(EtherType_Vlan)) {
				return true
			} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
				return true
			}
			return false
		}() {
			return uint16((*t.EtherType2()))
		} else {
			return uint16(t.EtherType)
		}
	}())
	if Len >= 0x600 {
		if _, ok := t.union19_.(*union_21_t); !ok {
			return fmt.Errorf("encode t.union19_: union is not set to union_21_t")
		}
		if n, err := w.Write(t.union19_.(*union_21_t).Data); err != nil || n != len(t.union19_.(*union_21_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	} else {
		if _, ok := t.union19_.(*union_22_t); !ok {
			return fmt.Errorf("encode t.union19_: union is not set to union_22_t")
		}
		len_Data := int(Len)
		if len(t.union19_.(*union_22_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union19_.(*union_22_t).Data))
		}
		if n, err := w.Write(t.union19_.(*union_22_t).Data); err != nil || n != len(t.union19_.(*union_22_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *EthernetFrame) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 14))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *EthernetFrame) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *EthernetFrame) Read(r io.Reader) (err error) {
	n_DstMac, err := io.ReadFull(r, t.DstMac[:])
	if err != nil {
		return fmt.Errorf("read DstMac: expect %d bytes but read %d bytes: %w", 6, n_DstMac, err)
	}
	n_SrcMac, err := io.ReadFull(r, t.SrcMac[:])
	if err != nil {
		return fmt.Errorf("read SrcMac: expect %d bytes but read %d bytes: %w", 6, n_SrcMac, err)
	}
	tmpEtherType := [2]byte{}
	n_EtherType, err := io.ReadFull(r, tmpEtherType[:])
	if err != nil {
		return fmt.Errorf("read EtherType: expect 2 bytes but read %d bytes: %w", n_EtherType, err)
	}
	t.EtherType = uint16(binary.BigEndian.Uint16(tmpEtherType[:]))
	if t.EtherType == uint16(EtherType_Vlan) {
		t.union15_ = &union_17_t{}
		tmpVlanTag := [2]byte{}
		n_VlanTag, err := io.ReadFull(r, tmpVlanTag[:])
		if err != nil {
			return fmt.Errorf("read VlanTag: expect 2 bytes but read %d bytes: %w", n_VlanTag, err)
		}
		t.union15_.(*union_17_t).VlanTag = uint16(binary.BigEndian.Uint16(tmpVlanTag[:]))
		tmpEtherType2 := [2]byte{}
		n_EtherType2, err := io.ReadFull(r, tmpEtherType2[:])
		if err != nil {
			return fmt.Errorf("read EtherType2: expect 2 bytes but read %d bytes: %w", n_EtherType2, err)
		}
		t.union15_.(*union_17_t).EtherType2 = uint16(binary.BigEndian.Uint16(tmpEtherType2[:]))
	} else if t.EtherType == uint16(EtherType_ServiceVlen) {
		t.union15_ = &union_18_t{}
		tmpServiceVlanTag := [2]byte{}
		n_ServiceVlanTag, err := io.ReadFull(r, tmpServiceVlanTag[:])
		if err != nil {
			return fmt.Errorf("read ServiceVlanTag: expect 2 bytes but read %d bytes: %w", n_ServiceVlanTag, err)
		}
		t.union15_.(*union_18_t).ServiceVlanTag = uint16(binary.BigEndian.Uint16(tmpServiceVlanTag[:]))
		tmpDummyEtherType := [2]byte{}
		n_DummyEtherType, err := io.ReadFull(r, tmpDummyEtherType[:])
		if err != nil {
			return fmt.Errorf("read DummyEtherType: expect 2 bytes but read %d bytes: %w", n_DummyEtherType, err)
		}
		t.union15_.(*union_18_t).DummyEtherType = uint16(binary.BigEndian.Uint16(tmpDummyEtherType[:]))
		tmpVlanTag := [2]byte{}
		n_VlanTag, err := io.ReadFull(r, tmpVlanTag[:])
		if err != nil {
			return fmt.Errorf("read VlanTag: expect 2 bytes but read %d bytes: %w", n_VlanTag, err)
		}
		t.union15_.(*union_18_t).VlanTag = uint16(binary.BigEndian.Uint16(tmpVlanTag[:]))
		tmpEtherType2 := [2]byte{}
		n_EtherType2, err := io.ReadFull(r, tmpEtherType2[:])
		if err != nil {
			return fmt.Errorf("read EtherType2: expect 2 bytes but read %d bytes: %w", n_EtherType2, err)
		}
		t.union15_.(*union_18_t).EtherType2 = uint16(binary.BigEndian.Uint16(tmpEtherType2[:]))
	}
	Len := (func() uint16 {
		if func() bool {
			if true == (t.EtherType == uint16(EtherType_Vlan)) {
				return true
			} else if true == (t.EtherType == uint16(EtherType_ServiceVlen)) {
				return true
			}
			return false
		}() {
			return uint16((*t.EtherType2()))
		} else {
			return uint16(t.EtherType)
		}
	}())
	if Len >= 0x600 {
		t.union19_ = &union_21_t{}
		bytes_buf_Data := &bytes.Buffer{}
		if _, err := io.Copy(bytes_buf_Data, r); err != nil {
			return err
		}
		t.union19_.(*union_21_t).Data = bytes_buf_Data.Bytes()
	} else {
		t.union19_ = &union_22_t{}
		len_Data := int(Len)
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union19_.(*union_22_t).Data = tmpData[:]
		} else {
			t.union19_.(*union_22_t).Data = nil
		}
	}
	return nil
}

func (t *EthernetFrame) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *EthernetFrame) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode EthernetFrame: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Tcpflags) Cwr() bool {
	return ((t.flags30 & 0x80) >> 7) == 1
}
func (t *Tcpflags) SetCwr(v bool) {
	if v {
		t.flags30 |= uint8(0x80)
	} else {
		t.flags30 &= ^uint8(0x80)
	}
}
func (t *Tcpflags) Ece() bool {
	return ((t.flags30 & 0x40) >> 6) == 1
}
func (t *Tcpflags) SetEce(v bool) {
	if v {
		t.flags30 |= uint8(0x40)
	} else {
		t.flags30 &= ^uint8(0x40)
	}
}
func (t *Tcpflags) Urg() bool {
	return ((t.flags30 & 0x20) >> 5) == 1
}
func (t *Tcpflags) SetUrg(v bool) {
	if v {
		t.flags30 |= uint8(0x20)
	} else {
		t.flags30 &= ^uint8(0x20)
	}
}
func (t *Tcpflags) Ack() bool {
	return ((t.flags30 & 0x10) >> 4) == 1
}
func (t *Tcpflags) SetAck(v bool) {
	if v {
		t.flags30 |= uint8(0x10)
	} else {
		t.flags30 &= ^uint8(0x10)
	}
}
func (t *Tcpflags) Psh() bool {
	return ((t.flags30 & 0x08) >> 3) == 1
}
func (t *Tcpflags) SetPsh(v bool) {
	if v {
		t.flags30 |= uint8(0x8)
	} else {
		t.flags30 &= ^uint8(0x8)
	}
}
func (t *Tcpflags) Rst() bool {
	return ((t.flags30 & 0x04) >> 2) == 1
}
func (t *Tcpflags) SetRst(v bool) {
	if v {
		t.flags30 |= uint8(0x4)
	} else {
		t.flags30 &= ^uint8(0x4)
	}
}
func (t *Tcpflags) Syn() bool {
	return ((t.flags30 & 0x02) >> 1) == 1
}
func (t *Tcpflags) SetSyn(v bool) {
	if v {
		t.flags30 |= uint8(0x2)
	} else {
		t.flags30 &= ^uint8(0x2)
	}
}
func (t *Tcpflags) Fin() bool {
	return ((t.flags30 & 0x01) >> 0) == 1
}
func (t *Tcpflags) SetFin(v bool) {
	if v {
		t.flags30 |= uint8(0x1)
	} else {
		t.flags30 &= ^uint8(0x1)
	}
}
func (t *Tcpflags) Visit(v VisitorKEYKW) {
	v.Visit(v, "Cwr", (func() uint8 {
		if t.Cwr() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Ece", (func() uint8 {
		if t.Ece() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Urg", (func() uint8 {
		if t.Urg() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Ack", (func() uint8 {
		if t.Ack() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Psh", (func() uint8 {
		if t.Psh() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Rst", (func() uint8 {
		if t.Rst() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Syn", (func() uint8 {
		if t.Syn() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Fin", (func() uint8 {
		if t.Fin() {
			return 1
		} else {
			return 0
		}
	}()))
}
func (t *Tcpflags) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Tcpflags) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags30)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags30: %w", err)
	}
	return nil
}
func (t *Tcpflags) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Tcpflags) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Tcpflags) Read(r io.Reader) (err error) {
	tmpflags30 := [1]byte{}
	n_flags30, err := io.ReadFull(r, tmpflags30[:])
	if err != nil {
		return fmt.Errorf("read flags30: expect 1 byte but read %d bytes: %w", n_flags30, err)
	}
	t.flags30 = uint8(tmpflags30[0])
	return nil
}

func (t *Tcpflags) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Tcpflags) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Tcpflags: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SackBlock) Visit(v VisitorKEYKW) {
	v.Visit(v, "Left", &t.Left)
	v.Visit(v, "Right", &t.Right)
}
func (t *SackBlock) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *SackBlock) Write(w io.Writer) (err error) {
	tmp31 := [4]byte{}
	binary.BigEndian.PutUint32(tmp31[:], uint32(t.Left))
	if n, err := w.Write(tmp31[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Left: %w", err)
	}
	tmp32 := [4]byte{}
	binary.BigEndian.PutUint32(tmp32[:], uint32(t.Right))
	if n, err := w.Write(tmp32[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Right: %w", err)
	}
	return nil
}
func (t *SackBlock) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SackBlock) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SackBlock) Read(r io.Reader) (err error) {
	tmpLeft := [4]byte{}
	n_Left, err := io.ReadFull(r, tmpLeft[:])
	if err != nil {
		return fmt.Errorf("read Left: expect 4 bytes but read %d bytes: %w", n_Left, err)
	}
	t.Left = uint32(binary.BigEndian.Uint32(tmpLeft[:]))
	tmpRight := [4]byte{}
	n_Right, err := io.ReadFull(r, tmpRight[:])
	if err != nil {
		return fmt.Errorf("read Right: expect 4 bytes but read %d bytes: %w", n_Right, err)
	}
	t.Right = uint32(binary.BigEndian.Uint32(tmpRight[:]))
	return nil
}

func (t *SackBlock) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SackBlock) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SackBlock: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Timestamp) Visit(v VisitorKEYKW) {
	v.Visit(v, "Value", &t.Value)
	v.Visit(v, "EchoReply", &t.EchoReply)
}
func (t *Timestamp) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Timestamp) Write(w io.Writer) (err error) {
	tmp33 := [4]byte{}
	binary.BigEndian.PutUint32(tmp33[:], uint32(t.Value))
	if n, err := w.Write(tmp33[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Value: %w", err)
	}
	tmp34 := [4]byte{}
	binary.BigEndian.PutUint32(tmp34[:], uint32(t.EchoReply))
	if n, err := w.Write(tmp34[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.EchoReply: %w", err)
	}
	return nil
}
func (t *Timestamp) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Timestamp) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Timestamp) Read(r io.Reader) (err error) {
	tmpValue := [4]byte{}
	n_Value, err := io.ReadFull(r, tmpValue[:])
	if err != nil {
		return fmt.Errorf("read Value: expect 4 bytes but read %d bytes: %w", n_Value, err)
	}
	t.Value = uint32(binary.BigEndian.Uint32(tmpValue[:]))
	tmpEchoReply := [4]byte{}
	n_EchoReply, err := io.ReadFull(r, tmpEchoReply[:])
	if err != nil {
		return fmt.Errorf("read EchoReply: expect 4 bytes but read %d bytes: %w", n_EchoReply, err)
	}
	t.EchoReply = uint32(binary.BigEndian.Uint32(tmpEchoReply[:]))
	return nil
}

func (t *Timestamp) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Timestamp) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Timestamp: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Icmpheader) Visit(v VisitorKEYKW) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Code", &t.Code)
	v.Visit(v, "Checksum", &t.Checksum)
}
func (t *Icmpheader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Icmpheader) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Code)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Code: %w", err)
	}
	tmp35 := [2]byte{}
	binary.BigEndian.PutUint16(tmp35[:], uint16(t.Checksum))
	if n, err := w.Write(tmp35[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Checksum: %w", err)
	}
	return nil
}
func (t *Icmpheader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Icmpheader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Icmpheader) Read(r io.Reader) (err error) {
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint8(tmpType[0])
	tmpCode := [1]byte{}
	n_Code, err := io.ReadFull(r, tmpCode[:])
	if err != nil {
		return fmt.Errorf("read Code: expect 1 byte but read %d bytes: %w", n_Code, err)
	}
	t.Code = uint8(tmpCode[0])
	tmpChecksum := [2]byte{}
	n_Checksum, err := io.ReadFull(r, tmpChecksum[:])
	if err != nil {
		return fmt.Errorf("read Checksum: expect 2 bytes but read %d bytes: %w", n_Checksum, err)
	}
	t.Checksum = uint16(binary.BigEndian.Uint16(tmpChecksum[:]))
	return nil
}

func (t *Icmpheader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Icmpheader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Icmpheader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *IcmptimeExceeded) Visit(v VisitorKEYKW) {
	v.Visit(v, "Unused", &t.Unused)
	v.Visit(v, "Data", &t.Data)
}
func (t *IcmptimeExceeded) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *IcmptimeExceeded) Write(w io.Writer) (err error) {
	tmp36 := [4]byte{}
	binary.BigEndian.PutUint32(tmp36[:], uint32(t.Unused))
	if n, err := w.Write(tmp36[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Unused: %w", err)
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *IcmptimeExceeded) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *IcmptimeExceeded) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *IcmptimeExceeded) Read(r io.Reader) (err error) {
	tmpUnused := [4]byte{}
	n_Unused, err := io.ReadFull(r, tmpUnused[:])
	if err != nil {
		return fmt.Errorf("read Unused: expect 4 bytes but read %d bytes: %w", n_Unused, err)
	}
	t.Unused = uint32(binary.BigEndian.Uint32(tmpUnused[:]))
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	return nil
}

func (t *IcmptimeExceeded) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *IcmptimeExceeded) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode IcmptimeExceeded: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Icmpecho) Visit(v VisitorKEYKW) {
	v.Visit(v, "Id", &t.Id)
	v.Visit(v, "Seq", &t.Seq)
	v.Visit(v, "Data", &t.Data)
}
func (t *Icmpecho) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Icmpecho) Write(w io.Writer) (err error) {
	tmp37 := [2]byte{}
	binary.BigEndian.PutUint16(tmp37[:], uint16(t.Id))
	if n, err := w.Write(tmp37[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Id: %w", err)
	}
	tmp38 := [2]byte{}
	binary.BigEndian.PutUint16(tmp38[:], uint16(t.Seq))
	if n, err := w.Write(tmp38[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Seq: %w", err)
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Icmpecho) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Icmpecho) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Icmpecho) Read(r io.Reader) (err error) {
	tmpId := [2]byte{}
	n_Id, err := io.ReadFull(r, tmpId[:])
	if err != nil {
		return fmt.Errorf("read Id: expect 2 bytes but read %d bytes: %w", n_Id, err)
	}
	t.Id = uint16(binary.BigEndian.Uint16(tmpId[:]))
	tmpSeq := [2]byte{}
	n_Seq, err := io.ReadFull(r, tmpSeq[:])
	if err != nil {
		return fmt.Errorf("read Seq: expect 2 bytes but read %d bytes: %w", n_Seq, err)
	}
	t.Seq = uint16(binary.BigEndian.Uint16(tmpSeq[:]))
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	return nil
}

func (t *Icmpecho) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Icmpecho) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Icmpecho: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *IcmpdestinationUnreachable) Visit(v VisitorKEYKW) {
	v.Visit(v, "Unused", &t.Unused)
	v.Visit(v, "NextHopMtu", &t.NextHopMtu)
	v.Visit(v, "Data", &t.Data)
}
func (t *IcmpdestinationUnreachable) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *IcmpdestinationUnreachable) Write(w io.Writer) (err error) {
	tmp39 := [2]byte{}
	binary.BigEndian.PutUint16(tmp39[:], uint16(t.Unused))
	if n, err := w.Write(tmp39[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Unused: %w", err)
	}
	tmp40 := [2]byte{}
	binary.BigEndian.PutUint16(tmp40[:], uint16(t.NextHopMtu))
	if n, err := w.Write(tmp40[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.NextHopMtu: %w", err)
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *IcmpdestinationUnreachable) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *IcmpdestinationUnreachable) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *IcmpdestinationUnreachable) Read(r io.Reader) (err error) {
	tmpUnused := [2]byte{}
	n_Unused, err := io.ReadFull(r, tmpUnused[:])
	if err != nil {
		return fmt.Errorf("read Unused: expect 2 bytes but read %d bytes: %w", n_Unused, err)
	}
	t.Unused = uint16(binary.BigEndian.Uint16(tmpUnused[:]))
	tmpNextHopMtu := [2]byte{}
	n_NextHopMtu, err := io.ReadFull(r, tmpNextHopMtu[:])
	if err != nil {
		return fmt.Errorf("read NextHopMtu: expect 2 bytes but read %d bytes: %w", n_NextHopMtu, err)
	}
	t.NextHopMtu = uint16(binary.BigEndian.Uint16(tmpNextHopMtu[:]))
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	return nil
}

func (t *IcmpdestinationUnreachable) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *IcmpdestinationUnreachable) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode IcmpdestinationUnreachable: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *IcmppacketTooBig) Visit(v VisitorKEYKW) {
	v.Visit(v, "Unused", &t.Unused)
	v.Visit(v, "Mtu", &t.Mtu)
	v.Visit(v, "Data", &t.Data)
}
func (t *IcmppacketTooBig) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *IcmppacketTooBig) Write(w io.Writer) (err error) {
	tmp41 := [4]byte{}
	binary.BigEndian.PutUint32(tmp41[:], uint32(t.Unused))
	if n, err := w.Write(tmp41[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Unused: %w", err)
	}
	tmp42 := [4]byte{}
	binary.BigEndian.PutUint32(tmp42[:], uint32(t.Mtu))
	if n, err := w.Write(tmp42[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Mtu: %w", err)
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *IcmppacketTooBig) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *IcmppacketTooBig) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *IcmppacketTooBig) Read(r io.Reader) (err error) {
	tmpUnused := [4]byte{}
	n_Unused, err := io.ReadFull(r, tmpUnused[:])
	if err != nil {
		return fmt.Errorf("read Unused: expect 4 bytes but read %d bytes: %w", n_Unused, err)
	}
	t.Unused = uint32(binary.BigEndian.Uint32(tmpUnused[:]))
	tmpMtu := [4]byte{}
	n_Mtu, err := io.ReadFull(r, tmpMtu[:])
	if err != nil {
		return fmt.Errorf("read Mtu: expect 4 bytes but read %d bytes: %w", n_Mtu, err)
	}
	t.Mtu = uint32(binary.BigEndian.Uint32(tmpMtu[:]))
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	return nil
}

func (t *IcmppacketTooBig) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *IcmppacketTooBig) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode IcmppacketTooBig: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Icmpv6ParameterProblem) Visit(v VisitorKEYKW) {
	v.Visit(v, "Pointer", &t.Pointer)
	v.Visit(v, "Data", &t.Data)
}
func (t *Icmpv6ParameterProblem) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Icmpv6ParameterProblem) Write(w io.Writer) (err error) {
	tmp43 := [4]byte{}
	binary.BigEndian.PutUint32(tmp43[:], uint32(t.Pointer))
	if n, err := w.Write(tmp43[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Pointer: %w", err)
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Icmpv6ParameterProblem) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Icmpv6ParameterProblem) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Icmpv6ParameterProblem) Read(r io.Reader) (err error) {
	tmpPointer := [4]byte{}
	n_Pointer, err := io.ReadFull(r, tmpPointer[:])
	if err != nil {
		return fmt.Errorf("read Pointer: expect 4 bytes but read %d bytes: %w", n_Pointer, err)
	}
	t.Pointer = uint32(binary.BigEndian.Uint32(tmpPointer[:]))
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	return nil
}

func (t *Icmpv6ParameterProblem) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Icmpv6ParameterProblem) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Icmpv6ParameterProblem: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *FloatMaximumResponseCode) One() bool {
	return ((t.flags44 & 0x8000) >> 15) == 1
}
func (t *FloatMaximumResponseCode) SetOne(v bool) {
	if v {
		t.flags44 |= uint16(0x8000)
	} else {
		t.flags44 &= ^uint16(0x8000)
	}
}
func (t *FloatMaximumResponseCode) Exp() uint16 {
	return ((t.flags44 & 0x7000) >> 12)
}
func (t *FloatMaximumResponseCode) SetExp(v uint16) bool {
	if v > 7 {
		return false
	}
	t.flags44 = (t.flags44 & ^uint16(0x7000)) | ((v & 0x7) << 12)
	return true
}
func (t *FloatMaximumResponseCode) Mant() uint16 {
	return ((t.flags44 & 0x0fff) >> 0)
}
func (t *FloatMaximumResponseCode) SetMant(v uint16) bool {
	if v > 4095 {
		return false
	}
	t.flags44 = (t.flags44 & ^uint16(0xfff)) | ((v & 0xfff) << 0)
	return true
}
func (t *FloatMaximumResponseCode) Visit(v VisitorKEYKW) {
	v.Visit(v, "One", (func() uint16 {
		if t.One() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Exp", t.Exp())
	v.Visit(v, "Mant", t.Mant())
}
func (t *FloatMaximumResponseCode) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *FloatMaximumResponseCode) Write(w io.Writer) (err error) {
	tmp45 := [2]byte{}
	binary.BigEndian.PutUint16(tmp45[:], uint16(t.flags44))
	if n, err := w.Write(tmp45[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.flags44: %w", err)
	}
	return nil
}
func (t *FloatMaximumResponseCode) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *FloatMaximumResponseCode) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *FloatMaximumResponseCode) Read(r io.Reader) (err error) {
	tmpflags44 := [2]byte{}
	n_flags44, err := io.ReadFull(r, tmpflags44[:])
	if err != nil {
		return fmt.Errorf("read flags44: expect 2 bytes but read %d bytes: %w", n_flags44, err)
	}
	t.flags44 = uint16(binary.BigEndian.Uint16(tmpflags44[:]))
	return nil
}

func (t *FloatMaximumResponseCode) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *FloatMaximumResponseCode) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode FloatMaximumResponseCode: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *FloatQqic) One() bool {
	return ((t.flags46 & 0x80) >> 7) == 1
}
func (t *FloatQqic) SetOne(v bool) {
	if v {
		t.flags46 |= uint8(0x80)
	} else {
		t.flags46 &= ^uint8(0x80)
	}
}
func (t *FloatQqic) Exp() uint8 {
	return ((t.flags46 & 0x70) >> 4)
}
func (t *FloatQqic) SetExp(v uint8) bool {
	if v > 7 {
		return false
	}
	t.flags46 = (t.flags46 & ^uint8(0x70)) | ((v & 0x7) << 4)
	return true
}
func (t *FloatQqic) Mant() uint8 {
	return ((t.flags46 & 0x0f) >> 0)
}
func (t *FloatQqic) SetMant(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags46 = (t.flags46 & ^uint8(0xf)) | ((v & 0xf) << 0)
	return true
}
func (t *FloatQqic) Visit(v VisitorKEYKW) {
	v.Visit(v, "One", (func() uint8 {
		if t.One() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Exp", t.Exp())
	v.Visit(v, "Mant", t.Mant())
}
func (t *FloatQqic) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *FloatQqic) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags46)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags46: %w", err)
	}
	return nil
}
func (t *FloatQqic) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *FloatQqic) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *FloatQqic) Read(r io.Reader) (err error) {
	tmpflags46 := [1]byte{}
	n_flags46, err := io.ReadFull(r, tmpflags46[:])
	if err != nil {
		return fmt.Errorf("read flags46: expect 1 byte but read %d bytes: %w", n_flags46, err)
	}
	t.flags46 = uint8(tmpflags46[0])
	return nil
}

func (t *FloatQqic) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *FloatQqic) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode FloatQqic: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *MulticastListenerQuery) Reserved2() uint8 {
	return ((t.flags47 & 0xf0) >> 4)
}
func (t *MulticastListenerQuery) SetReserved2(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags47 = (t.flags47 & ^uint8(0xf0)) | ((v & 0xf) << 4)
	return true
}
func (t *MulticastListenerQuery) SuppressRouterProcessing() bool {
	return ((t.flags47 & 0x08) >> 3) == 1
}
func (t *MulticastListenerQuery) SetSuppressRouterProcessing(v bool) {
	if v {
		t.flags47 |= uint8(0x8)
	} else {
		t.flags47 &= ^uint8(0x8)
	}
}
func (t *MulticastListenerQuery) QueriesRobustnessVar() uint8 {
	return ((t.flags47 & 0x07) >> 0)
}
func (t *MulticastListenerQuery) SetQueriesRobustnessVar(v uint8) bool {
	if v > 7 {
		return false
	}
	t.flags47 = (t.flags47 & ^uint8(0x7)) | ((v & 0x7) << 0)
	return true
}
func (t *MulticastListenerQuery) SetSourceAddr(v [][16]uint8) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.NumberOfSources = uint16(len(v))
	t.SourceAddr = v
	return true
}
func (t *MulticastListenerQuery) Visit(v VisitorKEYKW) {
	v.Visit(v, "MaxRespCode", &t.MaxRespCode)
	v.Visit(v, "Reserved1", &t.Reserved1)
	v.Visit(v, "McastAddr", &t.McastAddr)
	v.Visit(v, "Reserved2", t.Reserved2())
	v.Visit(v, "SuppressRouterProcessing", (func() uint8 {
		if t.SuppressRouterProcessing() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "QueriesRobustnessVar", t.QueriesRobustnessVar())
	v.Visit(v, "QuerierQueryInterval", &t.QuerierQueryInterval)
	v.Visit(v, "NumberOfSources", &t.NumberOfSources)
	v.Visit(v, "SourceAddr", &t.SourceAddr)
}
func (t *MulticastListenerQuery) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *MulticastListenerQuery) Write(w io.Writer) (err error) {
	tmp48 := [2]byte{}
	binary.BigEndian.PutUint16(tmp48[:], uint16(t.MaxRespCode))
	if n, err := w.Write(tmp48[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.MaxRespCode: %w", err)
	}
	tmp49 := [2]byte{}
	binary.BigEndian.PutUint16(tmp49[:], uint16(t.Reserved1))
	if n, err := w.Write(tmp49[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Reserved1: %w", err)
	}
	if n, err := w.Write(t.McastAddr[:]); err != nil || n != len(t.McastAddr) {
		return fmt.Errorf("encode McastAddr: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags47)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags47: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.QuerierQueryInterval)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.QuerierQueryInterval: %w", err)
	}
	tmp50 := [2]byte{}
	binary.BigEndian.PutUint16(tmp50[:], uint16(t.NumberOfSources))
	if n, err := w.Write(tmp50[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.NumberOfSources: %w", err)
	}
	len_SourceAddr := int(t.NumberOfSources)
	if len(t.SourceAddr) != len_SourceAddr {
		return fmt.Errorf("encode SourceAddr: expect %d but got %d for length", len_SourceAddr, len(t.SourceAddr))
	}
	for _, v := range t.SourceAddr {
		if n, err := w.Write(v[:]); err != nil || n != len(v) {
			return fmt.Errorf("encode SourceAddr: %w", err)
		}
	}
	return nil
}
func (t *MulticastListenerQuery) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 24))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *MulticastListenerQuery) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *MulticastListenerQuery) Read(r io.Reader) (err error) {
	tmpMaxRespCode := [2]byte{}
	n_MaxRespCode, err := io.ReadFull(r, tmpMaxRespCode[:])
	if err != nil {
		return fmt.Errorf("read MaxRespCode: expect 2 bytes but read %d bytes: %w", n_MaxRespCode, err)
	}
	t.MaxRespCode = uint16(binary.BigEndian.Uint16(tmpMaxRespCode[:]))
	tmpReserved1 := [2]byte{}
	n_Reserved1, err := io.ReadFull(r, tmpReserved1[:])
	if err != nil {
		return fmt.Errorf("read Reserved1: expect 2 bytes but read %d bytes: %w", n_Reserved1, err)
	}
	t.Reserved1 = uint16(binary.BigEndian.Uint16(tmpReserved1[:]))
	n_McastAddr, err := io.ReadFull(r, t.McastAddr[:])
	if err != nil {
		return fmt.Errorf("read McastAddr: expect %d bytes but read %d bytes: %w", 16, n_McastAddr, err)
	}
	tmpflags47 := [1]byte{}
	n_flags47, err := io.ReadFull(r, tmpflags47[:])
	if err != nil {
		return fmt.Errorf("read flags47: expect 1 byte but read %d bytes: %w", n_flags47, err)
	}
	t.flags47 = uint8(tmpflags47[0])
	tmpQuerierQueryInterval := [1]byte{}
	n_QuerierQueryInterval, err := io.ReadFull(r, tmpQuerierQueryInterval[:])
	if err != nil {
		return fmt.Errorf("read QuerierQueryInterval: expect 1 byte but read %d bytes: %w", n_QuerierQueryInterval, err)
	}
	t.QuerierQueryInterval = uint8(tmpQuerierQueryInterval[0])
	tmpNumberOfSources := [2]byte{}
	n_NumberOfSources, err := io.ReadFull(r, tmpNumberOfSources[:])
	if err != nil {
		return fmt.Errorf("read NumberOfSources: expect 2 bytes but read %d bytes: %w", n_NumberOfSources, err)
	}
	t.NumberOfSources = uint16(binary.BigEndian.Uint16(tmpNumberOfSources[:]))
	len_SourceAddr := int(t.NumberOfSources)
	for i_51 := 0; i_51 < len_SourceAddr; i_51++ {
		var tmp52_ [16]uint8
		n_SourceAddr, err := io.ReadFull(r, tmp52_[:])
		if err != nil {
			return fmt.Errorf("read SourceAddr: expect %d bytes but read %d bytes: %w", 16, n_SourceAddr, err)
		}
		t.SourceAddr = append(t.SourceAddr, tmp52_)
	}
	return nil
}

func (t *MulticastListenerQuery) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *MulticastListenerQuery) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode MulticastListenerQuery: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *MulticastAddressRecord) SetSourceAddr(v [][16]uint8) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.NumberOfSources = uint16(len(v))
	t.SourceAddr = v
	return true
}
func (t *MulticastAddressRecord) SetAuxData(v []uint8) bool {
	if len(v) > int(^uint8(0)) {
		return false
	}
	t.AuxDataLen = uint8(len(v))
	t.AuxData = v
	return true
}
func (t *MulticastAddressRecord) Visit(v VisitorKEYKW) {
	v.Visit(v, "RecordType", &t.RecordType)
	v.Visit(v, "AuxDataLen", &t.AuxDataLen)
	v.Visit(v, "NumberOfSources", &t.NumberOfSources)
	v.Visit(v, "MulticastAddr", &t.MulticastAddr)
	v.Visit(v, "SourceAddr", &t.SourceAddr)
	v.Visit(v, "AuxData", &t.AuxData)
}
func (t *MulticastAddressRecord) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *MulticastAddressRecord) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.RecordType)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.RecordType: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.AuxDataLen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.AuxDataLen: %w", err)
	}
	tmp53 := [2]byte{}
	binary.BigEndian.PutUint16(tmp53[:], uint16(t.NumberOfSources))
	if n, err := w.Write(tmp53[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.NumberOfSources: %w", err)
	}
	if n, err := w.Write(t.MulticastAddr[:]); err != nil || n != len(t.MulticastAddr) {
		return fmt.Errorf("encode MulticastAddr: %w", err)
	}
	len_SourceAddr := int(t.NumberOfSources)
	if len(t.SourceAddr) != len_SourceAddr {
		return fmt.Errorf("encode SourceAddr: expect %d but got %d for length", len_SourceAddr, len(t.SourceAddr))
	}
	for _, v := range t.SourceAddr {
		if n, err := w.Write(v[:]); err != nil || n != len(v) {
			return fmt.Errorf("encode SourceAddr: %w", err)
		}
	}
	len_AuxData := int(t.AuxDataLen)
	if len(t.AuxData) != len_AuxData {
		return fmt.Errorf("encode AuxData: expect %d bytes but got %d bytes", len_AuxData, len(t.AuxData))
	}
	if n, err := w.Write(t.AuxData); err != nil || n != len(t.AuxData) {
		return fmt.Errorf("encode AuxData: %w", err)
	}
	return nil
}
func (t *MulticastAddressRecord) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 20))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *MulticastAddressRecord) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *MulticastAddressRecord) Read(r io.Reader) (err error) {
	tmpRecordType := [1]byte{}
	n_RecordType, err := io.ReadFull(r, tmpRecordType[:])
	if err != nil {
		return fmt.Errorf("read RecordType: expect 1 byte but read %d bytes: %w", n_RecordType, err)
	}
	t.RecordType = uint8(tmpRecordType[0])
	tmpAuxDataLen := [1]byte{}
	n_AuxDataLen, err := io.ReadFull(r, tmpAuxDataLen[:])
	if err != nil {
		return fmt.Errorf("read AuxDataLen: expect 1 byte but read %d bytes: %w", n_AuxDataLen, err)
	}
	t.AuxDataLen = uint8(tmpAuxDataLen[0])
	tmpNumberOfSources := [2]byte{}
	n_NumberOfSources, err := io.ReadFull(r, tmpNumberOfSources[:])
	if err != nil {
		return fmt.Errorf("read NumberOfSources: expect 2 bytes but read %d bytes: %w", n_NumberOfSources, err)
	}
	t.NumberOfSources = uint16(binary.BigEndian.Uint16(tmpNumberOfSources[:]))
	n_MulticastAddr, err := io.ReadFull(r, t.MulticastAddr[:])
	if err != nil {
		return fmt.Errorf("read MulticastAddr: expect %d bytes but read %d bytes: %w", 16, n_MulticastAddr, err)
	}
	len_SourceAddr := int(t.NumberOfSources)
	for i_54 := 0; i_54 < len_SourceAddr; i_54++ {
		var tmp55_ [16]uint8
		n_SourceAddr, err := io.ReadFull(r, tmp55_[:])
		if err != nil {
			return fmt.Errorf("read SourceAddr: expect %d bytes but read %d bytes: %w", 16, n_SourceAddr, err)
		}
		t.SourceAddr = append(t.SourceAddr, tmp55_)
	}
	len_AuxData := int(t.AuxDataLen)
	if len_AuxData != 0 {
		tmpAuxData := make([]byte, len_AuxData)
		n_AuxData, err := io.ReadFull(r, tmpAuxData[:])
		if err != nil {
			return fmt.Errorf("read AuxData: expect %d bytes but read %d bytes: %w", len_AuxData, n_AuxData, err)
		}
		t.AuxData = tmpAuxData[:]
	} else {
		t.AuxData = nil
	}
	return nil
}

func (t *MulticastAddressRecord) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *MulticastAddressRecord) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode MulticastAddressRecord: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *PrefixInformation) OnLink() bool {
	return ((t.flags56 & 0x80) >> 7) == 1
}
func (t *PrefixInformation) SetOnLink(v bool) {
	if v {
		t.flags56 |= uint8(0x80)
	} else {
		t.flags56 &= ^uint8(0x80)
	}
}
func (t *PrefixInformation) Autoconfig() bool {
	return ((t.flags56 & 0x40) >> 6) == 1
}
func (t *PrefixInformation) SetAutoconfig(v bool) {
	if v {
		t.flags56 |= uint8(0x40)
	} else {
		t.flags56 &= ^uint8(0x40)
	}
}
func (t *PrefixInformation) Reserved1() uint8 {
	return ((t.flags56 & 0x3f) >> 0)
}
func (t *PrefixInformation) SetReserved1(v uint8) bool {
	if v > 63 {
		return false
	}
	t.flags56 = (t.flags56 & ^uint8(0x3f)) | ((v & 0x3f) << 0)
	return true
}
func (t *PrefixInformation) Visit(v VisitorKEYKW) {
	v.Visit(v, "PrefixLength", &t.PrefixLength)
	v.Visit(v, "OnLink", (func() uint8 {
		if t.OnLink() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Autoconfig", (func() uint8 {
		if t.Autoconfig() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved1", t.Reserved1())
	v.Visit(v, "ValidLifetime", &t.ValidLifetime)
	v.Visit(v, "PreferredLifetime", &t.PreferredLifetime)
	v.Visit(v, "Reserved2", &t.Reserved2)
	v.Visit(v, "Prefix", &t.Prefix)
}
func (t *PrefixInformation) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *PrefixInformation) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.PrefixLength)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.PrefixLength: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags56)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags56: %w", err)
	}
	tmp57 := [4]byte{}
	binary.BigEndian.PutUint32(tmp57[:], uint32(t.ValidLifetime))
	if n, err := w.Write(tmp57[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.ValidLifetime: %w", err)
	}
	tmp58 := [4]byte{}
	binary.BigEndian.PutUint32(tmp58[:], uint32(t.PreferredLifetime))
	if n, err := w.Write(tmp58[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.PreferredLifetime: %w", err)
	}
	tmp59 := [4]byte{}
	binary.BigEndian.PutUint32(tmp59[:], uint32(t.Reserved2))
	if n, err := w.Write(tmp59[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Reserved2: %w", err)
	}
	if n, err := w.Write(t.Prefix[:]); err != nil || n != len(t.Prefix) {
		return fmt.Errorf("encode Prefix: %w", err)
	}
	return nil
}
func (t *PrefixInformation) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 30))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *PrefixInformation) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *PrefixInformation) Read(r io.Reader) (err error) {
	tmpPrefixLength := [1]byte{}
	n_PrefixLength, err := io.ReadFull(r, tmpPrefixLength[:])
	if err != nil {
		return fmt.Errorf("read PrefixLength: expect 1 byte but read %d bytes: %w", n_PrefixLength, err)
	}
	t.PrefixLength = uint8(tmpPrefixLength[0])
	tmpflags56 := [1]byte{}
	n_flags56, err := io.ReadFull(r, tmpflags56[:])
	if err != nil {
		return fmt.Errorf("read flags56: expect 1 byte but read %d bytes: %w", n_flags56, err)
	}
	t.flags56 = uint8(tmpflags56[0])
	tmpValidLifetime := [4]byte{}
	n_ValidLifetime, err := io.ReadFull(r, tmpValidLifetime[:])
	if err != nil {
		return fmt.Errorf("read ValidLifetime: expect 4 bytes but read %d bytes: %w", n_ValidLifetime, err)
	}
	t.ValidLifetime = uint32(binary.BigEndian.Uint32(tmpValidLifetime[:]))
	tmpPreferredLifetime := [4]byte{}
	n_PreferredLifetime, err := io.ReadFull(r, tmpPreferredLifetime[:])
	if err != nil {
		return fmt.Errorf("read PreferredLifetime: expect 4 bytes but read %d bytes: %w", n_PreferredLifetime, err)
	}
	t.PreferredLifetime = uint32(binary.BigEndian.Uint32(tmpPreferredLifetime[:]))
	tmpReserved2 := [4]byte{}
	n_Reserved2, err := io.ReadFull(r, tmpReserved2[:])
	if err != nil {
		return fmt.Errorf("read Reserved2: expect 4 bytes but read %d bytes: %w", n_Reserved2, err)
	}
	t.Reserved2 = uint32(binary.BigEndian.Uint32(tmpReserved2[:]))
	n_Prefix, err := io.ReadFull(r, t.Prefix[:])
	if err != nil {
		return fmt.Errorf("read Prefix: expect %d bytes but read %d bytes: %w", 16, n_Prefix, err)
	}
	return nil
}

func (t *PrefixInformation) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *PrefixInformation) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode PrefixInformation: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *RedirectHeader) Visit(v VisitorKEYKW) {
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "HdrAndData", &t.HdrAndData)
}
func (t *RedirectHeader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *RedirectHeader) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.Reserved[:]); err != nil || n != len(t.Reserved) {
		return fmt.Errorf("encode Reserved: %w", err)
	}
	if n, err := w.Write(t.HdrAndData); err != nil || n != len(t.HdrAndData) {
		return fmt.Errorf("encode HdrAndData: %w", err)
	}
	return nil
}
func (t *RedirectHeader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 6))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *RedirectHeader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *RedirectHeader) Read(r io.Reader) (err error) {
	n_Reserved, err := io.ReadFull(r, t.Reserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect %d bytes but read %d bytes: %w", 6, n_Reserved, err)
	}
	bytes_buf_HdrAndData := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_HdrAndData, r); err != nil {
		return err
	}
	t.HdrAndData = bytes_buf_HdrAndData.Bytes()
	return nil
}

func (t *RedirectHeader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *RedirectHeader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode RedirectHeader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Mtu) Visit(v VisitorKEYKW) {
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "Mtu", &t.Mtu)
}
func (t *Mtu) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Mtu) Write(w io.Writer) (err error) {
	tmp60 := [2]byte{}
	binary.BigEndian.PutUint16(tmp60[:], uint16(t.Reserved))
	if n, err := w.Write(tmp60[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	tmp61 := [4]byte{}
	binary.BigEndian.PutUint32(tmp61[:], uint32(t.Mtu))
	if n, err := w.Write(tmp61[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Mtu: %w", err)
	}
	return nil
}
func (t *Mtu) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 6))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Mtu) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Mtu) Read(r io.Reader) (err error) {
	tmpReserved := [2]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 2 bytes but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint16(binary.BigEndian.Uint16(tmpReserved[:]))
	tmpMtu := [4]byte{}
	n_Mtu, err := io.ReadFull(r, tmpMtu[:])
	if err != nil {
		return fmt.Errorf("read Mtu: expect 4 bytes but read %d bytes: %w", n_Mtu, err)
	}
	t.Mtu = uint32(binary.BigEndian.Uint32(tmpMtu[:]))
	return nil
}

func (t *Mtu) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Mtu) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Mtu: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Ipv6ChecksumPseudoHeader) Visit(v VisitorKEYKW) {
	v.Visit(v, "SrcAddr", &t.SrcAddr)
	v.Visit(v, "DstAddr", &t.DstAddr)
	v.Visit(v, "UpperLayerLength", &t.UpperLayerLength)
	v.Visit(v, "Zero", &t.Zero)
	v.Visit(v, "NextHeader", &t.NextHeader)
}
func (t *Ipv6ChecksumPseudoHeader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Ipv6ChecksumPseudoHeader) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.SrcAddr[:]); err != nil || n != len(t.SrcAddr) {
		return fmt.Errorf("encode SrcAddr: %w", err)
	}
	if n, err := w.Write(t.DstAddr[:]); err != nil || n != len(t.DstAddr) {
		return fmt.Errorf("encode DstAddr: %w", err)
	}
	tmp62 := [4]byte{}
	binary.BigEndian.PutUint32(tmp62[:], uint32(t.UpperLayerLength))
	if n, err := w.Write(tmp62[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.UpperLayerLength: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Zero >> 16), byte(t.Zero >> 8), byte(t.Zero)}); err != nil || n != 3 {
		return fmt.Errorf("encode t.Zero: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.NextHeader)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.NextHeader: %w", err)
	}
	return nil
}
func (t *Ipv6ChecksumPseudoHeader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 40))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Ipv6ChecksumPseudoHeader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Ipv6ChecksumPseudoHeader) Read(r io.Reader) (err error) {
	n_SrcAddr, err := io.ReadFull(r, t.SrcAddr[:])
	if err != nil {
		return fmt.Errorf("read SrcAddr: expect %d bytes but read %d bytes: %w", 16, n_SrcAddr, err)
	}
	n_DstAddr, err := io.ReadFull(r, t.DstAddr[:])
	if err != nil {
		return fmt.Errorf("read DstAddr: expect %d bytes but read %d bytes: %w", 16, n_DstAddr, err)
	}
	tmpUpperLayerLength := [4]byte{}
	n_UpperLayerLength, err := io.ReadFull(r, tmpUpperLayerLength[:])
	if err != nil {
		return fmt.Errorf("read UpperLayerLength: expect 4 bytes but read %d bytes: %w", n_UpperLayerLength, err)
	}
	t.UpperLayerLength = uint32(binary.BigEndian.Uint32(tmpUpperLayerLength[:]))
	tmpZero := [3]byte{}
	n_Zero, err := io.ReadFull(r, tmpZero[:])
	if err != nil {
		return fmt.Errorf("read Zero: expect 3 bytes but read %d bytes: %w", n_Zero, err)
	}
	t.Zero = uint32(uint32(tmpZero[0])<<16 | uint32(tmpZero[1])<<8 | uint32(tmpZero[2]))
	tmpNextHeader := [1]byte{}
	n_NextHeader, err := io.ReadFull(r, tmpNextHeader[:])
	if err != nil {
		return fmt.Errorf("read NextHeader: expect 1 byte but read %d bytes: %w", n_NextHeader, err)
	}
	t.NextHeader = ProtocolNumber(tmpNextHeader[0])
	return nil
}

func (t *Ipv6ChecksumPseudoHeader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Ipv6ChecksumPseudoHeader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Ipv6ChecksumPseudoHeader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Ipv6ExtCommon) SetData(v []uint8) bool {
	t.Data = v
	return true
}
func (t *Ipv6ExtCommon) Visit(v VisitorKEYKW) {
	v.Visit(v, "Header", &t.Header)
	v.Visit(v, "Data", &t.Data)
}
func (t *Ipv6ExtCommon) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Ipv6ExtCommon) Write(w io.Writer) (err error) {
	if err := t.Header.Write(w); err != nil {
		return fmt.Errorf("encode Header: %w", err)
	}
	len_Data := int((6 + (t.Header.HdrExtLen * 8)))
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.Data))
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Ipv6ExtCommon) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Ipv6ExtCommon) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Ipv6ExtCommon) Read(r io.Reader) (err error) {
	if err := t.Header.Read(r); err != nil {
		return fmt.Errorf("read Header: %w", err)
	}
	len_Data := int((6 + (t.Header.HdrExtLen * 8)))
	if len_Data != 0 {
		tmpData := make([]byte, len_Data)
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
		}
		t.Data = tmpData[:]
	} else {
		t.Data = nil
	}
	return nil
}

func (t *Ipv6ExtCommon) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Ipv6ExtCommon) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Ipv6ExtCommon: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Open) Visit(v VisitorKEYKW) {
	v.Visit(v, "Version", &t.Version)
	v.Visit(v, "As", &t.As)
	v.Visit(v, "Hold", &t.Hold)
	v.Visit(v, "Id", &t.Id)
	v.Visit(v, "Optlen", &t.Optlen)
	v.Visit(v, "Options", &t.Options)
}
func (t *Open) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Open) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Version)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Version: %w", err)
	}
	tmp63 := [2]byte{}
	binary.BigEndian.PutUint16(tmp63[:], uint16(t.As))
	if n, err := w.Write(tmp63[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.As: %w", err)
	}
	tmp64 := [2]byte{}
	binary.BigEndian.PutUint16(tmp64[:], uint16(t.Hold))
	if n, err := w.Write(tmp64[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Hold: %w", err)
	}
	tmp65 := [4]byte{}
	binary.BigEndian.PutUint32(tmp65[:], uint32(t.Id))
	if n, err := w.Write(tmp65[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Id: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Optlen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Optlen: %w", err)
	}
	new_buf_66 := bytes.NewBuffer(nil)
	old_buf_66_w := w
	w = new_buf_66
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	if new_buf_66.Len() != int(t.Optlen) {
		return fmt.Errorf("encode Options: expect %d bytes but got %d bytes", new_buf_66.Len(), int(t.Optlen))
	}
	_, err = new_buf_66.WriteTo(old_buf_66_w)
	if err != nil {
		return err
	}
	w = old_buf_66_w
	return nil
}
func (t *Open) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 10))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Open) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Open) Read(r io.Reader) (err error) {
	tmpVersion := [1]byte{}
	n_Version, err := io.ReadFull(r, tmpVersion[:])
	if err != nil {
		return fmt.Errorf("read Version: expect 1 byte but read %d bytes: %w", n_Version, err)
	}
	t.Version = uint8(tmpVersion[0])
	tmpAs := [2]byte{}
	n_As, err := io.ReadFull(r, tmpAs[:])
	if err != nil {
		return fmt.Errorf("read As: expect 2 bytes but read %d bytes: %w", n_As, err)
	}
	t.As = uint16(binary.BigEndian.Uint16(tmpAs[:]))
	tmpHold := [2]byte{}
	n_Hold, err := io.ReadFull(r, tmpHold[:])
	if err != nil {
		return fmt.Errorf("read Hold: expect 2 bytes but read %d bytes: %w", n_Hold, err)
	}
	t.Hold = uint16(binary.BigEndian.Uint16(tmpHold[:]))
	tmpId := [4]byte{}
	n_Id, err := io.ReadFull(r, tmpId[:])
	if err != nil {
		return fmt.Errorf("read Id: expect 4 bytes but read %d bytes: %w", n_Id, err)
	}
	t.Id = uint32(binary.BigEndian.Uint32(tmpId[:]))
	tmpOptlen := [1]byte{}
	n_Optlen, err := io.ReadFull(r, tmpOptlen[:])
	if err != nil {
		return fmt.Errorf("read Optlen: expect 1 byte but read %d bytes: %w", n_Optlen, err)
	}
	t.Optlen = uint8(tmpOptlen[0])
	sub_byte_len_Options := int64(t.Optlen)
	sub_byte_r_Options := io.LimitReader(r, int64(sub_byte_len_Options))
	tmp_old_r_Options_67 := r
	r = sub_byte_r_Options
	len_Options := int(r.(*io.LimitedReader).N)
	tmpOptions := make([]byte, len_Options)
	n_Options, err := io.ReadFull(r, tmpOptions[:])
	if err != nil {
		return fmt.Errorf("read Options: expect %d bytes but read %d bytes: %w", len_Options, n_Options, err)
	}
	range_tmp_Options := bytes.NewReader(tmpOptions[:])
	tmp_old_r_Options := r
	r = range_tmp_Options
	for range_tmp_Options.Len() > 0 {
		var tmp68_ Bgpoption
		if err := tmp68_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp68_)
	}
	r = tmp_old_r_Options
	if sub_byte_r_Options.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Options: expect %d bytes but got %d bytes", sub_byte_len_Options, sub_byte_len_Options-sub_byte_r_Options.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Options_67
	return nil
}

func (t *Open) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Open) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Open: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_71_t) isunion69_() {}
func (t *union_72_t) isunion69_() {}
func (t *PathAttribute) Len() *uint16 {
	if true == ((func() uint8 {
		if t.Type.Extended() {
			return 1
		} else {
			return 0
		}
	}()) == 1) {
		if _, ok := t.union69_.(*union_71_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union69_.(*union_71_t).Len)
		return &tmp
	} else if true {
		if _, ok := t.union69_.(*union_72_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union69_.(*union_72_t).Len)
		return &tmp
	}
	return nil
}
func (t *PathAttribute) SetLen(v uint16) bool {
	if true == ((func() uint8 {
		if t.Type.Extended() {
			return 1
		} else {
			return 0
		}
	}()) == 1) {
		if _, ok := t.union69_.(*union_71_t); !ok {
			t.union69_ = &union_71_t{}
		}
		t.union69_.(*union_71_t).Len = uint16(v)
		return true
	} else if true {
		if v > uint16(^uint8(0)) {
			return false
		}
		if _, ok := t.union69_.(*union_72_t); !ok {
			t.union69_ = &union_72_t{}
		}
		t.union69_.(*union_72_t).Len = uint8(v)
		return true
	}
	return false
}
func (t *PathAttribute) SetData(v []uint8) bool {
	t.Data = v
	return true
}
func (t *PathAttribute) Visit(v VisitorKEYKW) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Len", (t.Len()))
	v.Visit(v, "Data", &t.Data)
}
func (t *PathAttribute) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *PathAttribute) Write(w io.Writer) (err error) {
	if err := t.Type.Write(w); err != nil {
		return fmt.Errorf("encode Type: %w", err)
	}
	if (func() uint8 {
		if t.Type.Extended() {
			return 1
		} else {
			return 0
		}
	}()) == 1 {
		if _, ok := t.union69_.(*union_71_t); !ok {
			return fmt.Errorf("encode t.union69_: union is not set to union_71_t")
		}
		tmp73 := [2]byte{}
		binary.BigEndian.PutUint16(tmp73[:], uint16(t.union69_.(*union_71_t).Len))
		if n, err := w.Write(tmp73[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union69_.(*union_71_t).Len: %w", err)
		}
	} else {
		if _, ok := t.union69_.(*union_72_t); !ok {
			return fmt.Errorf("encode t.union69_: union is not set to union_72_t")
		}
		if n, err := w.Write([]byte{byte(t.union69_.(*union_72_t).Len)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union69_.(*union_72_t).Len: %w", err)
		}
	}
	LenTmp := (*t.Len())
	len_Data := int(LenTmp)
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.Data))
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *PathAttribute) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *PathAttribute) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *PathAttribute) Read(r io.Reader) (err error) {
	if err := t.Type.Read(r); err != nil {
		return fmt.Errorf("read Type: %w", err)
	}
	if (func() uint8 {
		if t.Type.Extended() {
			return 1
		} else {
			return 0
		}
	}()) == 1 {
		t.union69_ = &union_71_t{}
		tmpLen := [2]byte{}
		n_Len, err := io.ReadFull(r, tmpLen[:])
		if err != nil {
			return fmt.Errorf("read Len: expect 2 bytes but read %d bytes: %w", n_Len, err)
		}
		t.union69_.(*union_71_t).Len = uint16(binary.BigEndian.Uint16(tmpLen[:]))
	} else {
		t.union69_ = &union_72_t{}
		tmpLen := [1]byte{}
		n_Len, err := io.ReadFull(r, tmpLen[:])
		if err != nil {
			return fmt.Errorf("read Len: expect 1 byte but read %d bytes: %w", n_Len, err)
		}
		t.union69_.(*union_72_t).Len = uint8(tmpLen[0])
	}
	LenTmp := (*t.Len())
	len_Data := int(LenTmp)
	if len_Data != 0 {
		tmpData := make([]byte, len_Data)
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
		}
		t.Data = tmpData[:]
	} else {
		t.Data = nil
	}
	return nil
}

func (t *PathAttribute) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *PathAttribute) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode PathAttribute: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *PathAttrs) Visit(v VisitorKEYKW) {
	v.Visit(v, "Len", &t.Len)
	v.Visit(v, "Data", &t.Data)
}
func (t *PathAttrs) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *PathAttrs) Write(w io.Writer) (err error) {
	tmp74 := [2]byte{}
	binary.BigEndian.PutUint16(tmp74[:], uint16(t.Len))
	if n, err := w.Write(tmp74[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Len: %w", err)
	}
	new_buf_75 := bytes.NewBuffer(nil)
	old_buf_75_w := w
	w = new_buf_75
	for _, v := range t.Data {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	if new_buf_75.Len() != int(t.Len) {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", new_buf_75.Len(), int(t.Len))
	}
	_, err = new_buf_75.WriteTo(old_buf_75_w)
	if err != nil {
		return err
	}
	w = old_buf_75_w
	return nil
}
func (t *PathAttrs) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *PathAttrs) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *PathAttrs) Read(r io.Reader) (err error) {
	tmpLen := [2]byte{}
	n_Len, err := io.ReadFull(r, tmpLen[:])
	if err != nil {
		return fmt.Errorf("read Len: expect 2 bytes but read %d bytes: %w", n_Len, err)
	}
	t.Len = uint16(binary.BigEndian.Uint16(tmpLen[:]))
	sub_byte_len_Data := int64(t.Len)
	sub_byte_r_Data := io.LimitReader(r, int64(sub_byte_len_Data))
	tmp_old_r_Data_76 := r
	r = sub_byte_r_Data
	len_Data := int(r.(*io.LimitedReader).N)
	tmpData := make([]byte, len_Data)
	n_Data, err := io.ReadFull(r, tmpData[:])
	if err != nil {
		return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
	}
	range_tmp_Data := bytes.NewReader(tmpData[:])
	tmp_old_r_Data := r
	r = range_tmp_Data
	for range_tmp_Data.Len() > 0 {
		var tmp77_ PathAttribute
		if err := tmp77_.Read(r); err != nil {
			return fmt.Errorf("read Data: %w", err)
		}
		t.Data = append(t.Data, tmp77_)
	}
	r = tmp_old_r_Data
	if sub_byte_r_Data.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Data: expect %d bytes but got %d bytes", sub_byte_len_Data, sub_byte_len_Data-sub_byte_r_Data.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Data_76
	return nil
}

func (t *PathAttrs) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *PathAttrs) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode PathAttrs: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *MacAddress) Visit(v VisitorKEYKW) {
	v.Visit(v, "Oui", &t.Oui)
	v.Visit(v, "Nic", &t.Nic)
}
func (t *MacAddress) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *MacAddress) Write(w io.Writer) (err error) {
	if err := t.Oui.Write(w); err != nil {
		return fmt.Errorf("encode Oui: %w", err)
	}
	if n, err := w.Write(t.Nic[:]); err != nil || n != len(t.Nic) {
		return fmt.Errorf("encode Nic: %w", err)
	}
	return nil
}
func (t *MacAddress) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 6))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *MacAddress) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *MacAddress) Read(r io.Reader) (err error) {
	if err := t.Oui.Read(r); err != nil {
		return fmt.Errorf("read Oui: %w", err)
	}
	n_Nic, err := io.ReadFull(r, t.Nic[:])
	if err != nil {
		return fmt.Errorf("read Nic: expect %d bytes but read %d bytes: %w", 3, n_Nic, err)
	}
	return nil
}

func (t *MacAddress) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *MacAddress) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode MacAddress: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Sack) Visit(v VisitorKEYKW) {
	v.Visit(v, "Blocks", &t.Blocks)
}
func (t *Sack) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Sack) Write(w io.Writer) (err error) {
	for _, v := range t.Blocks {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Blocks: %w", err)
		}
	}
	return nil
}
func (t *Sack) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Sack) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Sack) Read(r io.Reader) (err error) {
	tmp_byte_scanner78_ := bufio.NewReaderSize(r, 1)
	old_r_Blocks := r
	r = tmp_byte_scanner78_
	for {
		_, err := tmp_byte_scanner78_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Blocks: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner78_.UnreadByte(); err != nil {
			return fmt.Errorf("read Blocks: unexpected unread error: %w", err)
		}
		var tmp79_ SackBlock
		if err := tmp79_.Read(r); err != nil {
			return fmt.Errorf("read Blocks: %w", err)
		}
		t.Blocks = append(t.Blocks, tmp79_)
	}
	r = old_r_Blocks
	return nil
}

func (t *Sack) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Sack) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Sack: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_82_t) isunion80_() {}
func (t *union_83_t) isunion80_() {}
func (t *union_84_t) isunion80_() {}
func (t *union_85_t) isunion80_() {}
func (t *union_86_t) isunion80_() {}
func (t *union_87_t) isunion80_() {}
func (t *union_88_t) isunion80_() {}
func (t *union_89_t) isunion80_() {}
func (t *Tcpoption) Data() *[]uint8 {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return nil
	} else if t.Kind == TcpoptionKind_WindowScale {
		return nil
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return nil
	} else if t.Kind == TcpoptionKind_Sack {
		return nil
	} else if t.Kind == TcpoptionKind_Timestamp {
		return nil
	} else if true {
		if _, ok := t.union80_.(*union_89_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union80_.(*union_89_t).Data)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetData(v []uint8) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return false
	} else if t.Kind == TcpoptionKind_WindowScale {
		return false
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return false
	} else if t.Kind == TcpoptionKind_Sack {
		return false
	} else if t.Kind == TcpoptionKind_Timestamp {
		return false
	} else if true {
		if _, ok := t.union80_.(*union_89_t); !ok {
			t.union80_ = &union_89_t{}
		}
		t.union80_.(*union_89_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *Tcpoption) Length() *uint8 {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		if _, ok := t.union80_.(*union_84_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union80_.(*union_84_t).Length)
		return &tmp
	} else if t.Kind == TcpoptionKind_WindowScale {
		if _, ok := t.union80_.(*union_85_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union80_.(*union_85_t).Length)
		return &tmp
	} else if t.Kind == TcpoptionKind_SackPermitted {
		if _, ok := t.union80_.(*union_86_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union80_.(*union_86_t).Length)
		return &tmp
	} else if t.Kind == TcpoptionKind_Sack {
		if _, ok := t.union80_.(*union_87_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union80_.(*union_87_t).Length)
		return &tmp
	} else if t.Kind == TcpoptionKind_Timestamp {
		if _, ok := t.union80_.(*union_88_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union80_.(*union_88_t).Length)
		return &tmp
	} else if true {
		if _, ok := t.union80_.(*union_89_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union80_.(*union_89_t).Length)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetLength(v uint8) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		if _, ok := t.union80_.(*union_84_t); !ok {
			t.union80_ = &union_84_t{}
		}
		t.union80_.(*union_84_t).Length = uint8(v)
		return true
	} else if t.Kind == TcpoptionKind_WindowScale {
		if _, ok := t.union80_.(*union_85_t); !ok {
			t.union80_ = &union_85_t{}
		}
		t.union80_.(*union_85_t).Length = uint8(v)
		return true
	} else if t.Kind == TcpoptionKind_SackPermitted {
		if _, ok := t.union80_.(*union_86_t); !ok {
			t.union80_ = &union_86_t{}
		}
		t.union80_.(*union_86_t).Length = uint8(v)
		return true
	} else if t.Kind == TcpoptionKind_Sack {
		if _, ok := t.union80_.(*union_87_t); !ok {
			t.union80_ = &union_87_t{}
		}
		t.union80_.(*union_87_t).Length = uint8(v)
		return true
	} else if t.Kind == TcpoptionKind_Timestamp {
		if _, ok := t.union80_.(*union_88_t); !ok {
			t.union80_ = &union_88_t{}
		}
		t.union80_.(*union_88_t).Length = uint8(v)
		return true
	} else if true {
		if _, ok := t.union80_.(*union_89_t); !ok {
			t.union80_ = &union_89_t{}
		}
		t.union80_.(*union_89_t).Length = uint8(v)
		return true
	}
	return false
}
func (t *Tcpoption) Mss() *uint16 {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		if _, ok := t.union80_.(*union_84_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union80_.(*union_84_t).Mss)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetMss(v uint16) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		if _, ok := t.union80_.(*union_84_t); !ok {
			t.union80_ = &union_84_t{}
		}
		t.union80_.(*union_84_t).Mss = uint16(v)
		return true
	}
	return false
}
func (t *Tcpoption) Sack() *Sack {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return nil
	} else if t.Kind == TcpoptionKind_WindowScale {
		return nil
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return nil
	} else if t.Kind == TcpoptionKind_Sack {
		if _, ok := t.union80_.(*union_87_t); !ok {
			return nil // not set
		}
		tmp := Sack(t.union80_.(*union_87_t).Sack)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetSack(v Sack) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return false
	} else if t.Kind == TcpoptionKind_WindowScale {
		return false
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return false
	} else if t.Kind == TcpoptionKind_Sack {
		if _, ok := t.union80_.(*union_87_t); !ok {
			t.union80_ = &union_87_t{}
		}
		t.union80_.(*union_87_t).Sack = Sack(v)
		return true
	}
	return false
}
func (t *Tcpoption) ShiftCount() *uint8 {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return nil
	} else if t.Kind == TcpoptionKind_WindowScale {
		if _, ok := t.union80_.(*union_85_t); !ok {
			return nil // not set
		}
		tmp := uint8(t.union80_.(*union_85_t).ShiftCount)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetShiftCount(v uint8) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return false
	} else if t.Kind == TcpoptionKind_WindowScale {
		if _, ok := t.union80_.(*union_85_t); !ok {
			t.union80_ = &union_85_t{}
		}
		t.union80_.(*union_85_t).ShiftCount = uint8(v)
		return true
	}
	return false
}
func (t *Tcpoption) Timestamp() *Timestamp {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return nil
	} else if t.Kind == TcpoptionKind_Nop {
		return nil
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return nil
	} else if t.Kind == TcpoptionKind_WindowScale {
		return nil
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return nil
	} else if t.Kind == TcpoptionKind_Sack {
		return nil
	} else if t.Kind == TcpoptionKind_Timestamp {
		if _, ok := t.union80_.(*union_88_t); !ok {
			return nil // not set
		}
		tmp := Timestamp(t.union80_.(*union_88_t).Timestamp)
		return &tmp
	}
	return nil
}
func (t *Tcpoption) SetTimestamp(v Timestamp) bool {
	if t.Kind == TcpoptionKind_EndOfOptionsList {
		return false
	} else if t.Kind == TcpoptionKind_Nop {
		return false
	} else if t.Kind == TcpoptionKind_MaximumSegmentSize {
		return false
	} else if t.Kind == TcpoptionKind_WindowScale {
		return false
	} else if t.Kind == TcpoptionKind_SackPermitted {
		return false
	} else if t.Kind == TcpoptionKind_Sack {
		return false
	} else if t.Kind == TcpoptionKind_Timestamp {
		if _, ok := t.union80_.(*union_88_t); !ok {
			t.union80_ = &union_88_t{}
		}
		t.union80_.(*union_88_t).Timestamp = Timestamp(v)
		return true
	}
	return false
}
func (t *Tcpoption) Visit(v VisitorKEYKW) {
	v.Visit(v, "Kind", &t.Kind)
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "Length", (t.Length()))
	v.Visit(v, "Mss", (t.Mss()))
	v.Visit(v, "Sack", (t.Sack()))
	v.Visit(v, "ShiftCount", (t.ShiftCount()))
	v.Visit(v, "Timestamp", (t.Timestamp()))
}
func (t *Tcpoption) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Tcpoption) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Kind)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Kind: %w", err)
	}
	switch {
	case (t.Kind == TcpoptionKind_EndOfOptionsList):
	case (t.Kind == TcpoptionKind_Nop):
	case (t.Kind == TcpoptionKind_MaximumSegmentSize):
		if _, ok := t.union80_.(*union_84_t); !ok {
			return fmt.Errorf("encode t.union80_: union is not set to union_84_t")
		}
		if n, err := w.Write([]byte{byte(t.union80_.(*union_84_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union80_.(*union_84_t).Length: %w", err)
		}
		tmp90 := [2]byte{}
		binary.BigEndian.PutUint16(tmp90[:], uint16(t.union80_.(*union_84_t).Mss))
		if n, err := w.Write(tmp90[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union80_.(*union_84_t).Mss: %w", err)
		}
	case (t.Kind == TcpoptionKind_WindowScale):
		if _, ok := t.union80_.(*union_85_t); !ok {
			return fmt.Errorf("encode t.union80_: union is not set to union_85_t")
		}
		if n, err := w.Write([]byte{byte(t.union80_.(*union_85_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union80_.(*union_85_t).Length: %w", err)
		}
		if n, err := w.Write([]byte{byte(t.union80_.(*union_85_t).ShiftCount)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union80_.(*union_85_t).ShiftCount: %w", err)
		}
	case (t.Kind == TcpoptionKind_SackPermitted):
		if _, ok := t.union80_.(*union_86_t); !ok {
			return fmt.Errorf("encode t.union80_: union is not set to union_86_t")
		}
		if n, err := w.Write([]byte{byte(t.union80_.(*union_86_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union80_.(*union_86_t).Length: %w", err)
		}
	case (t.Kind == TcpoptionKind_Sack):
		if _, ok := t.union80_.(*union_87_t); !ok {
			return fmt.Errorf("encode t.union80_: union is not set to union_87_t")
		}
		if n, err := w.Write([]byte{byte(t.union80_.(*union_87_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union80_.(*union_87_t).Length: %w", err)
		}
		new_buf_91 := bytes.NewBuffer(nil)
		old_buf_91_w := w
		w = new_buf_91
		if err := t.union80_.(*union_87_t).Sack.Write(w); err != nil {
			return fmt.Errorf("encode Sack: %w", err)
		}
		if new_buf_91.Len() != int((t.union80_.(*union_87_t).Length - 2)) {
			return fmt.Errorf("encode Sack: expect %d bytes but got %d bytes", new_buf_91.Len(), int((t.union80_.(*union_87_t).Length - 2)))
		}
		_, err = new_buf_91.WriteTo(old_buf_91_w)
		if err != nil {
			return err
		}
		w = old_buf_91_w
	case (t.Kind == TcpoptionKind_Timestamp):
		if _, ok := t.union80_.(*union_88_t); !ok {
			return fmt.Errorf("encode t.union80_: union is not set to union_88_t")
		}
		if n, err := w.Write([]byte{byte(t.union80_.(*union_88_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union80_.(*union_88_t).Length: %w", err)
		}
		new_buf_92 := bytes.NewBuffer(nil)
		old_buf_92_w := w
		w = new_buf_92
		if err := t.union80_.(*union_88_t).Timestamp.Write(w); err != nil {
			return fmt.Errorf("encode Timestamp: %w", err)
		}
		if new_buf_92.Len() != int((t.union80_.(*union_88_t).Length - 2)) {
			return fmt.Errorf("encode Timestamp: expect %d bytes but got %d bytes", new_buf_92.Len(), int((t.union80_.(*union_88_t).Length - 2)))
		}
		_, err = new_buf_92.WriteTo(old_buf_92_w)
		if err != nil {
			return err
		}
		w = old_buf_92_w
	default:
		if _, ok := t.union80_.(*union_89_t); !ok {
			return fmt.Errorf("encode t.union80_: union is not set to union_89_t")
		}
		if n, err := w.Write([]byte{byte(t.union80_.(*union_89_t).Length)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union80_.(*union_89_t).Length: %w", err)
		}
		len_Data := int((t.union80_.(*union_89_t).Length - 2))
		if len(t.union80_.(*union_89_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union80_.(*union_89_t).Data))
		}
		if n, err := w.Write(t.union80_.(*union_89_t).Data); err != nil || n != len(t.union80_.(*union_89_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *Tcpoption) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Tcpoption) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Tcpoption) Read(r io.Reader) (err error) {
	tmpKind := [1]byte{}
	n_Kind, err := io.ReadFull(r, tmpKind[:])
	if err != nil {
		return fmt.Errorf("read Kind: expect 1 byte but read %d bytes: %w", n_Kind, err)
	}
	t.Kind = TcpoptionKind(tmpKind[0])
	switch {
	case (t.Kind == TcpoptionKind_EndOfOptionsList):
	case (t.Kind == TcpoptionKind_Nop):
	case (t.Kind == TcpoptionKind_MaximumSegmentSize):
		t.union80_ = &union_84_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union80_.(*union_84_t).Length = uint8(tmpLength[0])
		tmpMss := [2]byte{}
		n_Mss, err := io.ReadFull(r, tmpMss[:])
		if err != nil {
			return fmt.Errorf("read Mss: expect 2 bytes but read %d bytes: %w", n_Mss, err)
		}
		t.union80_.(*union_84_t).Mss = uint16(binary.BigEndian.Uint16(tmpMss[:]))
	case (t.Kind == TcpoptionKind_WindowScale):
		t.union80_ = &union_85_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union80_.(*union_85_t).Length = uint8(tmpLength[0])
		tmpShiftCount := [1]byte{}
		n_ShiftCount, err := io.ReadFull(r, tmpShiftCount[:])
		if err != nil {
			return fmt.Errorf("read ShiftCount: expect 1 byte but read %d bytes: %w", n_ShiftCount, err)
		}
		t.union80_.(*union_85_t).ShiftCount = uint8(tmpShiftCount[0])
	case (t.Kind == TcpoptionKind_SackPermitted):
		t.union80_ = &union_86_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union80_.(*union_86_t).Length = uint8(tmpLength[0])
	case (t.Kind == TcpoptionKind_Sack):
		t.union80_ = &union_87_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union80_.(*union_87_t).Length = uint8(tmpLength[0])
		sub_byte_len_Sack := int64((t.union80_.(*union_87_t).Length - 2))
		sub_byte_r_Sack := io.LimitReader(r, int64(sub_byte_len_Sack))
		tmp_old_r_Sack_93 := r
		r = sub_byte_r_Sack
		if err := t.union80_.(*union_87_t).Sack.Read(r); err != nil {
			return fmt.Errorf("read Sack: %w", err)
		}
		if sub_byte_r_Sack.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Sack: expect %d bytes but got %d bytes", sub_byte_len_Sack, sub_byte_len_Sack-sub_byte_r_Sack.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Sack_93
	case (t.Kind == TcpoptionKind_Timestamp):
		t.union80_ = &union_88_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union80_.(*union_88_t).Length = uint8(tmpLength[0])
		sub_byte_len_Timestamp := int64((t.union80_.(*union_88_t).Length - 2))
		sub_byte_r_Timestamp := io.LimitReader(r, int64(sub_byte_len_Timestamp))
		tmp_old_r_Timestamp_94 := r
		r = sub_byte_r_Timestamp
		if err := t.union80_.(*union_88_t).Timestamp.Read(r); err != nil {
			return fmt.Errorf("read Timestamp: %w", err)
		}
		if sub_byte_r_Timestamp.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Timestamp: expect %d bytes but got %d bytes", sub_byte_len_Timestamp, sub_byte_len_Timestamp-sub_byte_r_Timestamp.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Timestamp_94
	default:
		t.union80_ = &union_89_t{}
		tmpLength := [1]byte{}
		n_Length, err := io.ReadFull(r, tmpLength[:])
		if err != nil {
			return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
		}
		t.union80_.(*union_89_t).Length = uint8(tmpLength[0])
		len_Data := int((t.union80_.(*union_89_t).Length - 2))
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union80_.(*union_89_t).Data = tmpData[:]
		} else {
			t.union80_.(*union_89_t).Data = nil
		}
	}
	return nil
}

func (t *Tcpoption) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Tcpoption) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Tcpoption: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Tcpheader) DataOffset() uint8 {
	return ((t.flags95 & 0xf0) >> 4)
}
func (t *Tcpheader) SetDataOffset(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags95 = (t.flags95 & ^uint8(0xf0)) | ((v & 0xf) << 4)
	return true
}
func (t *Tcpheader) Reserved() uint8 {
	return ((t.flags95 & 0x0f) >> 0)
}
func (t *Tcpheader) SetReserved(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags95 = (t.flags95 & ^uint8(0xf)) | ((v & 0xf) << 0)
	return true
}
func (t *Tcpheader) Visit(v VisitorKEYKW) {
	v.Visit(v, "SrcPort", &t.SrcPort)
	v.Visit(v, "DstPort", &t.DstPort)
	v.Visit(v, "SeqNum", &t.SeqNum)
	v.Visit(v, "AckNum", &t.AckNum)
	v.Visit(v, "DataOffset", t.DataOffset())
	v.Visit(v, "Reserved", t.Reserved())
	v.Visit(v, "Flags", &t.Flags)
	v.Visit(v, "WindowSize", &t.WindowSize)
	v.Visit(v, "Checksum", &t.Checksum)
	v.Visit(v, "UrgentPointer", &t.UrgentPointer)
	v.Visit(v, "Options", &t.Options)
}
func (t *Tcpheader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Tcpheader) Write(w io.Writer) (err error) {
	tmp96 := [2]byte{}
	binary.BigEndian.PutUint16(tmp96[:], uint16(t.SrcPort))
	if n, err := w.Write(tmp96[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.SrcPort: %w", err)
	}
	tmp97 := [2]byte{}
	binary.BigEndian.PutUint16(tmp97[:], uint16(t.DstPort))
	if n, err := w.Write(tmp97[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.DstPort: %w", err)
	}
	tmp98 := [4]byte{}
	binary.BigEndian.PutUint32(tmp98[:], uint32(t.SeqNum))
	if n, err := w.Write(tmp98[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.SeqNum: %w", err)
	}
	tmp99 := [4]byte{}
	binary.BigEndian.PutUint32(tmp99[:], uint32(t.AckNum))
	if n, err := w.Write(tmp99[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.AckNum: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags95)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags95: %w", err)
	}
	if err := t.Flags.Write(w); err != nil {
		return fmt.Errorf("encode Flags: %w", err)
	}
	tmp100 := [2]byte{}
	binary.BigEndian.PutUint16(tmp100[:], uint16(t.WindowSize))
	if n, err := w.Write(tmp100[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.WindowSize: %w", err)
	}
	tmp101 := [2]byte{}
	binary.BigEndian.PutUint16(tmp101[:], uint16(t.Checksum))
	if n, err := w.Write(tmp101[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Checksum: %w", err)
	}
	tmp102 := [2]byte{}
	binary.BigEndian.PutUint16(tmp102[:], uint16(t.UrgentPointer))
	if n, err := w.Write(tmp102[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.UrgentPointer: %w", err)
	}
	new_buf_103 := bytes.NewBuffer(nil)
	old_buf_103_w := w
	w = new_buf_103
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	if new_buf_103.Len() != int((uint8((t.DataOffset() * 4)) - 20)) {
		return fmt.Errorf("encode Options: expect %d bytes but got %d bytes", new_buf_103.Len(), int((uint8((t.DataOffset() * 4)) - 20)))
	}
	_, err = new_buf_103.WriteTo(old_buf_103_w)
	if err != nil {
		return err
	}
	w = old_buf_103_w
	return nil
}
func (t *Tcpheader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 20))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Tcpheader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Tcpheader) Read(r io.Reader) (err error) {
	tmpSrcPort := [2]byte{}
	n_SrcPort, err := io.ReadFull(r, tmpSrcPort[:])
	if err != nil {
		return fmt.Errorf("read SrcPort: expect 2 bytes but read %d bytes: %w", n_SrcPort, err)
	}
	t.SrcPort = uint16(binary.BigEndian.Uint16(tmpSrcPort[:]))
	tmpDstPort := [2]byte{}
	n_DstPort, err := io.ReadFull(r, tmpDstPort[:])
	if err != nil {
		return fmt.Errorf("read DstPort: expect 2 bytes but read %d bytes: %w", n_DstPort, err)
	}
	t.DstPort = uint16(binary.BigEndian.Uint16(tmpDstPort[:]))
	tmpSeqNum := [4]byte{}
	n_SeqNum, err := io.ReadFull(r, tmpSeqNum[:])
	if err != nil {
		return fmt.Errorf("read SeqNum: expect 4 bytes but read %d bytes: %w", n_SeqNum, err)
	}
	t.SeqNum = uint32(binary.BigEndian.Uint32(tmpSeqNum[:]))
	tmpAckNum := [4]byte{}
	n_AckNum, err := io.ReadFull(r, tmpAckNum[:])
	if err != nil {
		return fmt.Errorf("read AckNum: expect 4 bytes but read %d bytes: %w", n_AckNum, err)
	}
	t.AckNum = uint32(binary.BigEndian.Uint32(tmpAckNum[:]))
	tmpflags95 := [1]byte{}
	n_flags95, err := io.ReadFull(r, tmpflags95[:])
	if err != nil {
		return fmt.Errorf("read flags95: expect 1 byte but read %d bytes: %w", n_flags95, err)
	}
	t.flags95 = uint8(tmpflags95[0])
	if err := t.Flags.Read(r); err != nil {
		return fmt.Errorf("read Flags: %w", err)
	}
	tmpWindowSize := [2]byte{}
	n_WindowSize, err := io.ReadFull(r, tmpWindowSize[:])
	if err != nil {
		return fmt.Errorf("read WindowSize: expect 2 bytes but read %d bytes: %w", n_WindowSize, err)
	}
	t.WindowSize = uint16(binary.BigEndian.Uint16(tmpWindowSize[:]))
	tmpChecksum := [2]byte{}
	n_Checksum, err := io.ReadFull(r, tmpChecksum[:])
	if err != nil {
		return fmt.Errorf("read Checksum: expect 2 bytes but read %d bytes: %w", n_Checksum, err)
	}
	t.Checksum = uint16(binary.BigEndian.Uint16(tmpChecksum[:]))
	tmpUrgentPointer := [2]byte{}
	n_UrgentPointer, err := io.ReadFull(r, tmpUrgentPointer[:])
	if err != nil {
		return fmt.Errorf("read UrgentPointer: expect 2 bytes but read %d bytes: %w", n_UrgentPointer, err)
	}
	t.UrgentPointer = uint16(binary.BigEndian.Uint16(tmpUrgentPointer[:]))
	sub_byte_len_Options := int64((uint8((t.DataOffset() * 4)) - 20))
	sub_byte_r_Options := io.LimitReader(r, int64(sub_byte_len_Options))
	tmp_old_r_Options_104 := r
	r = sub_byte_r_Options
	len_Options := int(r.(*io.LimitedReader).N)
	tmpOptions := make([]byte, len_Options)
	n_Options, err := io.ReadFull(r, tmpOptions[:])
	if err != nil {
		return fmt.Errorf("read Options: expect %d bytes but read %d bytes: %w", len_Options, n_Options, err)
	}
	range_tmp_Options := bytes.NewReader(tmpOptions[:])
	tmp_old_r_Options := r
	r = range_tmp_Options
	for range_tmp_Options.Len() > 0 {
		var tmp105_ Tcpoption
		if err := tmp105_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp105_)
	}
	r = tmp_old_r_Options
	if sub_byte_r_Options.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Options: expect %d bytes but got %d bytes", sub_byte_len_Options, sub_byte_len_Options-sub_byte_r_Options.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Options_104
	return nil
}

func (t *Tcpheader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Tcpheader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Tcpheader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Tcpsegment) Visit(v VisitorKEYKW) {
	v.Visit(v, "Hdr", &t.Hdr)
	v.Visit(v, "Payload", &t.Payload)
}
func (t *Tcpsegment) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Tcpsegment) Write(w io.Writer) (err error) {
	if err := t.Hdr.Write(w); err != nil {
		return fmt.Errorf("encode Hdr: %w", err)
	}
	if n, err := w.Write(t.Payload); err != nil || n != len(t.Payload) {
		return fmt.Errorf("encode Payload: %w", err)
	}
	return nil
}
func (t *Tcpsegment) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Tcpsegment) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Tcpsegment) Read(r io.Reader) (err error) {
	if err := t.Hdr.Read(r); err != nil {
		return fmt.Errorf("read Hdr: %w", err)
	}
	bytes_buf_Payload := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Payload, r); err != nil {
		return err
	}
	t.Payload = bytes_buf_Payload.Bytes()
	return nil
}

func (t *Tcpsegment) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Tcpsegment) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Tcpsegment: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_108_t) isunion106_() {}
func (t *union_109_t) isunion106_() {}
func (t *union_110_t) isunion106_() {}
func (t *union_111_t) isunion106_() {}
func (t *union_112_t) isunion106_() {}
func (t *union_113_t) isunion106_() {}
func (t *Ndpoption) Data() *[]uint8 {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_RedirectHeader {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_Mtu {
		return nil
	} else if true {
		if _, ok := t.union106_.(*union_113_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union106_.(*union_113_t).Data)
		return &tmp
	}
	return nil
}
func (t *Ndpoption) SetData(v []uint8) bool {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_RedirectHeader {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_Mtu {
		return false
	} else if true {
		if _, ok := t.union106_.(*union_113_t); !ok {
			t.union106_ = &union_113_t{}
		}
		t.union106_.(*union_113_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *Ndpoption) LinkLayerAddress() *[]uint8 {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		if _, ok := t.union106_.(*union_108_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union106_.(*union_108_t).LinkLayerAddress)
		return &tmp
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		if _, ok := t.union106_.(*union_109_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union106_.(*union_109_t).LinkLayerAddress)
		return &tmp
	}
	return nil
}
func (t *Ndpoption) SetLinkLayerAddress(v []uint8) bool {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		if _, ok := t.union106_.(*union_108_t); !ok {
			t.union106_ = &union_108_t{}
		}
		t.union106_.(*union_108_t).LinkLayerAddress = []uint8(v)
		return true
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		if _, ok := t.union106_.(*union_109_t); !ok {
			t.union106_ = &union_109_t{}
		}
		t.union106_.(*union_109_t).LinkLayerAddress = []uint8(v)
		return true
	}
	return false
}
func (t *Ndpoption) Mtu() *Mtu {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_RedirectHeader {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_Mtu {
		if _, ok := t.union106_.(*union_112_t); !ok {
			return nil // not set
		}
		tmp := Mtu(t.union106_.(*union_112_t).Mtu)
		return &tmp
	}
	return nil
}
func (t *Ndpoption) SetMtu(v Mtu) bool {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_RedirectHeader {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_Mtu {
		if _, ok := t.union106_.(*union_112_t); !ok {
			t.union106_ = &union_112_t{}
		}
		t.union106_.(*union_112_t).Mtu = Mtu(v)
		return true
	}
	return false
}
func (t *Ndpoption) PrefixInformation() *PrefixInformation {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		if _, ok := t.union106_.(*union_110_t); !ok {
			return nil // not set
		}
		tmp := PrefixInformation(t.union106_.(*union_110_t).PrefixInformation)
		return &tmp
	}
	return nil
}
func (t *Ndpoption) SetPrefixInformation(v PrefixInformation) bool {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		if _, ok := t.union106_.(*union_110_t); !ok {
			t.union106_ = &union_110_t{}
		}
		t.union106_.(*union_110_t).PrefixInformation = PrefixInformation(v)
		return true
	}
	return false
}
func (t *Ndpoption) RedirectHeader() *RedirectHeader {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		return nil
	} else if NdpoptionType(t.Type) == NdpoptionType_RedirectHeader {
		if _, ok := t.union106_.(*union_111_t); !ok {
			return nil // not set
		}
		tmp := RedirectHeader(t.union106_.(*union_111_t).RedirectHeader)
		return &tmp
	}
	return nil
}
func (t *Ndpoption) SetRedirectHeader(v RedirectHeader) bool {
	if NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_PrefixInformation {
		return false
	} else if NdpoptionType(t.Type) == NdpoptionType_RedirectHeader {
		if _, ok := t.union106_.(*union_111_t); !ok {
			t.union106_ = &union_111_t{}
		}
		t.union106_.(*union_111_t).RedirectHeader = RedirectHeader(v)
		return true
	}
	return false
}
func (t *Ndpoption) Visit(v VisitorKEYKW) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "LinkLayerAddress", (t.LinkLayerAddress()))
	v.Visit(v, "Mtu", (t.Mtu()))
	v.Visit(v, "PrefixInformation", (t.PrefixInformation()))
	v.Visit(v, "RedirectHeader", (t.RedirectHeader()))
}
func (t *Ndpoption) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Ndpoption) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Length)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	switch {
	case (NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress):
		if _, ok := t.union106_.(*union_108_t); !ok {
			return fmt.Errorf("encode t.union106_: union is not set to union_108_t")
		}
		len_LinkLayerAddress := int(((t.Length * 8) - 2))
		if len(t.union106_.(*union_108_t).LinkLayerAddress) != len_LinkLayerAddress {
			return fmt.Errorf("encode LinkLayerAddress: expect %d bytes but got %d bytes", len_LinkLayerAddress, len(t.union106_.(*union_108_t).LinkLayerAddress))
		}
		if n, err := w.Write(t.union106_.(*union_108_t).LinkLayerAddress); err != nil || n != len(t.union106_.(*union_108_t).LinkLayerAddress) {
			return fmt.Errorf("encode LinkLayerAddress: %w", err)
		}
	case (NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress):
		if _, ok := t.union106_.(*union_109_t); !ok {
			return fmt.Errorf("encode t.union106_: union is not set to union_109_t")
		}
		len_LinkLayerAddress := int(((t.Length * 8) - 2))
		if len(t.union106_.(*union_109_t).LinkLayerAddress) != len_LinkLayerAddress {
			return fmt.Errorf("encode LinkLayerAddress: expect %d bytes but got %d bytes", len_LinkLayerAddress, len(t.union106_.(*union_109_t).LinkLayerAddress))
		}
		if n, err := w.Write(t.union106_.(*union_109_t).LinkLayerAddress); err != nil || n != len(t.union106_.(*union_109_t).LinkLayerAddress) {
			return fmt.Errorf("encode LinkLayerAddress: %w", err)
		}
	case (NdpoptionType(t.Type) == NdpoptionType_PrefixInformation):
		if _, ok := t.union106_.(*union_110_t); !ok {
			return fmt.Errorf("encode t.union106_: union is not set to union_110_t")
		}
		new_buf_114 := bytes.NewBuffer(nil)
		old_buf_114_w := w
		w = new_buf_114
		if err := t.union106_.(*union_110_t).PrefixInformation.Write(w); err != nil {
			return fmt.Errorf("encode PrefixInformation: %w", err)
		}
		if new_buf_114.Len() != int(((t.Length * 8) - 2)) {
			return fmt.Errorf("encode PrefixInformation: expect %d bytes but got %d bytes", new_buf_114.Len(), int(((t.Length * 8) - 2)))
		}
		_, err = new_buf_114.WriteTo(old_buf_114_w)
		if err != nil {
			return err
		}
		w = old_buf_114_w
	case (NdpoptionType(t.Type) == NdpoptionType_RedirectHeader):
		if _, ok := t.union106_.(*union_111_t); !ok {
			return fmt.Errorf("encode t.union106_: union is not set to union_111_t")
		}
		new_buf_115 := bytes.NewBuffer(nil)
		old_buf_115_w := w
		w = new_buf_115
		if err := t.union106_.(*union_111_t).RedirectHeader.Write(w); err != nil {
			return fmt.Errorf("encode RedirectHeader: %w", err)
		}
		if new_buf_115.Len() != int(((t.Length * 8) - 2)) {
			return fmt.Errorf("encode RedirectHeader: expect %d bytes but got %d bytes", new_buf_115.Len(), int(((t.Length * 8) - 2)))
		}
		_, err = new_buf_115.WriteTo(old_buf_115_w)
		if err != nil {
			return err
		}
		w = old_buf_115_w
	case (NdpoptionType(t.Type) == NdpoptionType_Mtu):
		if _, ok := t.union106_.(*union_112_t); !ok {
			return fmt.Errorf("encode t.union106_: union is not set to union_112_t")
		}
		new_buf_116 := bytes.NewBuffer(nil)
		old_buf_116_w := w
		w = new_buf_116
		if err := t.union106_.(*union_112_t).Mtu.Write(w); err != nil {
			return fmt.Errorf("encode Mtu: %w", err)
		}
		if new_buf_116.Len() != int(((t.Length * 8) - 2)) {
			return fmt.Errorf("encode Mtu: expect %d bytes but got %d bytes", new_buf_116.Len(), int(((t.Length * 8) - 2)))
		}
		_, err = new_buf_116.WriteTo(old_buf_116_w)
		if err != nil {
			return err
		}
		w = old_buf_116_w
	default:
		if _, ok := t.union106_.(*union_113_t); !ok {
			return fmt.Errorf("encode t.union106_: union is not set to union_113_t")
		}
		len_Data := int(((t.Length * 8) - 2))
		if len(t.union106_.(*union_113_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union106_.(*union_113_t).Data))
		}
		if n, err := w.Write(t.union106_.(*union_113_t).Data); err != nil || n != len(t.union106_.(*union_113_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *Ndpoption) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Ndpoption) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Ndpoption) Read(r io.Reader) (err error) {
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = NdpoptionType(tmpType[0])
	tmpLength := [1]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 1 byte but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint8(tmpLength[0])
	switch {
	case (NdpoptionType(t.Type) == NdpoptionType_SourceLinkLayerAddress):
		t.union106_ = &union_108_t{}
		len_LinkLayerAddress := int(((t.Length * 8) - 2))
		if len_LinkLayerAddress != 0 {
			tmpLinkLayerAddress := make([]byte, len_LinkLayerAddress)
			n_LinkLayerAddress, err := io.ReadFull(r, tmpLinkLayerAddress[:])
			if err != nil {
				return fmt.Errorf("read LinkLayerAddress: expect %d bytes but read %d bytes: %w", len_LinkLayerAddress, n_LinkLayerAddress, err)
			}
			t.union106_.(*union_108_t).LinkLayerAddress = tmpLinkLayerAddress[:]
		} else {
			t.union106_.(*union_108_t).LinkLayerAddress = nil
		}
	case (NdpoptionType(t.Type) == NdpoptionType_TargetLinkLayerAddress):
		t.union106_ = &union_109_t{}
		len_LinkLayerAddress := int(((t.Length * 8) - 2))
		if len_LinkLayerAddress != 0 {
			tmpLinkLayerAddress := make([]byte, len_LinkLayerAddress)
			n_LinkLayerAddress, err := io.ReadFull(r, tmpLinkLayerAddress[:])
			if err != nil {
				return fmt.Errorf("read LinkLayerAddress: expect %d bytes but read %d bytes: %w", len_LinkLayerAddress, n_LinkLayerAddress, err)
			}
			t.union106_.(*union_109_t).LinkLayerAddress = tmpLinkLayerAddress[:]
		} else {
			t.union106_.(*union_109_t).LinkLayerAddress = nil
		}
	case (NdpoptionType(t.Type) == NdpoptionType_PrefixInformation):
		t.union106_ = &union_110_t{}
		sub_byte_len_PrefixInformation := int64(((t.Length * 8) - 2))
		sub_byte_r_PrefixInformation := io.LimitReader(r, int64(sub_byte_len_PrefixInformation))
		tmp_old_r_PrefixInformation_117 := r
		r = sub_byte_r_PrefixInformation
		if err := t.union106_.(*union_110_t).PrefixInformation.Read(r); err != nil {
			return fmt.Errorf("read PrefixInformation: %w", err)
		}
		if sub_byte_r_PrefixInformation.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read PrefixInformation: expect %d bytes but got %d bytes", sub_byte_len_PrefixInformation, sub_byte_len_PrefixInformation-sub_byte_r_PrefixInformation.(*io.LimitedReader).N)
		}
		r = tmp_old_r_PrefixInformation_117
	case (NdpoptionType(t.Type) == NdpoptionType_RedirectHeader):
		t.union106_ = &union_111_t{}
		sub_byte_len_RedirectHeader := int64(((t.Length * 8) - 2))
		sub_byte_r_RedirectHeader := io.LimitReader(r, int64(sub_byte_len_RedirectHeader))
		tmp_old_r_RedirectHeader_118 := r
		r = sub_byte_r_RedirectHeader
		if err := t.union106_.(*union_111_t).RedirectHeader.Read(r); err != nil {
			return fmt.Errorf("read RedirectHeader: %w", err)
		}
		if sub_byte_r_RedirectHeader.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read RedirectHeader: expect %d bytes but got %d bytes", sub_byte_len_RedirectHeader, sub_byte_len_RedirectHeader-sub_byte_r_RedirectHeader.(*io.LimitedReader).N)
		}
		r = tmp_old_r_RedirectHeader_118
	case (NdpoptionType(t.Type) == NdpoptionType_Mtu):
		t.union106_ = &union_112_t{}
		sub_byte_len_Mtu := int64(((t.Length * 8) - 2))
		sub_byte_r_Mtu := io.LimitReader(r, int64(sub_byte_len_Mtu))
		tmp_old_r_Mtu_119 := r
		r = sub_byte_r_Mtu
		if err := t.union106_.(*union_112_t).Mtu.Read(r); err != nil {
			return fmt.Errorf("read Mtu: %w", err)
		}
		if sub_byte_r_Mtu.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Mtu: expect %d bytes but got %d bytes", sub_byte_len_Mtu, sub_byte_len_Mtu-sub_byte_r_Mtu.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Mtu_119
	default:
		t.union106_ = &union_113_t{}
		len_Data := int(((t.Length * 8) - 2))
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union106_.(*union_113_t).Data = tmpData[:]
		} else {
			t.union106_.(*union_113_t).Data = nil
		}
	}
	return nil
}

func (t *Ndpoption) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Ndpoption) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Ndpoption: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NdprouterSolicitation) Visit(v VisitorKEYKW) {
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "Options", &t.Options)
}
func (t *NdprouterSolicitation) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *NdprouterSolicitation) Write(w io.Writer) (err error) {
	tmp120 := [4]byte{}
	binary.BigEndian.PutUint32(tmp120[:], uint32(t.Reserved))
	if n, err := w.Write(tmp120[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	return nil
}
func (t *NdprouterSolicitation) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NdprouterSolicitation) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NdprouterSolicitation) Read(r io.Reader) (err error) {
	tmpReserved := [4]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 4 bytes but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint32(binary.BigEndian.Uint32(tmpReserved[:]))
	tmp_byte_scanner121_ := bufio.NewReaderSize(r, 1)
	old_r_Options := r
	r = tmp_byte_scanner121_
	for {
		_, err := tmp_byte_scanner121_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Options: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner121_.UnreadByte(); err != nil {
			return fmt.Errorf("read Options: unexpected unread error: %w", err)
		}
		var tmp122_ Ndpoption
		if err := tmp122_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp122_)
	}
	r = old_r_Options
	return nil
}

func (t *NdprouterSolicitation) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NdprouterSolicitation) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NdprouterSolicitation: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NdprouterAdvertisement) ManagedAddrConfig() bool {
	return ((t.flags123 & 0x80) >> 7) == 1
}
func (t *NdprouterAdvertisement) SetManagedAddrConfig(v bool) {
	if v {
		t.flags123 |= uint8(0x80)
	} else {
		t.flags123 &= ^uint8(0x80)
	}
}
func (t *NdprouterAdvertisement) OtherStatefulConfig() bool {
	return ((t.flags123 & 0x40) >> 6) == 1
}
func (t *NdprouterAdvertisement) SetOtherStatefulConfig(v bool) {
	if v {
		t.flags123 |= uint8(0x40)
	} else {
		t.flags123 &= ^uint8(0x40)
	}
}
func (t *NdprouterAdvertisement) Reserved() uint8 {
	return ((t.flags123 & 0x3f) >> 0)
}
func (t *NdprouterAdvertisement) SetReserved(v uint8) bool {
	if v > 63 {
		return false
	}
	t.flags123 = (t.flags123 & ^uint8(0x3f)) | ((v & 0x3f) << 0)
	return true
}
func (t *NdprouterAdvertisement) Visit(v VisitorKEYKW) {
	v.Visit(v, "CurHopLimit", &t.CurHopLimit)
	v.Visit(v, "ManagedAddrConfig", (func() uint8 {
		if t.ManagedAddrConfig() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "OtherStatefulConfig", (func() uint8 {
		if t.OtherStatefulConfig() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved", t.Reserved())
	v.Visit(v, "RouterLifetime", &t.RouterLifetime)
	v.Visit(v, "ReachableTime", &t.ReachableTime)
	v.Visit(v, "RetransTimer", &t.RetransTimer)
	v.Visit(v, "Options", &t.Options)
}
func (t *NdprouterAdvertisement) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *NdprouterAdvertisement) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.CurHopLimit)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.CurHopLimit: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags123)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags123: %w", err)
	}
	tmp124 := [2]byte{}
	binary.BigEndian.PutUint16(tmp124[:], uint16(t.RouterLifetime))
	if n, err := w.Write(tmp124[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.RouterLifetime: %w", err)
	}
	tmp125 := [4]byte{}
	binary.BigEndian.PutUint32(tmp125[:], uint32(t.ReachableTime))
	if n, err := w.Write(tmp125[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.ReachableTime: %w", err)
	}
	tmp126 := [4]byte{}
	binary.BigEndian.PutUint32(tmp126[:], uint32(t.RetransTimer))
	if n, err := w.Write(tmp126[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.RetransTimer: %w", err)
	}
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	return nil
}
func (t *NdprouterAdvertisement) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 12))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NdprouterAdvertisement) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NdprouterAdvertisement) Read(r io.Reader) (err error) {
	tmpCurHopLimit := [1]byte{}
	n_CurHopLimit, err := io.ReadFull(r, tmpCurHopLimit[:])
	if err != nil {
		return fmt.Errorf("read CurHopLimit: expect 1 byte but read %d bytes: %w", n_CurHopLimit, err)
	}
	t.CurHopLimit = uint8(tmpCurHopLimit[0])
	tmpflags123 := [1]byte{}
	n_flags123, err := io.ReadFull(r, tmpflags123[:])
	if err != nil {
		return fmt.Errorf("read flags123: expect 1 byte but read %d bytes: %w", n_flags123, err)
	}
	t.flags123 = uint8(tmpflags123[0])
	tmpRouterLifetime := [2]byte{}
	n_RouterLifetime, err := io.ReadFull(r, tmpRouterLifetime[:])
	if err != nil {
		return fmt.Errorf("read RouterLifetime: expect 2 bytes but read %d bytes: %w", n_RouterLifetime, err)
	}
	t.RouterLifetime = uint16(binary.BigEndian.Uint16(tmpRouterLifetime[:]))
	tmpReachableTime := [4]byte{}
	n_ReachableTime, err := io.ReadFull(r, tmpReachableTime[:])
	if err != nil {
		return fmt.Errorf("read ReachableTime: expect 4 bytes but read %d bytes: %w", n_ReachableTime, err)
	}
	t.ReachableTime = uint32(binary.BigEndian.Uint32(tmpReachableTime[:]))
	tmpRetransTimer := [4]byte{}
	n_RetransTimer, err := io.ReadFull(r, tmpRetransTimer[:])
	if err != nil {
		return fmt.Errorf("read RetransTimer: expect 4 bytes but read %d bytes: %w", n_RetransTimer, err)
	}
	t.RetransTimer = uint32(binary.BigEndian.Uint32(tmpRetransTimer[:]))
	tmp_byte_scanner127_ := bufio.NewReaderSize(r, 1)
	old_r_Options := r
	r = tmp_byte_scanner127_
	for {
		_, err := tmp_byte_scanner127_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Options: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner127_.UnreadByte(); err != nil {
			return fmt.Errorf("read Options: unexpected unread error: %w", err)
		}
		var tmp128_ Ndpoption
		if err := tmp128_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp128_)
	}
	r = old_r_Options
	return nil
}

func (t *NdprouterAdvertisement) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NdprouterAdvertisement) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NdprouterAdvertisement: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NdpneighborSolicitation) Visit(v VisitorKEYKW) {
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "TargetAddr", &t.TargetAddr)
	v.Visit(v, "Options", &t.Options)
}
func (t *NdpneighborSolicitation) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *NdpneighborSolicitation) Write(w io.Writer) (err error) {
	tmp129 := [4]byte{}
	binary.BigEndian.PutUint32(tmp129[:], uint32(t.Reserved))
	if n, err := w.Write(tmp129[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	if n, err := w.Write(t.TargetAddr[:]); err != nil || n != len(t.TargetAddr) {
		return fmt.Errorf("encode TargetAddr: %w", err)
	}
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	return nil
}
func (t *NdpneighborSolicitation) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 20))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NdpneighborSolicitation) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NdpneighborSolicitation) Read(r io.Reader) (err error) {
	tmpReserved := [4]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 4 bytes but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint32(binary.BigEndian.Uint32(tmpReserved[:]))
	n_TargetAddr, err := io.ReadFull(r, t.TargetAddr[:])
	if err != nil {
		return fmt.Errorf("read TargetAddr: expect %d bytes but read %d bytes: %w", 16, n_TargetAddr, err)
	}
	tmp_byte_scanner130_ := bufio.NewReaderSize(r, 1)
	old_r_Options := r
	r = tmp_byte_scanner130_
	for {
		_, err := tmp_byte_scanner130_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Options: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner130_.UnreadByte(); err != nil {
			return fmt.Errorf("read Options: unexpected unread error: %w", err)
		}
		var tmp131_ Ndpoption
		if err := tmp131_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp131_)
	}
	r = old_r_Options
	return nil
}

func (t *NdpneighborSolicitation) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NdpneighborSolicitation) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NdpneighborSolicitation: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NdpneighborAdvertisement) Router() bool {
	return ((t.flags132 & 0x80000000) >> 31) == 1
}
func (t *NdpneighborAdvertisement) SetRouter(v bool) {
	if v {
		t.flags132 |= uint32(0x80000000)
	} else {
		t.flags132 &= ^uint32(0x80000000)
	}
}
func (t *NdpneighborAdvertisement) Solicited() bool {
	return ((t.flags132 & 0x40000000) >> 30) == 1
}
func (t *NdpneighborAdvertisement) SetSolicited(v bool) {
	if v {
		t.flags132 |= uint32(0x40000000)
	} else {
		t.flags132 &= ^uint32(0x40000000)
	}
}
func (t *NdpneighborAdvertisement) Override() bool {
	return ((t.flags132 & 0x20000000) >> 29) == 1
}
func (t *NdpneighborAdvertisement) SetOverride(v bool) {
	if v {
		t.flags132 |= uint32(0x20000000)
	} else {
		t.flags132 &= ^uint32(0x20000000)
	}
}
func (t *NdpneighborAdvertisement) Flags() uint32 {
	return ((t.flags132 & 0x1fffffff) >> 0)
}
func (t *NdpneighborAdvertisement) SetFlags(v uint32) bool {
	if v > 536870911 {
		return false
	}
	t.flags132 = (t.flags132 & ^uint32(0x1fffffff)) | ((v & 0x1fffffff) << 0)
	return true
}
func (t *NdpneighborAdvertisement) Visit(v VisitorKEYKW) {
	v.Visit(v, "Router", (func() uint32 {
		if t.Router() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Solicited", (func() uint32 {
		if t.Solicited() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Override", (func() uint32 {
		if t.Override() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Flags", t.Flags())
	v.Visit(v, "TargetAddr", &t.TargetAddr)
	v.Visit(v, "Options", &t.Options)
}
func (t *NdpneighborAdvertisement) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *NdpneighborAdvertisement) Write(w io.Writer) (err error) {
	tmp133 := [4]byte{}
	binary.BigEndian.PutUint32(tmp133[:], uint32(t.flags132))
	if n, err := w.Write(tmp133[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.flags132: %w", err)
	}
	if n, err := w.Write(t.TargetAddr[:]); err != nil || n != len(t.TargetAddr) {
		return fmt.Errorf("encode TargetAddr: %w", err)
	}
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	return nil
}
func (t *NdpneighborAdvertisement) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 20))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NdpneighborAdvertisement) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NdpneighborAdvertisement) Read(r io.Reader) (err error) {
	tmpflags132 := [4]byte{}
	n_flags132, err := io.ReadFull(r, tmpflags132[:])
	if err != nil {
		return fmt.Errorf("read flags132: expect 4 bytes but read %d bytes: %w", n_flags132, err)
	}
	t.flags132 = uint32(binary.BigEndian.Uint32(tmpflags132[:]))
	n_TargetAddr, err := io.ReadFull(r, t.TargetAddr[:])
	if err != nil {
		return fmt.Errorf("read TargetAddr: expect %d bytes but read %d bytes: %w", 16, n_TargetAddr, err)
	}
	tmp_byte_scanner134_ := bufio.NewReaderSize(r, 1)
	old_r_Options := r
	r = tmp_byte_scanner134_
	for {
		_, err := tmp_byte_scanner134_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Options: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner134_.UnreadByte(); err != nil {
			return fmt.Errorf("read Options: unexpected unread error: %w", err)
		}
		var tmp135_ Ndpoption
		if err := tmp135_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp135_)
	}
	r = old_r_Options
	return nil
}

func (t *NdpneighborAdvertisement) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NdpneighborAdvertisement) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NdpneighborAdvertisement: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NdpredirectMessage) Visit(v VisitorKEYKW) {
	v.Visit(v, "TargetAddr", &t.TargetAddr)
	v.Visit(v, "DestAddr", &t.DestAddr)
	v.Visit(v, "Options", &t.Options)
}
func (t *NdpredirectMessage) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *NdpredirectMessage) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.TargetAddr[:]); err != nil || n != len(t.TargetAddr) {
		return fmt.Errorf("encode TargetAddr: %w", err)
	}
	if n, err := w.Write(t.DestAddr[:]); err != nil || n != len(t.DestAddr) {
		return fmt.Errorf("encode DestAddr: %w", err)
	}
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	return nil
}
func (t *NdpredirectMessage) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 32))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NdpredirectMessage) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NdpredirectMessage) Read(r io.Reader) (err error) {
	n_TargetAddr, err := io.ReadFull(r, t.TargetAddr[:])
	if err != nil {
		return fmt.Errorf("read TargetAddr: expect %d bytes but read %d bytes: %w", 16, n_TargetAddr, err)
	}
	n_DestAddr, err := io.ReadFull(r, t.DestAddr[:])
	if err != nil {
		return fmt.Errorf("read DestAddr: expect %d bytes but read %d bytes: %w", 16, n_DestAddr, err)
	}
	tmp_byte_scanner136_ := bufio.NewReaderSize(r, 1)
	old_r_Options := r
	r = tmp_byte_scanner136_
	for {
		_, err := tmp_byte_scanner136_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Options: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner136_.UnreadByte(); err != nil {
			return fmt.Errorf("read Options: unexpected unread error: %w", err)
		}
		var tmp137_ Ndpoption
		if err := tmp137_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp137_)
	}
	r = old_r_Options
	return nil
}

func (t *NdpredirectMessage) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NdpredirectMessage) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NdpredirectMessage: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *V2MulticastListernerReport) SetRecords(v []MulticastAddressRecord) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.NumberOfRecords = uint16(len(v))
	t.Records = v
	return true
}
func (t *V2MulticastListernerReport) Visit(v VisitorKEYKW) {
	v.Visit(v, "Reserved1", &t.Reserved1)
	v.Visit(v, "NumberOfRecords", &t.NumberOfRecords)
	v.Visit(v, "Records", &t.Records)
}
func (t *V2MulticastListernerReport) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *V2MulticastListernerReport) Write(w io.Writer) (err error) {
	tmp138 := [2]byte{}
	binary.BigEndian.PutUint16(tmp138[:], uint16(t.Reserved1))
	if n, err := w.Write(tmp138[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Reserved1: %w", err)
	}
	tmp139 := [2]byte{}
	binary.BigEndian.PutUint16(tmp139[:], uint16(t.NumberOfRecords))
	if n, err := w.Write(tmp139[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.NumberOfRecords: %w", err)
	}
	len_Records := int(t.NumberOfRecords)
	if len(t.Records) != len_Records {
		return fmt.Errorf("encode Records: expect %d but got %d for length", len_Records, len(t.Records))
	}
	for _, v := range t.Records {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Records: %w", err)
		}
	}
	return nil
}
func (t *V2MulticastListernerReport) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *V2MulticastListernerReport) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *V2MulticastListernerReport) Read(r io.Reader) (err error) {
	tmpReserved1 := [2]byte{}
	n_Reserved1, err := io.ReadFull(r, tmpReserved1[:])
	if err != nil {
		return fmt.Errorf("read Reserved1: expect 2 bytes but read %d bytes: %w", n_Reserved1, err)
	}
	t.Reserved1 = uint16(binary.BigEndian.Uint16(tmpReserved1[:]))
	tmpNumberOfRecords := [2]byte{}
	n_NumberOfRecords, err := io.ReadFull(r, tmpNumberOfRecords[:])
	if err != nil {
		return fmt.Errorf("read NumberOfRecords: expect 2 bytes but read %d bytes: %w", n_NumberOfRecords, err)
	}
	t.NumberOfRecords = uint16(binary.BigEndian.Uint16(tmpNumberOfRecords[:]))
	len_Records := int(t.NumberOfRecords)
	for i_140 := 0; i_140 < len_Records; i_140++ {
		var tmp141_ MulticastAddressRecord
		if err := tmp141_.Read(r); err != nil {
			return fmt.Errorf("read Records: %w", err)
		}
		t.Records = append(t.Records, tmp141_)
	}
	return nil
}

func (t *V2MulticastListernerReport) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *V2MulticastListernerReport) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode V2MulticastListernerReport: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SegmentRouting) SetSegmentList(v [][16]uint8) bool {
	t.SegmentList = v
	return true
}
func (t *SegmentRouting) Visit(v VisitorKEYKW) {
	v.Visit(v, "Header", &t.Header)
	v.Visit(v, "RoutingType", &t.RoutingType)
	v.Visit(v, "SegmentsLeft", &t.SegmentsLeft)
	v.Visit(v, "LastEntry", &t.LastEntry)
	v.Visit(v, "Flags", &t.Flags)
	v.Visit(v, "Tag", &t.Tag)
	v.Visit(v, "SegmentList", &t.SegmentList)
	v.Visit(v, "Options", &t.Options)
}
func (t *SegmentRouting) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *SegmentRouting) Write(w io.Writer) (err error) {
	if err := t.Header.Write(w); err != nil {
		return fmt.Errorf("encode Header: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.RoutingType)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.RoutingType: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.SegmentsLeft)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.SegmentsLeft: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.LastEntry)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.LastEntry: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Flags)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Flags: %w", err)
	}
	tmp142 := [2]byte{}
	binary.BigEndian.PutUint16(tmp142[:], uint16(t.Tag))
	if n, err := w.Write(tmp142[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Tag: %w", err)
	}
	len_SegmentList := int((t.LastEntry + 1))
	if len(t.SegmentList) != len_SegmentList {
		return fmt.Errorf("encode SegmentList: expect %d but got %d for length", len_SegmentList, len(t.SegmentList))
	}
	for _, v := range t.SegmentList {
		if n, err := w.Write(v[:]); err != nil || n != len(v) {
			return fmt.Errorf("encode SegmentList: %w", err)
		}
	}
	RemainingInByte := ((uint16(t.Header.HdrExtLen) * 8) - ((uint16(t.LastEntry) + 1) * 16))
	new_buf_143 := bytes.NewBuffer(nil)
	old_buf_143_w := w
	w = new_buf_143
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	if new_buf_143.Len() != int(RemainingInByte) {
		return fmt.Errorf("encode Options: expect %d bytes but got %d bytes", new_buf_143.Len(), int(RemainingInByte))
	}
	_, err = new_buf_143.WriteTo(old_buf_143_w)
	if err != nil {
		return err
	}
	w = old_buf_143_w
	return nil
}
func (t *SegmentRouting) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SegmentRouting) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SegmentRouting) Read(r io.Reader) (err error) {
	if err := t.Header.Read(r); err != nil {
		return fmt.Errorf("read Header: %w", err)
	}
	tmpRoutingType := [1]byte{}
	n_RoutingType, err := io.ReadFull(r, tmpRoutingType[:])
	if err != nil {
		return fmt.Errorf("read RoutingType: expect 1 byte but read %d bytes: %w", n_RoutingType, err)
	}
	t.RoutingType = uint8(tmpRoutingType[0])
	tmpSegmentsLeft := [1]byte{}
	n_SegmentsLeft, err := io.ReadFull(r, tmpSegmentsLeft[:])
	if err != nil {
		return fmt.Errorf("read SegmentsLeft: expect 1 byte but read %d bytes: %w", n_SegmentsLeft, err)
	}
	t.SegmentsLeft = uint8(tmpSegmentsLeft[0])
	tmpLastEntry := [1]byte{}
	n_LastEntry, err := io.ReadFull(r, tmpLastEntry[:])
	if err != nil {
		return fmt.Errorf("read LastEntry: expect 1 byte but read %d bytes: %w", n_LastEntry, err)
	}
	t.LastEntry = uint8(tmpLastEntry[0])
	tmpFlags := [1]byte{}
	n_Flags, err := io.ReadFull(r, tmpFlags[:])
	if err != nil {
		return fmt.Errorf("read Flags: expect 1 byte but read %d bytes: %w", n_Flags, err)
	}
	t.Flags = uint8(tmpFlags[0])
	tmpTag := [2]byte{}
	n_Tag, err := io.ReadFull(r, tmpTag[:])
	if err != nil {
		return fmt.Errorf("read Tag: expect 2 bytes but read %d bytes: %w", n_Tag, err)
	}
	t.Tag = uint16(binary.BigEndian.Uint16(tmpTag[:]))
	len_SegmentList := int((t.LastEntry + 1))
	for i_144 := 0; i_144 < len_SegmentList; i_144++ {
		var tmp145_ [16]uint8
		n_SegmentList, err := io.ReadFull(r, tmp145_[:])
		if err != nil {
			return fmt.Errorf("read SegmentList: expect %d bytes but read %d bytes: %w", 16, n_SegmentList, err)
		}
		t.SegmentList = append(t.SegmentList, tmp145_)
	}
	RemainingInByte := ((uint16(t.Header.HdrExtLen) * 8) - ((uint16(t.LastEntry) + 1) * 16))
	sub_byte_len_Options := int64(RemainingInByte)
	sub_byte_r_Options := io.LimitReader(r, int64(sub_byte_len_Options))
	tmp_old_r_Options_146 := r
	r = sub_byte_r_Options
	len_Options := int(r.(*io.LimitedReader).N)
	tmpOptions := make([]byte, len_Options)
	n_Options, err := io.ReadFull(r, tmpOptions[:])
	if err != nil {
		return fmt.Errorf("read Options: expect %d bytes but read %d bytes: %w", len_Options, n_Options, err)
	}
	range_tmp_Options := bytes.NewReader(tmpOptions[:])
	tmp_old_r_Options := r
	r = range_tmp_Options
	for range_tmp_Options.Len() > 0 {
		var tmp147_ SegmentRoutingTlv
		if err := tmp147_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp147_)
	}
	r = tmp_old_r_Options
	if sub_byte_r_Options.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Options: expect %d bytes but got %d bytes", sub_byte_len_Options, sub_byte_len_Options-sub_byte_r_Options.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Options_146
	return nil
}

func (t *SegmentRouting) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SegmentRouting) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SegmentRouting: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Update) Visit(v VisitorKEYKW) {
	v.Visit(v, "WithdrawnRoutes", &t.WithdrawnRoutes)
	v.Visit(v, "PathAttr", &t.PathAttr)
	v.Visit(v, "NetworkReachabilityInfo", &t.NetworkReachabilityInfo)
}
func (t *Update) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Update) Write(w io.Writer) (err error) {
	if err := t.WithdrawnRoutes.Write(w); err != nil {
		return fmt.Errorf("encode WithdrawnRoutes: %w", err)
	}
	if err := t.PathAttr.Write(w); err != nil {
		return fmt.Errorf("encode PathAttr: %w", err)
	}
	for _, v := range t.NetworkReachabilityInfo {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode NetworkReachabilityInfo: %w", err)
		}
	}
	return nil
}
func (t *Update) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Update) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Update) Read(r io.Reader) (err error) {
	if err := t.WithdrawnRoutes.Read(r); err != nil {
		return fmt.Errorf("read WithdrawnRoutes: %w", err)
	}
	if err := t.PathAttr.Read(r); err != nil {
		return fmt.Errorf("read PathAttr: %w", err)
	}
	tmp_byte_scanner148_ := bufio.NewReaderSize(r, 1)
	old_r_NetworkReachabilityInfo := r
	r = tmp_byte_scanner148_
	for {
		_, err := tmp_byte_scanner148_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read NetworkReachabilityInfo: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner148_.UnreadByte(); err != nil {
			return fmt.Errorf("read NetworkReachabilityInfo: unexpected unread error: %w", err)
		}
		var tmp149_ NetWorkReachabilityInfo
		if err := tmp149_.Read(r); err != nil {
			return fmt.Errorf("read NetworkReachabilityInfo: %w", err)
		}
		t.NetworkReachabilityInfo = append(t.NetworkReachabilityInfo, tmp149_)
	}
	r = old_r_NetworkReachabilityInfo
	return nil
}

func (t *Update) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Update) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Update: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_152_t) isunion150_() {}
func (t *union_153_t) isunion150_() {}
func (t *union_154_t) isunion150_() {}
func (t *union_155_t) isunion150_() {}
func (t *Bgppacket) Notification() *Notification {
	if t.Header.Type == Bgptype_Open {
		return nil
	} else if t.Header.Type == Bgptype_Update {
		return nil
	} else if t.Header.Type == Bgptype_Notification {
		if _, ok := t.union150_.(*union_154_t); !ok {
			return nil // not set
		}
		tmp := Notification(t.union150_.(*union_154_t).Notification)
		return &tmp
	}
	return nil
}
func (t *Bgppacket) SetNotification(v Notification) bool {
	if t.Header.Type == Bgptype_Open {
		return false
	} else if t.Header.Type == Bgptype_Update {
		return false
	} else if t.Header.Type == Bgptype_Notification {
		if _, ok := t.union150_.(*union_154_t); !ok {
			t.union150_ = &union_154_t{}
		}
		t.union150_.(*union_154_t).Notification = Notification(v)
		return true
	}
	return false
}
func (t *Bgppacket) Open() *Open {
	if t.Header.Type == Bgptype_Open {
		if _, ok := t.union150_.(*union_152_t); !ok {
			return nil // not set
		}
		tmp := Open(t.union150_.(*union_152_t).Open)
		return &tmp
	}
	return nil
}
func (t *Bgppacket) SetOpen(v Open) bool {
	if t.Header.Type == Bgptype_Open {
		if _, ok := t.union150_.(*union_152_t); !ok {
			t.union150_ = &union_152_t{}
		}
		t.union150_.(*union_152_t).Open = Open(v)
		return true
	}
	return false
}
func (t *Bgppacket) Update() *Update {
	if t.Header.Type == Bgptype_Open {
		return nil
	} else if t.Header.Type == Bgptype_Update {
		if _, ok := t.union150_.(*union_153_t); !ok {
			return nil // not set
		}
		tmp := Update(t.union150_.(*union_153_t).Update)
		return &tmp
	}
	return nil
}
func (t *Bgppacket) SetUpdate(v Update) bool {
	if t.Header.Type == Bgptype_Open {
		return false
	} else if t.Header.Type == Bgptype_Update {
		if _, ok := t.union150_.(*union_153_t); !ok {
			t.union150_ = &union_153_t{}
		}
		t.union150_.(*union_153_t).Update = Update(v)
		return true
	}
	return false
}
func (t *Bgppacket) Visit(v VisitorKEYKW) {
	v.Visit(v, "Header", &t.Header)
	v.Visit(v, "Notification", (t.Notification()))
	v.Visit(v, "Open", (t.Open()))
	v.Visit(v, "Update", (t.Update()))
}
func (t *Bgppacket) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Bgppacket) Write(w io.Writer) (err error) {
	if err := t.Header.Write(w); err != nil {
		return fmt.Errorf("encode Header: %w", err)
	}
	switch {
	case (t.Header.Type == Bgptype_Open):
		if _, ok := t.union150_.(*union_152_t); !ok {
			return fmt.Errorf("encode t.union150_: union is not set to union_152_t")
		}
		new_buf_156 := bytes.NewBuffer(nil)
		old_buf_156_w := w
		w = new_buf_156
		if err := t.union150_.(*union_152_t).Open.Write(w); err != nil {
			return fmt.Errorf("encode Open: %w", err)
		}
		if new_buf_156.Len() != int((t.Header.Length - 19)) {
			return fmt.Errorf("encode Open: expect %d bytes but got %d bytes", new_buf_156.Len(), int((t.Header.Length - 19)))
		}
		_, err = new_buf_156.WriteTo(old_buf_156_w)
		if err != nil {
			return err
		}
		w = old_buf_156_w
	case (t.Header.Type == Bgptype_Update):
		if _, ok := t.union150_.(*union_153_t); !ok {
			return fmt.Errorf("encode t.union150_: union is not set to union_153_t")
		}
		new_buf_157 := bytes.NewBuffer(nil)
		old_buf_157_w := w
		w = new_buf_157
		if err := t.union150_.(*union_153_t).Update.Write(w); err != nil {
			return fmt.Errorf("encode Update: %w", err)
		}
		if new_buf_157.Len() != int((t.Header.Length - 19)) {
			return fmt.Errorf("encode Update: expect %d bytes but got %d bytes", new_buf_157.Len(), int((t.Header.Length - 19)))
		}
		_, err = new_buf_157.WriteTo(old_buf_157_w)
		if err != nil {
			return err
		}
		w = old_buf_157_w
	case (t.Header.Type == Bgptype_Notification):
		if _, ok := t.union150_.(*union_154_t); !ok {
			return fmt.Errorf("encode t.union150_: union is not set to union_154_t")
		}
		new_buf_158 := bytes.NewBuffer(nil)
		old_buf_158_w := w
		w = new_buf_158
		if err := t.union150_.(*union_154_t).Notification.Write(w); err != nil {
			return fmt.Errorf("encode Notification: %w", err)
		}
		if new_buf_158.Len() != int((t.Header.Length - 19)) {
			return fmt.Errorf("encode Notification: expect %d bytes but got %d bytes", new_buf_158.Len(), int((t.Header.Length - 19)))
		}
		_, err = new_buf_158.WriteTo(old_buf_158_w)
		if err != nil {
			return err
		}
		w = old_buf_158_w
	case (t.Header.Type == Bgptype_Keepalive):
	}
	return nil
}
func (t *Bgppacket) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 19))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Bgppacket) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Bgppacket) Read(r io.Reader) (err error) {
	if err := t.Header.Read(r); err != nil {
		return fmt.Errorf("read Header: %w", err)
	}
	switch {
	case (t.Header.Type == Bgptype_Open):
		t.union150_ = &union_152_t{}
		sub_byte_len_Open := int64((t.Header.Length - 19))
		sub_byte_r_Open := io.LimitReader(r, int64(sub_byte_len_Open))
		tmp_old_r_Open_159 := r
		r = sub_byte_r_Open
		if err := t.union150_.(*union_152_t).Open.Read(r); err != nil {
			return fmt.Errorf("read Open: %w", err)
		}
		if sub_byte_r_Open.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Open: expect %d bytes but got %d bytes", sub_byte_len_Open, sub_byte_len_Open-sub_byte_r_Open.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Open_159
	case (t.Header.Type == Bgptype_Update):
		t.union150_ = &union_153_t{}
		sub_byte_len_Update := int64((t.Header.Length - 19))
		sub_byte_r_Update := io.LimitReader(r, int64(sub_byte_len_Update))
		tmp_old_r_Update_160 := r
		r = sub_byte_r_Update
		if err := t.union150_.(*union_153_t).Update.Read(r); err != nil {
			return fmt.Errorf("read Update: %w", err)
		}
		if sub_byte_r_Update.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Update: expect %d bytes but got %d bytes", sub_byte_len_Update, sub_byte_len_Update-sub_byte_r_Update.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Update_160
	case (t.Header.Type == Bgptype_Notification):
		t.union150_ = &union_154_t{}
		sub_byte_len_Notification := int64((t.Header.Length - 19))
		sub_byte_r_Notification := io.LimitReader(r, int64(sub_byte_len_Notification))
		tmp_old_r_Notification_161 := r
		r = sub_byte_r_Notification
		if err := t.union150_.(*union_154_t).Notification.Read(r); err != nil {
			return fmt.Errorf("read Notification: %w", err)
		}
		if sub_byte_r_Notification.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Notification: expect %d bytes but got %d bytes", sub_byte_len_Notification, sub_byte_len_Notification-sub_byte_r_Notification.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Notification_161
	case (t.Header.Type == Bgptype_Keepalive):
	}
	return nil
}

func (t *Bgppacket) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Bgppacket) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Bgppacket: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_164_t) isunion162_() {}
func (t *union_165_t) isunion162_() {}
func (t *union_166_t) isunion162_() {}
func (t *union_167_t) isunion162_() {}
func (t *union_168_t) isunion162_() {}
func (t *union_169_t) isunion162_() {}
func (t *union_170_t) isunion162_() {}
func (t *union_171_t) isunion162_() {}
func (t *union_172_t) isunion162_() {}
func (t *union_173_t) isunion162_() {}
func (t *union_174_t) isunion162_() {}
func (t *union_175_t) isunion162_() {}
func (t *union_176_t) isunion162_() {}
func (t *union_177_t) isunion162_() {}
func (t *Icmpv6Packet) Data() *[]uint8 {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_V2MulticastListenerReport {
		return nil
	} else if true {
		if _, ok := t.union162_.(*union_177_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union162_.(*union_177_t).Data)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetData(v []uint8) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_V2MulticastListenerReport {
		return false
	} else if true {
		if _, ok := t.union162_.(*union_177_t); !ok {
			t.union162_ = &union_177_t{}
		}
		t.union162_.(*union_177_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) DestinationUnreachable() *IcmpdestinationUnreachable {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		if _, ok := t.union162_.(*union_169_t); !ok {
			return nil // not set
		}
		tmp := IcmpdestinationUnreachable(t.union162_.(*union_169_t).DestinationUnreachable)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetDestinationUnreachable(v IcmpdestinationUnreachable) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		if _, ok := t.union162_.(*union_169_t); !ok {
			t.union162_ = &union_169_t{}
		}
		t.union162_.(*union_169_t).DestinationUnreachable = IcmpdestinationUnreachable(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) EchoReply() *Icmpecho {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		if _, ok := t.union162_.(*union_165_t); !ok {
			return nil // not set
		}
		tmp := Icmpecho(t.union162_.(*union_165_t).EchoReply)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetEchoReply(v Icmpecho) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		if _, ok := t.union162_.(*union_165_t); !ok {
			t.union162_ = &union_165_t{}
		}
		t.union162_.(*union_165_t).EchoReply = Icmpecho(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) EchoRequest() *Icmpecho {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		if _, ok := t.union162_.(*union_164_t); !ok {
			return nil // not set
		}
		tmp := Icmpecho(t.union162_.(*union_164_t).EchoRequest)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetEchoRequest(v Icmpecho) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		if _, ok := t.union162_.(*union_164_t); !ok {
			t.union162_ = &union_164_t{}
		}
		t.union162_.(*union_164_t).EchoRequest = Icmpecho(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) MulticastListenerQuery() *MulticastListenerQuery {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery {
		if _, ok := t.union162_.(*union_175_t); !ok {
			return nil // not set
		}
		tmp := MulticastListenerQuery(t.union162_.(*union_175_t).MulticastListenerQuery)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetMulticastListenerQuery(v MulticastListenerQuery) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery {
		if _, ok := t.union162_.(*union_175_t); !ok {
			t.union162_ = &union_175_t{}
		}
		t.union162_.(*union_175_t).MulticastListenerQuery = MulticastListenerQuery(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) NeighborAdvertisement() *NdpneighborAdvertisement {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		if _, ok := t.union162_.(*union_173_t); !ok {
			return nil // not set
		}
		tmp := NdpneighborAdvertisement(t.union162_.(*union_173_t).NeighborAdvertisement)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetNeighborAdvertisement(v NdpneighborAdvertisement) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		if _, ok := t.union162_.(*union_173_t); !ok {
			t.union162_ = &union_173_t{}
		}
		t.union162_.(*union_173_t).NeighborAdvertisement = NdpneighborAdvertisement(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) NeighborSolicitation() *NdpneighborSolicitation {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		if _, ok := t.union162_.(*union_172_t); !ok {
			return nil // not set
		}
		tmp := NdpneighborSolicitation(t.union162_.(*union_172_t).NeighborSolicitation)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetNeighborSolicitation(v NdpneighborSolicitation) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		if _, ok := t.union162_.(*union_172_t); !ok {
			t.union162_ = &union_172_t{}
		}
		t.union162_.(*union_172_t).NeighborSolicitation = NdpneighborSolicitation(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) PacketTooBig() *IcmppacketTooBig {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		if _, ok := t.union162_.(*union_167_t); !ok {
			return nil // not set
		}
		tmp := IcmppacketTooBig(t.union162_.(*union_167_t).PacketTooBig)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetPacketTooBig(v IcmppacketTooBig) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		if _, ok := t.union162_.(*union_167_t); !ok {
			t.union162_ = &union_167_t{}
		}
		t.union162_.(*union_167_t).PacketTooBig = IcmppacketTooBig(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) ParameterProblem() *Icmpv6ParameterProblem {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		if _, ok := t.union162_.(*union_168_t); !ok {
			return nil // not set
		}
		tmp := Icmpv6ParameterProblem(t.union162_.(*union_168_t).ParameterProblem)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetParameterProblem(v Icmpv6ParameterProblem) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		if _, ok := t.union162_.(*union_168_t); !ok {
			t.union162_ = &union_168_t{}
		}
		t.union162_.(*union_168_t).ParameterProblem = Icmpv6ParameterProblem(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) RedirectMessage() *NdpredirectMessage {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		if _, ok := t.union162_.(*union_174_t); !ok {
			return nil // not set
		}
		tmp := NdpredirectMessage(t.union162_.(*union_174_t).RedirectMessage)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetRedirectMessage(v NdpredirectMessage) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		if _, ok := t.union162_.(*union_174_t); !ok {
			t.union162_ = &union_174_t{}
		}
		t.union162_.(*union_174_t).RedirectMessage = NdpredirectMessage(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) RouterAdvertisement() *NdprouterAdvertisement {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		if _, ok := t.union162_.(*union_171_t); !ok {
			return nil // not set
		}
		tmp := NdprouterAdvertisement(t.union162_.(*union_171_t).RouterAdvertisement)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetRouterAdvertisement(v NdprouterAdvertisement) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		if _, ok := t.union162_.(*union_171_t); !ok {
			t.union162_ = &union_171_t{}
		}
		t.union162_.(*union_171_t).RouterAdvertisement = NdprouterAdvertisement(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) RouterSolicitation() *NdprouterSolicitation {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		if _, ok := t.union162_.(*union_170_t); !ok {
			return nil // not set
		}
		tmp := NdprouterSolicitation(t.union162_.(*union_170_t).RouterSolicitation)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetRouterSolicitation(v NdprouterSolicitation) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		if _, ok := t.union162_.(*union_170_t); !ok {
			t.union162_ = &union_170_t{}
		}
		t.union162_.(*union_170_t).RouterSolicitation = NdprouterSolicitation(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) TimeExceeded() *Icmpv6ParameterProblem {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		if _, ok := t.union162_.(*union_166_t); !ok {
			return nil // not set
		}
		tmp := Icmpv6ParameterProblem(t.union162_.(*union_166_t).TimeExceeded)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetTimeExceeded(v Icmpv6ParameterProblem) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		if _, ok := t.union162_.(*union_166_t); !ok {
			t.union162_ = &union_166_t{}
		}
		t.union162_.(*union_166_t).TimeExceeded = Icmpv6ParameterProblem(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) V2MulticastListenerReport() *V2MulticastListernerReport {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery {
		return nil
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_V2MulticastListenerReport {
		if _, ok := t.union162_.(*union_176_t); !ok {
			return nil // not set
		}
		tmp := V2MulticastListernerReport(t.union162_.(*union_176_t).V2MulticastListenerReport)
		return &tmp
	}
	return nil
}
func (t *Icmpv6Packet) SetV2MulticastListenerReport(v V2MulticastListernerReport) bool {
	if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery {
		return false
	} else if Icmpv6Type(t.Header.Type) == Icmpv6Type_V2MulticastListenerReport {
		if _, ok := t.union162_.(*union_176_t); !ok {
			t.union162_ = &union_176_t{}
		}
		t.union162_.(*union_176_t).V2MulticastListenerReport = V2MulticastListernerReport(v)
		return true
	}
	return false
}
func (t *Icmpv6Packet) Visit(v VisitorKEYKW) {
	v.Visit(v, "Header", &t.Header)
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "DestinationUnreachable", (t.DestinationUnreachable()))
	v.Visit(v, "EchoReply", (t.EchoReply()))
	v.Visit(v, "EchoRequest", (t.EchoRequest()))
	v.Visit(v, "MulticastListenerQuery", (t.MulticastListenerQuery()))
	v.Visit(v, "NeighborAdvertisement", (t.NeighborAdvertisement()))
	v.Visit(v, "NeighborSolicitation", (t.NeighborSolicitation()))
	v.Visit(v, "PacketTooBig", (t.PacketTooBig()))
	v.Visit(v, "ParameterProblem", (t.ParameterProblem()))
	v.Visit(v, "RedirectMessage", (t.RedirectMessage()))
	v.Visit(v, "RouterAdvertisement", (t.RouterAdvertisement()))
	v.Visit(v, "RouterSolicitation", (t.RouterSolicitation()))
	v.Visit(v, "TimeExceeded", (t.TimeExceeded()))
	v.Visit(v, "V2MulticastListenerReport", (t.V2MulticastListenerReport()))
}
func (t *Icmpv6Packet) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorKEYKWToMap(t))
}
func (t *Icmpv6Packet) Write(w io.Writer) (err error) {
	if err := t.Header.Write(w); err != nil {
		return fmt.Errorf("encode Header: %w", err)
	}
	switch {
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest):
		if _, ok := t.union162_.(*union_164_t); !ok {
			return fmt.Errorf("encode t.union162_: union is not set to union_164_t")
		}
		if err := t.union162_.(*union_164_t).EchoRequest.Write(w); err != nil {
			return fmt.Errorf("encode EchoRequest: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply):
		if _, ok := t.union162_.(*union_165_t); !ok {
			return fmt.Errorf("encode t.union162_: union is not set to union_165_t")
		}
		if err := t.union162_.(*union_165_t).EchoReply.Write(w); err != nil {
			return fmt.Errorf("encode EchoReply: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded):
		if _, ok := t.union162_.(*union_166_t); !ok {
			return fmt.Errorf("encode t.union162_: union is not set to union_166_t")
		}
		if err := t.union162_.(*union_166_t).TimeExceeded.Write(w); err != nil {
			return fmt.Errorf("encode TimeExceeded: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig):
		if _, ok := t.union162_.(*union_167_t); !ok {
			return fmt.Errorf("encode t.union162_: union is not set to union_167_t")
		}
		if err := t.union162_.(*union_167_t).PacketTooBig.Write(w); err != nil {
			return fmt.Errorf("encode PacketTooBig: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem):
		if _, ok := t.union162_.(*union_168_t); !ok {
			return fmt.Errorf("encode t.union162_: union is not set to union_168_t")
		}
		if err := t.union162_.(*union_168_t).ParameterProblem.Write(w); err != nil {
			return fmt.Errorf("encode ParameterProblem: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable):
		if _, ok := t.union162_.(*union_169_t); !ok {
			return fmt.Errorf("encode t.union162_: union is not set to union_169_t")
		}
		if err := t.union162_.(*union_169_t).DestinationUnreachable.Write(w); err != nil {
			return fmt.Errorf("encode DestinationUnreachable: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation):
		if _, ok := t.union162_.(*union_170_t); !ok {
			return fmt.Errorf("encode t.union162_: union is not set to union_170_t")
		}
		if err := t.union162_.(*union_170_t).RouterSolicitation.Write(w); err != nil {
			return fmt.Errorf("encode RouterSolicitation: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement):
		if _, ok := t.union162_.(*union_171_t); !ok {
			return fmt.Errorf("encode t.union162_: union is not set to union_171_t")
		}
		if err := t.union162_.(*union_171_t).RouterAdvertisement.Write(w); err != nil {
			return fmt.Errorf("encode RouterAdvertisement: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation):
		if _, ok := t.union162_.(*union_172_t); !ok {
			return fmt.Errorf("encode t.union162_: union is not set to union_172_t")
		}
		if err := t.union162_.(*union_172_t).NeighborSolicitation.Write(w); err != nil {
			return fmt.Errorf("encode NeighborSolicitation: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement):
		if _, ok := t.union162_.(*union_173_t); !ok {
			return fmt.Errorf("encode t.union162_: union is not set to union_173_t")
		}
		if err := t.union162_.(*union_173_t).NeighborAdvertisement.Write(w); err != nil {
			return fmt.Errorf("encode NeighborAdvertisement: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage):
		if _, ok := t.union162_.(*union_174_t); !ok {
			return fmt.Errorf("encode t.union162_: union is not set to union_174_t")
		}
		if err := t.union162_.(*union_174_t).RedirectMessage.Write(w); err != nil {
			return fmt.Errorf("encode RedirectMessage: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery):
		if _, ok := t.union162_.(*union_175_t); !ok {
			return fmt.Errorf("encode t.union162_: union is not set to union_175_t")
		}
		if err := t.union162_.(*union_175_t).MulticastListenerQuery.Write(w); err != nil {
			return fmt.Errorf("encode MulticastListenerQuery: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_V2MulticastListenerReport):
		if _, ok := t.union162_.(*union_176_t); !ok {
			return fmt.Errorf("encode t.union162_: union is not set to union_176_t")
		}
		if err := t.union162_.(*union_176_t).V2MulticastListenerReport.Write(w); err != nil {
			return fmt.Errorf("encode V2MulticastListenerReport: %w", err)
		}
	default:
		if _, ok := t.union162_.(*union_177_t); !ok {
			return fmt.Errorf("encode t.union162_: union is not set to union_177_t")
		}
		if n, err := w.Write(t.union162_.(*union_177_t).Data); err != nil || n != len(t.union162_.(*union_177_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *Icmpv6Packet) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Icmpv6Packet) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Icmpv6Packet) Read(r io.Reader) (err error) {
	if err := t.Header.Read(r); err != nil {
		return fmt.Errorf("read Header: %w", err)
	}
	switch {
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoRequest):
		t.union162_ = &union_164_t{}
		if err := t.union162_.(*union_164_t).EchoRequest.Read(r); err != nil {
			return fmt.Errorf("read EchoRequest: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_EchoReply):
		t.union162_ = &union_165_t{}
		if err := t.union162_.(*union_165_t).EchoReply.Read(r); err != nil {
			return fmt.Errorf("read EchoReply: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_TimeExceeded):
		t.union162_ = &union_166_t{}
		if err := t.union162_.(*union_166_t).TimeExceeded.Read(r); err != nil {
			return fmt.Errorf("read TimeExceeded: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_PacketTooBig):
		t.union162_ = &union_167_t{}
		if err := t.union162_.(*union_167_t).PacketTooBig.Read(r); err != nil {
			return fmt.Errorf("read PacketTooBig: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_ParameterProblem):
		t.union162_ = &union_168_t{}
		if err := t.union162_.(*union_168_t).ParameterProblem.Read(r); err != nil {
			return fmt.Errorf("read ParameterProblem: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_DestinationUnreachable):
		t.union162_ = &union_169_t{}
		if err := t.union162_.(*union_169_t).DestinationUnreachable.Read(r); err != nil {
			return fmt.Errorf("read DestinationUnreachable: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterSolicitation):
		t.union162_ = &union_170_t{}
		if err := t.union162_.(*union_170_t).RouterSolicitation.Read(r); err != nil {
			return fmt.Errorf("read RouterSolicitation: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_RouterAdvertisement):
		t.union162_ = &union_171_t{}
		if err := t.union162_.(*union_171_t).RouterAdvertisement.Read(r); err != nil {
			return fmt.Errorf("read RouterAdvertisement: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborSolicitation):
		t.union162_ = &union_172_t{}
		if err := t.union162_.(*union_172_t).NeighborSolicitation.Read(r); err != nil {
			return fmt.Errorf("read NeighborSolicitation: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_NeighborAdvertisement):
		t.union162_ = &union_173_t{}
		if err := t.union162_.(*union_173_t).NeighborAdvertisement.Read(r); err != nil {
			return fmt.Errorf("read NeighborAdvertisement: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_RedirectMessage):
		t.union162_ = &union_174_t{}
		if err := t.union162_.(*union_174_t).RedirectMessage.Read(r); err != nil {
			return fmt.Errorf("read RedirectMessage: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_MulticastListenerQuery):
		t.union162_ = &union_175_t{}
		if err := t.union162_.(*union_175_t).MulticastListenerQuery.Read(r); err != nil {
			return fmt.Errorf("read MulticastListenerQuery: %w", err)
		}
	case (Icmpv6Type(t.Header.Type) == Icmpv6Type_V2MulticastListenerReport):
		t.union162_ = &union_176_t{}
		if err := t.union162_.(*union_176_t).V2MulticastListenerReport.Read(r); err != nil {
			return fmt.Errorf("read V2MulticastListenerReport: %w", err)
		}
	default:
		t.union162_ = &union_177_t{}
		bytes_buf_Data := &bytes.Buffer{}
		if _, err := io.Copy(bytes_buf_Data, r); err != nil {
			return err
		}
		t.union162_.(*union_177_t).Data = bytes_buf_Data.Bytes()
	}
	return nil
}

func (t *Icmpv6Packet) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Icmpv6Packet) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Icmpv6Packet: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
