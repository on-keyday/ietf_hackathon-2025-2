// Code generated by json2go. DO NOT EDIT.
package bgp

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"reflect"
)

type Bgptype uint8

const (
	Bgptype_Open         Bgptype = 1
	Bgptype_Update       Bgptype = 2
	Bgptype_Notification Bgptype = 3
	Bgptype_Keepalive    Bgptype = 4
)

func (t Bgptype) String() string {
	switch t {
	case Bgptype_Open:
		return "Open"
	case Bgptype_Update:
		return "Update"
	case Bgptype_Notification:
		return "Notification"
	case Bgptype_Keepalive:
		return "Keepalive"
	}
	return fmt.Sprintf("Bgptype(%d)", t)
}

type BgpoptionType uint8

const (
	BgpoptionType_Capability BgpoptionType = 2
)

func (t BgpoptionType) String() string {
	switch t {
	case BgpoptionType_Capability:
		return "Capability"
	}
	return fmt.Sprintf("BgpoptionType(%d)", t)
}

type AttributeCode uint8

const (
	AttributeCode_Origin                               AttributeCode = 1
	AttributeCode_AsPath                               AttributeCode = 2
	AttributeCode_NextHop                              AttributeCode = 3
	AttributeCode_MultiExitDisc                        AttributeCode = 4
	AttributeCode_LocalPref                            AttributeCode = 5
	AttributeCode_AtomicAggregate                      AttributeCode = 6
	AttributeCode_Aggregator                           AttributeCode = 7
	AttributeCode_Communities                          AttributeCode = 8
	AttributeCode_OriginatorId                         AttributeCode = 9
	AttributeCode_ClusterList                          AttributeCode = 10
	AttributeCode_DpaDeprecated                        AttributeCode = 11
	AttributeCode_AdvertiserDeprecated                 AttributeCode = 12
	AttributeCode_RcidPathDeprecated                   AttributeCode = 13
	AttributeCode_MpReachNlri                          AttributeCode = 14
	AttributeCode_MpUnreachNlri                        AttributeCode = 15
	AttributeCode_ExtendedCommunities                  AttributeCode = 16
	AttributeCode_As4Path                              AttributeCode = 17
	AttributeCode_As4Aggregator                        AttributeCode = 18
	AttributeCode_SsaDeprecated                        AttributeCode = 19
	AttributeCode_ConnectorAttributeDeprecated         AttributeCode = 20
	AttributeCode_AsPathlimitDeprecated                AttributeCode = 21
	AttributeCode_PmsiTunnel                           AttributeCode = 22
	AttributeCode_TunnelEncap                          AttributeCode = 23
	AttributeCode_TrafficEngineering                   AttributeCode = 24
	AttributeCode_Ipv6AddressSpecificExtendedCommunity AttributeCode = 25
	AttributeCode_Aigp                                 AttributeCode = 26
	AttributeCode_PeDistinguisherLabel                 AttributeCode = 27
	AttributeCode_BgpLs                                AttributeCode = 29
	AttributeCode_LargeCommunity                       AttributeCode = 32
	AttributeCode_BgpsecPath                           AttributeCode = 33
	AttributeCode_OnlyForOrf                           AttributeCode = 35
	AttributeCode_BgpDomainPath                        AttributeCode = 36
	AttributeCode_SfpAttribute                         AttributeCode = 37
	AttributeCode_BfdDiscriminator                     AttributeCode = 38
	AttributeCode_BgpPrefixSid                         AttributeCode = 40
	AttributeCode_Bier                                 AttributeCode = 41
	AttributeCode_AttrSet                              AttributeCode = 128
	AttributeCode_ReservedForDevelopment               AttributeCode = 255
)

func (t AttributeCode) String() string {
	switch t {
	case AttributeCode_Origin:
		return "Origin"
	case AttributeCode_AsPath:
		return "AsPath"
	case AttributeCode_NextHop:
		return "NextHop"
	case AttributeCode_MultiExitDisc:
		return "MultiExitDisc"
	case AttributeCode_LocalPref:
		return "LocalPref"
	case AttributeCode_AtomicAggregate:
		return "AtomicAggregate"
	case AttributeCode_Aggregator:
		return "Aggregator"
	case AttributeCode_Communities:
		return "Communities"
	case AttributeCode_OriginatorId:
		return "OriginatorId"
	case AttributeCode_ClusterList:
		return "ClusterList"
	case AttributeCode_DpaDeprecated:
		return "DpaDeprecated"
	case AttributeCode_AdvertiserDeprecated:
		return "AdvertiserDeprecated"
	case AttributeCode_RcidPathDeprecated:
		return "RcidPathDeprecated"
	case AttributeCode_MpReachNlri:
		return "MpReachNlri"
	case AttributeCode_MpUnreachNlri:
		return "MpUnreachNlri"
	case AttributeCode_ExtendedCommunities:
		return "ExtendedCommunities"
	case AttributeCode_As4Path:
		return "As4Path"
	case AttributeCode_As4Aggregator:
		return "As4Aggregator"
	case AttributeCode_SsaDeprecated:
		return "SsaDeprecated"
	case AttributeCode_ConnectorAttributeDeprecated:
		return "ConnectorAttributeDeprecated"
	case AttributeCode_AsPathlimitDeprecated:
		return "AsPathlimitDeprecated"
	case AttributeCode_PmsiTunnel:
		return "PmsiTunnel"
	case AttributeCode_TunnelEncap:
		return "TunnelEncap"
	case AttributeCode_TrafficEngineering:
		return "TrafficEngineering"
	case AttributeCode_Ipv6AddressSpecificExtendedCommunity:
		return "Ipv6AddressSpecificExtendedCommunity"
	case AttributeCode_Aigp:
		return "Aigp"
	case AttributeCode_PeDistinguisherLabel:
		return "PeDistinguisherLabel"
	case AttributeCode_BgpLs:
		return "BgpLs"
	case AttributeCode_LargeCommunity:
		return "LargeCommunity"
	case AttributeCode_BgpsecPath:
		return "BgpsecPath"
	case AttributeCode_OnlyForOrf:
		return "OnlyForOrf"
	case AttributeCode_BgpDomainPath:
		return "BgpDomainPath"
	case AttributeCode_SfpAttribute:
		return "SfpAttribute"
	case AttributeCode_BfdDiscriminator:
		return "BfdDiscriminator"
	case AttributeCode_BgpPrefixSid:
		return "BgpPrefixSid"
	case AttributeCode_Bier:
		return "Bier"
	case AttributeCode_AttrSet:
		return "AttrSet"
	case AttributeCode_ReservedForDevelopment:
		return "ReservedForDevelopment"
	}
	return fmt.Sprintf("AttributeCode(%d)", t)
}

type AsPathSegmentType uint8

const (
	AsPathSegmentType_AsSet            AsPathSegmentType = 1
	AsPathSegmentType_AsSequence       AsPathSegmentType = 2
	AsPathSegmentType_AsConfedSequence AsPathSegmentType = 3
	AsPathSegmentType_AsConfedSet      AsPathSegmentType = 4
)

func (t AsPathSegmentType) String() string {
	switch t {
	case AsPathSegmentType_AsSet:
		return "AsSet"
	case AsPathSegmentType_AsSequence:
		return "AsSequence"
	case AsPathSegmentType_AsConfedSequence:
		return "AsConfedSequence"
	case AsPathSegmentType_AsConfedSet:
		return "AsConfedSet"
	}
	return fmt.Sprintf("AsPathSegmentType(%d)", t)
}

type Origin uint8

const (
	Origin_Igp        Origin = 0
	Origin_Egp        Origin = 1
	Origin_Incomplete Origin = 2
)

func (t Origin) String() string {
	switch t {
	case Origin_Igp:
		return "Igp"
	case Origin_Egp:
		return "Egp"
	case Origin_Incomplete:
		return "Incomplete"
	}
	return fmt.Sprintf("Origin(%d)", t)
}

type Nlritype uint16

const (
	Nlritype_NodeNlri           Nlritype = 1
	Nlritype_LinkNlri           Nlritype = 2
	Nlritype_Ipv4TopologyPrefix Nlritype = 3
	Nlritype_Ipv6TopologyPrefix Nlritype = 4
)

func (t Nlritype) String() string {
	switch t {
	case Nlritype_NodeNlri:
		return "NodeNlri"
	case Nlritype_LinkNlri:
		return "LinkNlri"
	case Nlritype_Ipv4TopologyPrefix:
		return "Ipv4TopologyPrefix"
	case Nlritype_Ipv6TopologyPrefix:
		return "Ipv6TopologyPrefix"
	}
	return fmt.Sprintf("Nlritype(%d)", t)
}

type SubTlvtype uint16

const (
	SubTlvtype_MultiTopologyId           SubTlvtype = 263
	SubTlvtype_OspfrouteType             SubTlvtype = 264
	SubTlvtype_IpreachabilityInformation SubTlvtype = 265
	SubTlvtype_AutonomousSystem          SubTlvtype = 512
	SubTlvtype_Bgplsid                   SubTlvtype = 513
	SubTlvtype_OspfareaId                SubTlvtype = 514
	SubTlvtype_IgprouterId               SubTlvtype = 515
)

func (t SubTlvtype) String() string {
	switch t {
	case SubTlvtype_MultiTopologyId:
		return "MultiTopologyId"
	case SubTlvtype_OspfrouteType:
		return "OspfrouteType"
	case SubTlvtype_IpreachabilityInformation:
		return "IpreachabilityInformation"
	case SubTlvtype_AutonomousSystem:
		return "AutonomousSystem"
	case SubTlvtype_Bgplsid:
		return "Bgplsid"
	case SubTlvtype_OspfareaId:
		return "OspfareaId"
	case SubTlvtype_IgprouterId:
		return "IgprouterId"
	}
	return fmt.Sprintf("SubTlvtype(%d)", t)
}

type OspfrouteType uint8

const (
	OspfrouteType_IntraAreaPrefix OspfrouteType = 1
	OspfrouteType_InterAreaPrefix OspfrouteType = 2
	OspfrouteType_External1       OspfrouteType = 3
	OspfrouteType_External2       OspfrouteType = 4
	OspfrouteType_Nssa1           OspfrouteType = 5
	OspfrouteType_Nssa2           OspfrouteType = 6
)

func (t OspfrouteType) String() string {
	switch t {
	case OspfrouteType_IntraAreaPrefix:
		return "IntraAreaPrefix"
	case OspfrouteType_InterAreaPrefix:
		return "InterAreaPrefix"
	case OspfrouteType_External1:
		return "External1"
	case OspfrouteType_External2:
		return "External2"
	case OspfrouteType_Nssa1:
		return "Nssa1"
	case OspfrouteType_Nssa2:
		return "Nssa2"
	}
	return fmt.Sprintf("OspfrouteType(%d)", t)
}

type Bgpheader struct {
	// "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" (16 byte)
	Length uint16
	Type   Bgptype
}
type VisitorPRAYV interface {
	Visit(v VisitorPRAYV, name string, field any)
}
type VisitorPRAYVFunc func(v VisitorPRAYV, name string, field any)

func (f VisitorPRAYVFunc) Visit(v VisitorPRAYV, name string, field any) {
	f(v, name, field)
}

type VisitorPRAYVVisitable interface {
	Visit(v VisitorPRAYV)
}

func VisitorPRAYVToMap(v any) interface{} {
	if v == nil {
		return nil
	}
	if inter, ok := v.(VisitorPRAYVVisitable); ok {
		if p := reflect.ValueOf(inter); p.Kind() == reflect.Pointer && p.IsNil() {
			return nil
		}
		m := map[string]interface{}{}
		inter.Visit(VisitorPRAYVFunc(func(v VisitorPRAYV, name string, field any) {
			m[name] = VisitorPRAYVToMap(field)
		}))
		return m
	}
	if tf := reflect.TypeOf(v); (tf.Kind() == reflect.Slice || tf.Kind() == reflect.Array) && !(func() bool { k := tf.Elem().Kind().String(); return k[:3] == "int" || k[:3] == "uin" || k[:3] == "flo" })() {
		m := []interface{}{}
		vf := reflect.ValueOf(v)
		for i := 0; i < vf.Len(); i++ {
			index := vf.Index(i)
			if index.Kind() == reflect.Struct && index.CanAddr() {
				index = index.Addr()
			}
			m = append(m, VisitorPRAYVToMap(index.Interface()))
		}
		return m
	}
	if tf := reflect.TypeOf(v); tf.Kind() == reflect.Pointer {
		val := reflect.ValueOf(v)
		if val.IsNil() {
			return nil
		}
		return VisitorPRAYVToMap(val.Elem().Interface())
	}
	return v
}

type Bgpoption struct {
	Type BgpoptionType
	Len  uint8
	Data []uint8
}
type WithdrawnRoute struct {
	Bits   uint16
	Prefix []uint8
}
type AttributeType struct {
	flags6 uint8
	Code   AttributeCode
}
type Aggregator struct {
	As   uint16
	Addr []uint8
}
type AsPathSegment struct {
	Type AsPathSegmentType
	Len  uint8
	Data []uint16
}
type NetWorkReachabilityInfo struct {
	Prefixlen uint8
	Prefix    []uint8
}
type Notification struct {
	Code    uint8
	Subcode uint8
	Data    []uint8
}
type Lstlv struct {
	Type   uint16
	Length uint16
	Value  []uint8
}
type LinkDescriptorSubTlv struct {
	Type   uint16
	Length uint16
	Data   []uint8
}
type union16_NodeDescriptorSubTlv interface {
	isunion15_()
}
type union_17_t struct {
	AutonomousSystem [4]uint8
}
type union_18_t struct {
	BgpLsIdentifier [4]uint8
}
type union_19_t struct {
	OspfAreaId [4]uint8
}
type union_20_t struct {
	IgpRouterId []uint8
}
type union_21_t struct {
	Data []uint8
}
type NodeDescriptorSubTlv struct {
	Type     SubTlvtype
	Length   uint16
	union15_ union16_NodeDescriptorSubTlv
}
type MultiTopologyId struct {
	flags30 uint16
}
type IpreachabilityInformation struct {
	PrefixLength uint8
	Prefix       []uint8
}
type NodeFlagBits struct {
	flags32 uint8
}
type IsisareaIdentifier struct {
	AreaId []uint8
}
type NodeName struct {
	Name []uint8
}
type MplsprotocolMask struct {
	flags33 uint8
}
type LinkName struct {
	Name []uint8
}
type Igpflags struct {
	flags34 uint8
}
type RouteTags struct {
	Tags []uint32
}
type PrefixMetric struct {
	Metric uint32
}
type OspfforwardingAddress struct {
	ForwardingAddress []uint8
}
type OpaquePrefixAttribute struct {
	PrefixAttributes []uint8
}
type ExtendedCommunity struct {
	Type    uint8
	Subtype uint8
	Data    [6]uint8
}
type CandidatePathDescriptorSubTlv struct {
	Type   uint16
	Length uint16
	Data   []uint8
}
type SrpolicyCandidatePathDescriptor struct {
	ProtocolOrigin     uint8
	flags41            uint8
	Reserved2          uint16
	Endpoint           []uint8
	PolicyColor        uint32
	OriginatorAsNumber uint32
	OriginatorAddress  []uint8
	Discriminator      uint32
}
type SrbindingSid struct {
	flags46             uint16
	Reserved2           uint16
	BindingSid          []uint8
	SpecifiedBindingSid []uint8
}
type Srv6BindingSidsubTlv struct {
	Type   uint16
	Length uint16
	Data   []uint8
}
type SrcandidatePathState struct {
	Priority   uint8
	Reserved   uint8
	flags51    uint8
	flags52    uint8
	Preference uint32
}
type SrpolicyName struct {
	Name []uint8
}
type SrcandidatePathName struct {
	Name []uint8
}
type SrcandidateConstraintsSubTlv struct {
	Type   uint16
	Length uint16
	Data   []uint8
}
type SraffinityConstraint struct {
	ExclAnySize uint8
	IncAnySize  uint8
	InclAllSize uint8
	Reserved    uint8
	ExclAny     []uint32
	IncAny      []uint32
	InclAll     []uint32
}
type Srsrlgconstraint struct {
	Srlg []uint32
}
type SrbandwidthConstraint struct {
	Bandwidth uint32
}
type SrdisjointGroup struct {
	flags69             uint8
	flags70             uint8
	Reserved3           uint16
	DisjointnessGroupId []uint8
}
type SrbidirectionalGroupConstraint struct {
	flags72     uint16
	Reserved2   uint16
	BidiGroupId []uint8
}
type SrmetricConstraint struct {
	MetricType   uint8
	flags75      uint8
	MetricMargin uint32
	MetricBound  uint32
}
type Open struct {
	Version uint8
	As      uint16
	Hold    uint16
	Id      uint32
	Optlen  uint8
	Options []Bgpoption
}
type WithdrawnRoutes struct {
	Len  uint16
	Data []WithdrawnRoute
}
type AsPath struct {
	Segments []AsPathSegment
}
type NodeDescriptors struct {
	Type       uint16
	Length     uint16
	Descriptor []NodeDescriptorSubTlv
}
type NodeNlri struct {
	ProtocolId           uint8
	Identifier           uint64
	LocalNodeDescriptors NodeDescriptors
}
type LinkDescriptors struct {
	Type       uint16
	Length     uint16
	Descriptor []LinkDescriptorSubTlv
}
type LinkNlri struct {
	LinkLocalId           uint32
	LocalNodeDescriptors  NodeDescriptors
	RemoteNodeDescriptors NodeDescriptors
	LinkDescriptors       LinkDescriptors
}
type MultiTopologyIdlist struct {
	MtIds []MultiTopologyId
}
type union105_PrefixDescriptorSubTlv interface {
	isunion104_()
}
type union_106_t struct {
	MultiTopologyIdentifier MultiTopologyIdlist
}
type union_107_t struct {
	OspfRouteType OspfrouteType
}
type union_108_t struct {
	IpReachabilityInformation IpreachabilityInformation
}
type union_109_t struct {
	Data []uint8
}
type PrefixDescriptorSubTlv struct {
	Type      SubTlvtype
	Length    uint16
	union104_ union105_PrefixDescriptorSubTlv
}
type PrefixDescriptors struct {
	Type       uint16
	Length     uint16
	Descriptor []PrefixDescriptorSubTlv
}
type PrefixNlri struct {
	ProtocolId           uint8
	Identifier           uint64
	LocalNodeDescriptors NodeDescriptors
	PrefixDescriptors    PrefixDescriptors
}
type union125_LinkStateNlri interface {
	isunion124_()
}
type union_126_t struct {
	NodeNlri NodeNlri
}
type union_127_t struct {
	LinkNlri LinkNlri
}
type union_128_t struct {
	PrefixNlri PrefixNlri
}
type union_129_t struct {
	PrefixNlri PrefixNlri
}
type union_130_t struct {
	Data []uint8
}
type LinkStateNlri struct {
	NlriType   Nlritype
	NlriLength uint16
	union124_  union125_LinkStateNlri
}
type union142_PathAttribute interface {
	isunion141_()
}
type union_143_t struct {
	Len uint16
}
type union_144_t struct {
	Len uint8
}
type union146_PathAttribute interface {
	isunion145_()
}
type union_147_t struct {
	Origin Origin
}
type union_148_t struct {
	AsPath AsPath
}
type union_149_t struct {
	NextHop [4]uint8
}
type union_150_t struct {
	MultiExitDisc uint32
}
type union_151_t struct {
	LocalPref uint32
}
type union_152_t struct{}
type union_153_t struct {
	Aggregator Aggregator
}
type union_154_t struct {
	Communities []uint32
}
type union_155_t struct {
	ExtendedCommunities []ExtendedCommunity
}
type union_156_t struct {
	BgpLs LinkStateNlri
}
type union_157_t struct {
	Data []uint8
}
type PathAttribute struct {
	Type      AttributeType
	union141_ union142_PathAttribute
	union145_ union146_PathAttribute
}
type PathAttributes struct {
	Len  uint16
	Data []PathAttribute
}
type OpaqueNode struct {
	NodeAttributes []Lstlv
}
type OpaqueLink struct {
	LinkAttributes []Lstlv
}
type CandidatePathDescriptors struct {
	Descriptor []CandidatePathDescriptorSubTlv
}
type Srv6BindingSid struct {
	flags192            uint16
	Reserved2           uint16
	BindingSid          [16]uint8
	SpecifiedBindingSid [16]uint8
	SubTlvs             []Srv6BindingSidsubTlv
}
type SrcandidateConstraints struct {
	flags197  uint8
	Reserved1 uint8
	Reserved2 uint16
	Mtid      uint16
	Algorithm uint8
	Reserved3 uint8
	SubTlvs   []SrcandidateConstraintsSubTlv
}
type SrpolicyCandidatePathNlri struct {
	ProtocolId               uint8
	Identifier               uint64
	LocalNodeDescriptors     NodeDescriptors
	CandidatePathDescriptors CandidatePathDescriptors
}
type union204_Update interface {
	isunion203_()
}
type union_205_t struct {
	NetworkReachabilityInfo []NetWorkReachabilityInfo
}
type Update struct {
	WithdrawnRoutes WithdrawnRoutes
	PathAttr        PathAttributes
	union203_       union204_Update
}
type union209_Bgppacket interface {
	isunion208_()
}
type union_210_t struct {
	Open Open
}
type union_211_t struct {
	Update Update
}
type union_212_t struct {
	Notification Notification
}
type union_213_t struct{}
type Bgppacket struct {
	Header    Bgpheader
	union208_ union209_Bgppacket
}

func (t *Bgpheader) Visit(v VisitorPRAYV) {
	v.Visit(v, "Marker", "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF")
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Type", &t.Type)
}
func (t *Bgpheader) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *Bgpheader) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF")); err != nil || n != len("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF") {
		return fmt.Errorf("encode Marker: %w", err)
	}
	tmp1 := [2]byte{}
	binary.BigEndian.PutUint16(tmp1[:], uint16(t.Length))
	if n, err := w.Write(tmp1[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	return nil
}
func (t *Bgpheader) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 19))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Bgpheader) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Bgpheader) Read(r io.Reader) (err error) {
	tmp2_ := [16]byte{}
	n_tmp2_, err := io.ReadFull(r, tmp2_[:])
	if err != nil {
		return fmt.Errorf("read Marker: expect 16 bytes but read %d bytes: %w", n_tmp2_, err)
	}
	if string(tmp2_[:]) != "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" {
		return fmt.Errorf("read Marker: expect %s but got %s", "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", tmp2_[:])
	}
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = Bgptype(tmpType[0])
	return nil
}

func (t *Bgpheader) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Bgpheader) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Bgpheader: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Bgpoption) SetData(v []uint8) bool {
	if len(v) > int(^uint8(0)) {
		return false
	}
	t.Len = uint8(len(v))
	t.Data = v
	return true
}
func (t *Bgpoption) Visit(v VisitorPRAYV) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Len", &t.Len)
	v.Visit(v, "Data", &t.Data)
}
func (t *Bgpoption) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *Bgpoption) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Len)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Len: %w", err)
	}
	len_Data := int(t.Len)
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.Data))
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Bgpoption) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Bgpoption) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Bgpoption) Read(r io.Reader) (err error) {
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = BgpoptionType(tmpType[0])
	tmpLen := [1]byte{}
	n_Len, err := io.ReadFull(r, tmpLen[:])
	if err != nil {
		return fmt.Errorf("read Len: expect 1 byte but read %d bytes: %w", n_Len, err)
	}
	t.Len = uint8(tmpLen[0])
	len_Data := int(t.Len)
	if len_Data != 0 {
		tmpData := make([]byte, len_Data)
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
		}
		t.Data = tmpData[:]
	} else {
		t.Data = nil
	}
	return nil
}

func (t *Bgpoption) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Bgpoption) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Bgpoption: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *WithdrawnRoute) Visit(v VisitorPRAYV) {
	v.Visit(v, "Bits", &t.Bits)
	v.Visit(v, "Prefix", &t.Prefix)
}
func (t *WithdrawnRoute) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *WithdrawnRoute) Write(w io.Writer) (err error) {
	tmp3 := [2]byte{}
	binary.BigEndian.PutUint16(tmp3[:], uint16(t.Bits))
	if n, err := w.Write(tmp3[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Bits: %w", err)
	}
	InByte := ((t.Bits + 7) / 8)
	new_buf_4 := bytes.NewBuffer(nil)
	old_buf_4_w := w
	w = new_buf_4
	if n, err := w.Write(t.Prefix); err != nil || n != len(t.Prefix) {
		return fmt.Errorf("encode Prefix: %w", err)
	}
	if new_buf_4.Len() != int(InByte) {
		return fmt.Errorf("encode Prefix: expect %d bytes but got %d bytes", new_buf_4.Len(), int(InByte))
	}
	_, err = new_buf_4.WriteTo(old_buf_4_w)
	if err != nil {
		return err
	}
	w = old_buf_4_w
	return nil
}
func (t *WithdrawnRoute) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *WithdrawnRoute) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *WithdrawnRoute) Read(r io.Reader) (err error) {
	tmpBits := [2]byte{}
	n_Bits, err := io.ReadFull(r, tmpBits[:])
	if err != nil {
		return fmt.Errorf("read Bits: expect 2 bytes but read %d bytes: %w", n_Bits, err)
	}
	t.Bits = uint16(binary.BigEndian.Uint16(tmpBits[:]))
	InByte := ((t.Bits + 7) / 8)
	sub_byte_len_Prefix := int64(InByte)
	sub_byte_r_Prefix := io.LimitReader(r, int64(sub_byte_len_Prefix))
	tmp_old_r_Prefix_5 := r
	r = sub_byte_r_Prefix
	bytes_buf_Prefix := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Prefix, r); err != nil {
		return err
	}
	t.Prefix = bytes_buf_Prefix.Bytes()
	if sub_byte_r_Prefix.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Prefix: expect %d bytes but got %d bytes", sub_byte_len_Prefix, sub_byte_len_Prefix-sub_byte_r_Prefix.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Prefix_5
	return nil
}

func (t *WithdrawnRoute) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *WithdrawnRoute) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode WithdrawnRoute: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *AttributeType) Option() bool {
	return ((t.flags6 & 0x80) >> 7) == 1
}
func (t *AttributeType) SetOption(v bool) {
	if v {
		t.flags6 |= uint8(0x80)
	} else {
		t.flags6 &= ^uint8(0x80)
	}
}
func (t *AttributeType) Transitive() bool {
	return ((t.flags6 & 0x40) >> 6) == 1
}
func (t *AttributeType) SetTransitive(v bool) {
	if v {
		t.flags6 |= uint8(0x40)
	} else {
		t.flags6 &= ^uint8(0x40)
	}
}
func (t *AttributeType) Partial() bool {
	return ((t.flags6 & 0x20) >> 5) == 1
}
func (t *AttributeType) SetPartial(v bool) {
	if v {
		t.flags6 |= uint8(0x20)
	} else {
		t.flags6 &= ^uint8(0x20)
	}
}
func (t *AttributeType) Extended() bool {
	return ((t.flags6 & 0x10) >> 4) == 1
}
func (t *AttributeType) SetExtended(v bool) {
	if v {
		t.flags6 |= uint8(0x10)
	} else {
		t.flags6 &= ^uint8(0x10)
	}
}
func (t *AttributeType) Reserved() uint8 {
	return ((t.flags6 & 0x0f) >> 0)
}
func (t *AttributeType) SetReserved(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags6 = (t.flags6 & ^uint8(0xf)) | ((v & 0xf) << 0)
	return true
}
func (t *AttributeType) Visit(v VisitorPRAYV) {
	v.Visit(v, "Option", (func() uint8 {
		if t.Option() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Transitive", (func() uint8 {
		if t.Transitive() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Partial", (func() uint8 {
		if t.Partial() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Extended", (func() uint8 {
		if t.Extended() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved", t.Reserved())
	v.Visit(v, "Code", &t.Code)
}
func (t *AttributeType) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *AttributeType) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags6)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags6: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Code)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Code: %w", err)
	}
	return nil
}
func (t *AttributeType) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *AttributeType) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *AttributeType) Read(r io.Reader) (err error) {
	tmpflags6 := [1]byte{}
	n_flags6, err := io.ReadFull(r, tmpflags6[:])
	if err != nil {
		return fmt.Errorf("read flags6: expect 1 byte but read %d bytes: %w", n_flags6, err)
	}
	t.flags6 = uint8(tmpflags6[0])
	tmpCode := [1]byte{}
	n_Code, err := io.ReadFull(r, tmpCode[:])
	if err != nil {
		return fmt.Errorf("read Code: expect 1 byte but read %d bytes: %w", n_Code, err)
	}
	t.Code = AttributeCode(tmpCode[0])
	return nil
}

func (t *AttributeType) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *AttributeType) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode AttributeType: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Aggregator) Visit(v VisitorPRAYV) {
	v.Visit(v, "As", &t.As)
	v.Visit(v, "Addr", &t.Addr)
}
func (t *Aggregator) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *Aggregator) Write(w io.Writer) (err error) {
	tmp7 := [2]byte{}
	binary.BigEndian.PutUint16(tmp7[:], uint16(t.As))
	if n, err := w.Write(tmp7[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.As: %w", err)
	}
	if n, err := w.Write(t.Addr); err != nil || n != len(t.Addr) {
		return fmt.Errorf("encode Addr: %w", err)
	}
	return nil
}
func (t *Aggregator) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Aggregator) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Aggregator) Read(r io.Reader) (err error) {
	tmpAs := [2]byte{}
	n_As, err := io.ReadFull(r, tmpAs[:])
	if err != nil {
		return fmt.Errorf("read As: expect 2 bytes but read %d bytes: %w", n_As, err)
	}
	t.As = uint16(binary.BigEndian.Uint16(tmpAs[:]))
	bytes_buf_Addr := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Addr, r); err != nil {
		return err
	}
	t.Addr = bytes_buf_Addr.Bytes()
	return nil
}

func (t *Aggregator) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Aggregator) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Aggregator: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *AsPathSegment) SetData(v []uint16) bool {
	if len(v) > int(^uint8(0)) {
		return false
	}
	t.Len = uint8(len(v))
	t.Data = v
	return true
}
func (t *AsPathSegment) Visit(v VisitorPRAYV) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Len", &t.Len)
	v.Visit(v, "Data", &t.Data)
}
func (t *AsPathSegment) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *AsPathSegment) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Len)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Len: %w", err)
	}
	len_Data := int(t.Len)
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d but got %d for length", len_Data, len(t.Data))
	}
	for _, v := range t.Data {
		tmp8 := [2]byte{}
		binary.BigEndian.PutUint16(tmp8[:], uint16(v))
		if n, err := w.Write(tmp8[:]); err != nil || n != 2 {
			return fmt.Errorf("encode v: %w", err)
		}
	}
	return nil
}
func (t *AsPathSegment) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *AsPathSegment) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *AsPathSegment) Read(r io.Reader) (err error) {
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = AsPathSegmentType(tmpType[0])
	tmpLen := [1]byte{}
	n_Len, err := io.ReadFull(r, tmpLen[:])
	if err != nil {
		return fmt.Errorf("read Len: expect 1 byte but read %d bytes: %w", n_Len, err)
	}
	t.Len = uint8(tmpLen[0])
	len_Data := int(t.Len)
	for i_9 := 0; i_9 < len_Data; i_9++ {
		var tmp10_ uint16
		tmpData := [2]byte{}
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect 2 bytes but read %d bytes: %w", n_Data, err)
		}
		tmp10_ = uint16(binary.BigEndian.Uint16(tmpData[:]))
		t.Data = append(t.Data, tmp10_)
	}
	return nil
}

func (t *AsPathSegment) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *AsPathSegment) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode AsPathSegment: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NetWorkReachabilityInfo) SetPrefix(v []uint8) bool {
	if len(v) > int(^uint8(0)) {
		return false
	}
	t.Prefixlen = uint8(len(v))
	t.Prefix = v
	return true
}
func (t *NetWorkReachabilityInfo) Visit(v VisitorPRAYV) {
	v.Visit(v, "Prefixlen", &t.Prefixlen)
	v.Visit(v, "Prefix", &t.Prefix)
}
func (t *NetWorkReachabilityInfo) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *NetWorkReachabilityInfo) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Prefixlen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Prefixlen: %w", err)
	}
	len_Prefix := int(t.Prefixlen)
	if len(t.Prefix) != len_Prefix {
		return fmt.Errorf("encode Prefix: expect %d bytes but got %d bytes", len_Prefix, len(t.Prefix))
	}
	if n, err := w.Write(t.Prefix); err != nil || n != len(t.Prefix) {
		return fmt.Errorf("encode Prefix: %w", err)
	}
	return nil
}
func (t *NetWorkReachabilityInfo) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NetWorkReachabilityInfo) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NetWorkReachabilityInfo) Read(r io.Reader) (err error) {
	tmpPrefixlen := [1]byte{}
	n_Prefixlen, err := io.ReadFull(r, tmpPrefixlen[:])
	if err != nil {
		return fmt.Errorf("read Prefixlen: expect 1 byte but read %d bytes: %w", n_Prefixlen, err)
	}
	t.Prefixlen = uint8(tmpPrefixlen[0])
	len_Prefix := int(t.Prefixlen)
	if len_Prefix != 0 {
		tmpPrefix := make([]byte, len_Prefix)
		n_Prefix, err := io.ReadFull(r, tmpPrefix[:])
		if err != nil {
			return fmt.Errorf("read Prefix: expect %d bytes but read %d bytes: %w", len_Prefix, n_Prefix, err)
		}
		t.Prefix = tmpPrefix[:]
	} else {
		t.Prefix = nil
	}
	return nil
}

func (t *NetWorkReachabilityInfo) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NetWorkReachabilityInfo) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NetWorkReachabilityInfo: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Notification) Visit(v VisitorPRAYV) {
	v.Visit(v, "Code", &t.Code)
	v.Visit(v, "Subcode", &t.Subcode)
	v.Visit(v, "Data", &t.Data)
}
func (t *Notification) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *Notification) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Code)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Code: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Subcode)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Subcode: %w", err)
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Notification) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Notification) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Notification) Read(r io.Reader) (err error) {
	tmpCode := [1]byte{}
	n_Code, err := io.ReadFull(r, tmpCode[:])
	if err != nil {
		return fmt.Errorf("read Code: expect 1 byte but read %d bytes: %w", n_Code, err)
	}
	t.Code = uint8(tmpCode[0])
	tmpSubcode := [1]byte{}
	n_Subcode, err := io.ReadFull(r, tmpSubcode[:])
	if err != nil {
		return fmt.Errorf("read Subcode: expect 1 byte but read %d bytes: %w", n_Subcode, err)
	}
	t.Subcode = uint8(tmpSubcode[0])
	bytes_buf_Data := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Data, r); err != nil {
		return err
	}
	t.Data = bytes_buf_Data.Bytes()
	return nil
}

func (t *Notification) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Notification) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Notification: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Lstlv) SetValue(v []uint8) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.Length = uint16(len(v))
	t.Value = v
	return true
}
func (t *Lstlv) Visit(v VisitorPRAYV) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Value", &t.Value)
}
func (t *Lstlv) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *Lstlv) Write(w io.Writer) (err error) {
	tmp11 := [2]byte{}
	binary.BigEndian.PutUint16(tmp11[:], uint16(t.Type))
	if n, err := w.Write(tmp11[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	tmp12 := [2]byte{}
	binary.BigEndian.PutUint16(tmp12[:], uint16(t.Length))
	if n, err := w.Write(tmp12[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	len_Value := int(t.Length)
	if len(t.Value) != len_Value {
		return fmt.Errorf("encode Value: expect %d bytes but got %d bytes", len_Value, len(t.Value))
	}
	if n, err := w.Write(t.Value); err != nil || n != len(t.Value) {
		return fmt.Errorf("encode Value: %w", err)
	}
	return nil
}
func (t *Lstlv) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Lstlv) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Lstlv) Read(r io.Reader) (err error) {
	tmpType := [2]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 2 bytes but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint16(binary.BigEndian.Uint16(tmpType[:]))
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	len_Value := int(t.Length)
	if len_Value != 0 {
		tmpValue := make([]byte, len_Value)
		n_Value, err := io.ReadFull(r, tmpValue[:])
		if err != nil {
			return fmt.Errorf("read Value: expect %d bytes but read %d bytes: %w", len_Value, n_Value, err)
		}
		t.Value = tmpValue[:]
	} else {
		t.Value = nil
	}
	return nil
}

func (t *Lstlv) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Lstlv) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Lstlv: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *LinkDescriptorSubTlv) SetData(v []uint8) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.Length = uint16(len(v))
	t.Data = v
	return true
}
func (t *LinkDescriptorSubTlv) Visit(v VisitorPRAYV) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Data", &t.Data)
}
func (t *LinkDescriptorSubTlv) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *LinkDescriptorSubTlv) Write(w io.Writer) (err error) {
	tmp13 := [2]byte{}
	binary.BigEndian.PutUint16(tmp13[:], uint16(t.Type))
	if n, err := w.Write(tmp13[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	tmp14 := [2]byte{}
	binary.BigEndian.PutUint16(tmp14[:], uint16(t.Length))
	if n, err := w.Write(tmp14[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	len_Data := int(t.Length)
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.Data))
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *LinkDescriptorSubTlv) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *LinkDescriptorSubTlv) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *LinkDescriptorSubTlv) Read(r io.Reader) (err error) {
	tmpType := [2]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 2 bytes but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint16(binary.BigEndian.Uint16(tmpType[:]))
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	len_Data := int(t.Length)
	if len_Data != 0 {
		tmpData := make([]byte, len_Data)
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
		}
		t.Data = tmpData[:]
	} else {
		t.Data = nil
	}
	return nil
}

func (t *LinkDescriptorSubTlv) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *LinkDescriptorSubTlv) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode LinkDescriptorSubTlv: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_17_t) isunion15_() {}
func (t *union_18_t) isunion15_() {}
func (t *union_19_t) isunion15_() {}
func (t *union_20_t) isunion15_() {}
func (t *union_21_t) isunion15_() {}
func (t *NodeDescriptorSubTlv) AutonomousSystem() *[4]uint8 {
	if t.Type == SubTlvtype_AutonomousSystem {
		if _, ok := t.union15_.(*union_17_t); !ok {
			return nil // not set
		}
		tmp := [4]uint8(t.union15_.(*union_17_t).AutonomousSystem[:])
		return &tmp
	}
	return nil
}
func (t *NodeDescriptorSubTlv) SetAutonomousSystem(v [4]uint8) bool {
	if t.Type == SubTlvtype_AutonomousSystem {
		if _, ok := t.union15_.(*union_17_t); !ok {
			t.union15_ = &union_17_t{}
		}
		t.union15_.(*union_17_t).AutonomousSystem = [4]uint8(v)
		return true
	}
	return false
}
func (t *NodeDescriptorSubTlv) BgpLsIdentifier() *[4]uint8 {
	if t.Type == SubTlvtype_AutonomousSystem {
		return nil
	} else if t.Type == SubTlvtype_OspfareaId {
		if _, ok := t.union15_.(*union_18_t); !ok {
			return nil // not set
		}
		tmp := [4]uint8(t.union15_.(*union_18_t).BgpLsIdentifier[:])
		return &tmp
	}
	return nil
}
func (t *NodeDescriptorSubTlv) SetBgpLsIdentifier(v [4]uint8) bool {
	if t.Type == SubTlvtype_AutonomousSystem {
		return false
	} else if t.Type == SubTlvtype_OspfareaId {
		if _, ok := t.union15_.(*union_18_t); !ok {
			t.union15_ = &union_18_t{}
		}
		t.union15_.(*union_18_t).BgpLsIdentifier = [4]uint8(v)
		return true
	}
	return false
}
func (t *NodeDescriptorSubTlv) Data() *[]uint8 {
	if t.Type == SubTlvtype_AutonomousSystem {
		return nil
	} else if t.Type == SubTlvtype_OspfareaId {
		return nil
	} else if t.Type == SubTlvtype_Bgplsid {
		return nil
	} else if t.Type == SubTlvtype_IgprouterId {
		return nil
	} else if true {
		if _, ok := t.union15_.(*union_21_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union15_.(*union_21_t).Data)
		return &tmp
	}
	return nil
}
func (t *NodeDescriptorSubTlv) SetData(v []uint8) bool {
	if t.Type == SubTlvtype_AutonomousSystem {
		return false
	} else if t.Type == SubTlvtype_OspfareaId {
		return false
	} else if t.Type == SubTlvtype_Bgplsid {
		return false
	} else if t.Type == SubTlvtype_IgprouterId {
		return false
	} else if true {
		if len(v) > int(^uint16(0)) {
			return false
		}
		if _, ok := t.union15_.(*union_21_t); !ok {
			t.union15_ = &union_21_t{}
		}
		t.Length = uint16(len(v))
		t.union15_.(*union_21_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *NodeDescriptorSubTlv) IgpRouterId() *[]uint8 {
	if t.Type == SubTlvtype_AutonomousSystem {
		return nil
	} else if t.Type == SubTlvtype_OspfareaId {
		return nil
	} else if t.Type == SubTlvtype_Bgplsid {
		return nil
	} else if t.Type == SubTlvtype_IgprouterId {
		if _, ok := t.union15_.(*union_20_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union15_.(*union_20_t).IgpRouterId)
		return &tmp
	}
	return nil
}
func (t *NodeDescriptorSubTlv) SetIgpRouterId(v []uint8) bool {
	if t.Type == SubTlvtype_AutonomousSystem {
		return false
	} else if t.Type == SubTlvtype_OspfareaId {
		return false
	} else if t.Type == SubTlvtype_Bgplsid {
		return false
	} else if t.Type == SubTlvtype_IgprouterId {
		if len(v) > int(^uint16(0)) {
			return false
		}
		if _, ok := t.union15_.(*union_20_t); !ok {
			t.union15_ = &union_20_t{}
		}
		t.Length = uint16(len(v))
		t.union15_.(*union_20_t).IgpRouterId = []uint8(v)
		return true
	}
	return false
}
func (t *NodeDescriptorSubTlv) OspfAreaId() *[4]uint8 {
	if t.Type == SubTlvtype_AutonomousSystem {
		return nil
	} else if t.Type == SubTlvtype_OspfareaId {
		return nil
	} else if t.Type == SubTlvtype_Bgplsid {
		if _, ok := t.union15_.(*union_19_t); !ok {
			return nil // not set
		}
		tmp := [4]uint8(t.union15_.(*union_19_t).OspfAreaId[:])
		return &tmp
	}
	return nil
}
func (t *NodeDescriptorSubTlv) SetOspfAreaId(v [4]uint8) bool {
	if t.Type == SubTlvtype_AutonomousSystem {
		return false
	} else if t.Type == SubTlvtype_OspfareaId {
		return false
	} else if t.Type == SubTlvtype_Bgplsid {
		if _, ok := t.union15_.(*union_19_t); !ok {
			t.union15_ = &union_19_t{}
		}
		t.union15_.(*union_19_t).OspfAreaId = [4]uint8(v)
		return true
	}
	return false
}
func (t *NodeDescriptorSubTlv) Visit(v VisitorPRAYV) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "AutonomousSystem", (t.AutonomousSystem()))
	v.Visit(v, "BgpLsIdentifier", (t.BgpLsIdentifier()))
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "IgpRouterId", (t.IgpRouterId()))
	v.Visit(v, "OspfAreaId", (t.OspfAreaId()))
}
func (t *NodeDescriptorSubTlv) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *NodeDescriptorSubTlv) Write(w io.Writer) (err error) {
	tmp22 := [2]byte{}
	binary.BigEndian.PutUint16(tmp22[:], uint16(t.Type))
	if n, err := w.Write(tmp22[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	tmp23 := [2]byte{}
	binary.BigEndian.PutUint16(tmp23[:], uint16(t.Length))
	if n, err := w.Write(tmp23[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	switch {
	case (t.Type == SubTlvtype_AutonomousSystem):
		if _, ok := t.union15_.(*union_17_t); !ok {
			return fmt.Errorf("encode t.union15_: union is not set to union_17_t")
		}
		new_buf_24 := bytes.NewBuffer(nil)
		old_buf_24_w := w
		w = new_buf_24
		if n, err := w.Write(t.union15_.(*union_17_t).AutonomousSystem[:]); err != nil || n != len(t.union15_.(*union_17_t).AutonomousSystem) {
			return fmt.Errorf("encode AutonomousSystem: %w", err)
		}
		if new_buf_24.Len() != int(t.Length) {
			return fmt.Errorf("encode AutonomousSystem: expect %d bytes but got %d bytes", new_buf_24.Len(), int(t.Length))
		}
		_, err = new_buf_24.WriteTo(old_buf_24_w)
		if err != nil {
			return err
		}
		w = old_buf_24_w
	case (t.Type == SubTlvtype_OspfareaId):
		if _, ok := t.union15_.(*union_18_t); !ok {
			return fmt.Errorf("encode t.union15_: union is not set to union_18_t")
		}
		new_buf_25 := bytes.NewBuffer(nil)
		old_buf_25_w := w
		w = new_buf_25
		if n, err := w.Write(t.union15_.(*union_18_t).BgpLsIdentifier[:]); err != nil || n != len(t.union15_.(*union_18_t).BgpLsIdentifier) {
			return fmt.Errorf("encode BgpLsIdentifier: %w", err)
		}
		if new_buf_25.Len() != int(t.Length) {
			return fmt.Errorf("encode BgpLsIdentifier: expect %d bytes but got %d bytes", new_buf_25.Len(), int(t.Length))
		}
		_, err = new_buf_25.WriteTo(old_buf_25_w)
		if err != nil {
			return err
		}
		w = old_buf_25_w
	case (t.Type == SubTlvtype_Bgplsid):
		if _, ok := t.union15_.(*union_19_t); !ok {
			return fmt.Errorf("encode t.union15_: union is not set to union_19_t")
		}
		new_buf_26 := bytes.NewBuffer(nil)
		old_buf_26_w := w
		w = new_buf_26
		if n, err := w.Write(t.union15_.(*union_19_t).OspfAreaId[:]); err != nil || n != len(t.union15_.(*union_19_t).OspfAreaId) {
			return fmt.Errorf("encode OspfAreaId: %w", err)
		}
		if new_buf_26.Len() != int(t.Length) {
			return fmt.Errorf("encode OspfAreaId: expect %d bytes but got %d bytes", new_buf_26.Len(), int(t.Length))
		}
		_, err = new_buf_26.WriteTo(old_buf_26_w)
		if err != nil {
			return err
		}
		w = old_buf_26_w
	case (t.Type == SubTlvtype_IgprouterId):
		if _, ok := t.union15_.(*union_20_t); !ok {
			return fmt.Errorf("encode t.union15_: union is not set to union_20_t")
		}
		len_IgpRouterId := int(t.Length)
		if len(t.union15_.(*union_20_t).IgpRouterId) != len_IgpRouterId {
			return fmt.Errorf("encode IgpRouterId: expect %d bytes but got %d bytes", len_IgpRouterId, len(t.union15_.(*union_20_t).IgpRouterId))
		}
		if n, err := w.Write(t.union15_.(*union_20_t).IgpRouterId); err != nil || n != len(t.union15_.(*union_20_t).IgpRouterId) {
			return fmt.Errorf("encode IgpRouterId: %w", err)
		}
	default:
		if _, ok := t.union15_.(*union_21_t); !ok {
			return fmt.Errorf("encode t.union15_: union is not set to union_21_t")
		}
		len_Data := int(t.Length)
		if len(t.union15_.(*union_21_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union15_.(*union_21_t).Data))
		}
		if n, err := w.Write(t.union15_.(*union_21_t).Data); err != nil || n != len(t.union15_.(*union_21_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *NodeDescriptorSubTlv) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NodeDescriptorSubTlv) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NodeDescriptorSubTlv) Read(r io.Reader) (err error) {
	tmpType := [2]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 2 bytes but read %d bytes: %w", n_Type, err)
	}
	t.Type = SubTlvtype(binary.BigEndian.Uint16(tmpType[:]))
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	switch {
	case (t.Type == SubTlvtype_AutonomousSystem):
		t.union15_ = &union_17_t{}
		sub_byte_len_AutonomousSystem := int64(t.Length)
		sub_byte_r_AutonomousSystem := io.LimitReader(r, int64(sub_byte_len_AutonomousSystem))
		tmp_old_r_AutonomousSystem_27 := r
		r = sub_byte_r_AutonomousSystem
		n_AutonomousSystem, err := io.ReadFull(r, t.union15_.(*union_17_t).AutonomousSystem[:])
		if err != nil {
			return fmt.Errorf("read AutonomousSystem: expect %d bytes but read %d bytes: %w", 4, n_AutonomousSystem, err)
		}
		if sub_byte_r_AutonomousSystem.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read AutonomousSystem: expect %d bytes but got %d bytes", sub_byte_len_AutonomousSystem, sub_byte_len_AutonomousSystem-sub_byte_r_AutonomousSystem.(*io.LimitedReader).N)
		}
		r = tmp_old_r_AutonomousSystem_27
	case (t.Type == SubTlvtype_OspfareaId):
		t.union15_ = &union_18_t{}
		sub_byte_len_BgpLsIdentifier := int64(t.Length)
		sub_byte_r_BgpLsIdentifier := io.LimitReader(r, int64(sub_byte_len_BgpLsIdentifier))
		tmp_old_r_BgpLsIdentifier_28 := r
		r = sub_byte_r_BgpLsIdentifier
		n_BgpLsIdentifier, err := io.ReadFull(r, t.union15_.(*union_18_t).BgpLsIdentifier[:])
		if err != nil {
			return fmt.Errorf("read BgpLsIdentifier: expect %d bytes but read %d bytes: %w", 4, n_BgpLsIdentifier, err)
		}
		if sub_byte_r_BgpLsIdentifier.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read BgpLsIdentifier: expect %d bytes but got %d bytes", sub_byte_len_BgpLsIdentifier, sub_byte_len_BgpLsIdentifier-sub_byte_r_BgpLsIdentifier.(*io.LimitedReader).N)
		}
		r = tmp_old_r_BgpLsIdentifier_28
	case (t.Type == SubTlvtype_Bgplsid):
		t.union15_ = &union_19_t{}
		sub_byte_len_OspfAreaId := int64(t.Length)
		sub_byte_r_OspfAreaId := io.LimitReader(r, int64(sub_byte_len_OspfAreaId))
		tmp_old_r_OspfAreaId_29 := r
		r = sub_byte_r_OspfAreaId
		n_OspfAreaId, err := io.ReadFull(r, t.union15_.(*union_19_t).OspfAreaId[:])
		if err != nil {
			return fmt.Errorf("read OspfAreaId: expect %d bytes but read %d bytes: %w", 4, n_OspfAreaId, err)
		}
		if sub_byte_r_OspfAreaId.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read OspfAreaId: expect %d bytes but got %d bytes", sub_byte_len_OspfAreaId, sub_byte_len_OspfAreaId-sub_byte_r_OspfAreaId.(*io.LimitedReader).N)
		}
		r = tmp_old_r_OspfAreaId_29
	case (t.Type == SubTlvtype_IgprouterId):
		t.union15_ = &union_20_t{}
		len_IgpRouterId := int(t.Length)
		if len_IgpRouterId != 0 {
			tmpIgpRouterId := make([]byte, len_IgpRouterId)
			n_IgpRouterId, err := io.ReadFull(r, tmpIgpRouterId[:])
			if err != nil {
				return fmt.Errorf("read IgpRouterId: expect %d bytes but read %d bytes: %w", len_IgpRouterId, n_IgpRouterId, err)
			}
			t.union15_.(*union_20_t).IgpRouterId = tmpIgpRouterId[:]
		} else {
			t.union15_.(*union_20_t).IgpRouterId = nil
		}
	default:
		t.union15_ = &union_21_t{}
		len_Data := int(t.Length)
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union15_.(*union_21_t).Data = tmpData[:]
		} else {
			t.union15_.(*union_21_t).Data = nil
		}
	}
	return nil
}

func (t *NodeDescriptorSubTlv) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NodeDescriptorSubTlv) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NodeDescriptorSubTlv: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *MultiTopologyId) Reserved() uint16 {
	return ((t.flags30 & 0xf000) >> 12)
}
func (t *MultiTopologyId) SetReserved(v uint16) bool {
	if v > 15 {
		return false
	}
	t.flags30 = (t.flags30 & ^uint16(0xf000)) | ((v & 0xf) << 12)
	return true
}
func (t *MultiTopologyId) MtId() uint16 {
	return ((t.flags30 & 0x0fff) >> 0)
}
func (t *MultiTopologyId) SetMtId(v uint16) bool {
	if v > 4095 {
		return false
	}
	t.flags30 = (t.flags30 & ^uint16(0xfff)) | ((v & 0xfff) << 0)
	return true
}
func (t *MultiTopologyId) Visit(v VisitorPRAYV) {
	v.Visit(v, "Reserved", t.Reserved())
	v.Visit(v, "MtId", t.MtId())
}
func (t *MultiTopologyId) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *MultiTopologyId) Write(w io.Writer) (err error) {
	tmp31 := [2]byte{}
	binary.BigEndian.PutUint16(tmp31[:], uint16(t.flags30))
	if n, err := w.Write(tmp31[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.flags30: %w", err)
	}
	return nil
}
func (t *MultiTopologyId) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *MultiTopologyId) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *MultiTopologyId) Read(r io.Reader) (err error) {
	tmpflags30 := [2]byte{}
	n_flags30, err := io.ReadFull(r, tmpflags30[:])
	if err != nil {
		return fmt.Errorf("read flags30: expect 2 bytes but read %d bytes: %w", n_flags30, err)
	}
	t.flags30 = uint16(binary.BigEndian.Uint16(tmpflags30[:]))
	return nil
}

func (t *MultiTopologyId) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *MultiTopologyId) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode MultiTopologyId: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *IpreachabilityInformation) Visit(v VisitorPRAYV) {
	v.Visit(v, "PrefixLength", &t.PrefixLength)
	v.Visit(v, "Prefix", &t.Prefix)
}
func (t *IpreachabilityInformation) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *IpreachabilityInformation) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.PrefixLength)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.PrefixLength: %w", err)
	}
	if n, err := w.Write(t.Prefix); err != nil || n != len(t.Prefix) {
		return fmt.Errorf("encode Prefix: %w", err)
	}
	return nil
}
func (t *IpreachabilityInformation) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *IpreachabilityInformation) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *IpreachabilityInformation) Read(r io.Reader) (err error) {
	tmpPrefixLength := [1]byte{}
	n_PrefixLength, err := io.ReadFull(r, tmpPrefixLength[:])
	if err != nil {
		return fmt.Errorf("read PrefixLength: expect 1 byte but read %d bytes: %w", n_PrefixLength, err)
	}
	t.PrefixLength = uint8(tmpPrefixLength[0])
	bytes_buf_Prefix := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Prefix, r); err != nil {
		return err
	}
	t.Prefix = bytes_buf_Prefix.Bytes()
	return nil
}

func (t *IpreachabilityInformation) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *IpreachabilityInformation) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode IpreachabilityInformation: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NodeFlagBits) Overload() bool {
	return ((t.flags32 & 0x80) >> 7) == 1
}
func (t *NodeFlagBits) SetOverload(v bool) {
	if v {
		t.flags32 |= uint8(0x80)
	} else {
		t.flags32 &= ^uint8(0x80)
	}
}
func (t *NodeFlagBits) Attached() bool {
	return ((t.flags32 & 0x40) >> 6) == 1
}
func (t *NodeFlagBits) SetAttached(v bool) {
	if v {
		t.flags32 |= uint8(0x40)
	} else {
		t.flags32 &= ^uint8(0x40)
	}
}
func (t *NodeFlagBits) External() bool {
	return ((t.flags32 & 0x20) >> 5) == 1
}
func (t *NodeFlagBits) SetExternal(v bool) {
	if v {
		t.flags32 |= uint8(0x20)
	} else {
		t.flags32 &= ^uint8(0x20)
	}
}
func (t *NodeFlagBits) Abr() bool {
	return ((t.flags32 & 0x10) >> 4) == 1
}
func (t *NodeFlagBits) SetAbr(v bool) {
	if v {
		t.flags32 |= uint8(0x10)
	} else {
		t.flags32 &= ^uint8(0x10)
	}
}
func (t *NodeFlagBits) Router() bool {
	return ((t.flags32 & 0x08) >> 3) == 1
}
func (t *NodeFlagBits) SetRouter(v bool) {
	if v {
		t.flags32 |= uint8(0x8)
	} else {
		t.flags32 &= ^uint8(0x8)
	}
}
func (t *NodeFlagBits) V6() bool {
	return ((t.flags32 & 0x04) >> 2) == 1
}
func (t *NodeFlagBits) SetV6(v bool) {
	if v {
		t.flags32 |= uint8(0x4)
	} else {
		t.flags32 &= ^uint8(0x4)
	}
}
func (t *NodeFlagBits) Reserved() uint8 {
	return ((t.flags32 & 0x03) >> 0)
}
func (t *NodeFlagBits) SetReserved(v uint8) bool {
	if v > 3 {
		return false
	}
	t.flags32 = (t.flags32 & ^uint8(0x3)) | ((v & 0x3) << 0)
	return true
}
func (t *NodeFlagBits) Visit(v VisitorPRAYV) {
	v.Visit(v, "Overload", (func() uint8 {
		if t.Overload() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Attached", (func() uint8 {
		if t.Attached() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "External", (func() uint8 {
		if t.External() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Abr", (func() uint8 {
		if t.Abr() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Router", (func() uint8 {
		if t.Router() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "V6", (func() uint8 {
		if t.V6() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved", t.Reserved())
}
func (t *NodeFlagBits) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *NodeFlagBits) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags32)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags32: %w", err)
	}
	return nil
}
func (t *NodeFlagBits) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NodeFlagBits) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NodeFlagBits) Read(r io.Reader) (err error) {
	tmpflags32 := [1]byte{}
	n_flags32, err := io.ReadFull(r, tmpflags32[:])
	if err != nil {
		return fmt.Errorf("read flags32: expect 1 byte but read %d bytes: %w", n_flags32, err)
	}
	t.flags32 = uint8(tmpflags32[0])
	return nil
}

func (t *NodeFlagBits) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NodeFlagBits) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NodeFlagBits: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *IsisareaIdentifier) Visit(v VisitorPRAYV) {
	v.Visit(v, "AreaId", &t.AreaId)
}
func (t *IsisareaIdentifier) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *IsisareaIdentifier) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.AreaId); err != nil || n != len(t.AreaId) {
		return fmt.Errorf("encode AreaId: %w", err)
	}
	return nil
}
func (t *IsisareaIdentifier) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *IsisareaIdentifier) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *IsisareaIdentifier) Read(r io.Reader) (err error) {
	bytes_buf_AreaId := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_AreaId, r); err != nil {
		return err
	}
	t.AreaId = bytes_buf_AreaId.Bytes()
	return nil
}

func (t *IsisareaIdentifier) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *IsisareaIdentifier) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode IsisareaIdentifier: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NodeName) Visit(v VisitorPRAYV) {
	v.Visit(v, "Name", &t.Name)
}
func (t *NodeName) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *NodeName) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.Name); err != nil || n != len(t.Name) {
		return fmt.Errorf("encode Name: %w", err)
	}
	return nil
}
func (t *NodeName) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NodeName) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NodeName) Read(r io.Reader) (err error) {
	bytes_buf_Name := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Name, r); err != nil {
		return err
	}
	t.Name = bytes_buf_Name.Bytes()
	return nil
}

func (t *NodeName) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NodeName) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NodeName: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *MplsprotocolMask) LabelDistributionProtocol() bool {
	return ((t.flags33 & 0x80) >> 7) == 1
}
func (t *MplsprotocolMask) SetLabelDistributionProtocol(v bool) {
	if v {
		t.flags33 |= uint8(0x80)
	} else {
		t.flags33 &= ^uint8(0x80)
	}
}
func (t *MplsprotocolMask) ExtensionToRsvpForLspTunnel() bool {
	return ((t.flags33 & 0x40) >> 6) == 1
}
func (t *MplsprotocolMask) SetExtensionToRsvpForLspTunnel(v bool) {
	if v {
		t.flags33 |= uint8(0x40)
	} else {
		t.flags33 &= ^uint8(0x40)
	}
}
func (t *MplsprotocolMask) Reserved() uint8 {
	return ((t.flags33 & 0x3f) >> 0)
}
func (t *MplsprotocolMask) SetReserved(v uint8) bool {
	if v > 63 {
		return false
	}
	t.flags33 = (t.flags33 & ^uint8(0x3f)) | ((v & 0x3f) << 0)
	return true
}
func (t *MplsprotocolMask) Visit(v VisitorPRAYV) {
	v.Visit(v, "LabelDistributionProtocol", (func() uint8 {
		if t.LabelDistributionProtocol() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "ExtensionToRsvpForLspTunnel", (func() uint8 {
		if t.ExtensionToRsvpForLspTunnel() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved", t.Reserved())
}
func (t *MplsprotocolMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *MplsprotocolMask) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags33)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags33: %w", err)
	}
	return nil
}
func (t *MplsprotocolMask) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *MplsprotocolMask) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *MplsprotocolMask) Read(r io.Reader) (err error) {
	tmpflags33 := [1]byte{}
	n_flags33, err := io.ReadFull(r, tmpflags33[:])
	if err != nil {
		return fmt.Errorf("read flags33: expect 1 byte but read %d bytes: %w", n_flags33, err)
	}
	t.flags33 = uint8(tmpflags33[0])
	return nil
}

func (t *MplsprotocolMask) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *MplsprotocolMask) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode MplsprotocolMask: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *LinkName) Visit(v VisitorPRAYV) {
	v.Visit(v, "Name", &t.Name)
}
func (t *LinkName) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *LinkName) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.Name); err != nil || n != len(t.Name) {
		return fmt.Errorf("encode Name: %w", err)
	}
	return nil
}
func (t *LinkName) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *LinkName) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *LinkName) Read(r io.Reader) (err error) {
	bytes_buf_Name := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Name, r); err != nil {
		return err
	}
	t.Name = bytes_buf_Name.Bytes()
	return nil
}

func (t *LinkName) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *LinkName) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode LinkName: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Igpflags) IsisUpDown() bool {
	return ((t.flags34 & 0x80) >> 7) == 1
}
func (t *Igpflags) SetIsisUpDown(v bool) {
	if v {
		t.flags34 |= uint8(0x80)
	} else {
		t.flags34 &= ^uint8(0x80)
	}
}
func (t *Igpflags) OspfNoUnicast() bool {
	return ((t.flags34 & 0x40) >> 6) == 1
}
func (t *Igpflags) SetOspfNoUnicast(v bool) {
	if v {
		t.flags34 |= uint8(0x40)
	} else {
		t.flags34 &= ^uint8(0x40)
	}
}
func (t *Igpflags) OspfNoLocalAddress() bool {
	return ((t.flags34 & 0x20) >> 5) == 1
}
func (t *Igpflags) SetOspfNoLocalAddress(v bool) {
	if v {
		t.flags34 |= uint8(0x20)
	} else {
		t.flags34 &= ^uint8(0x20)
	}
}
func (t *Igpflags) OspfPropagateNssa() bool {
	return ((t.flags34 & 0x10) >> 4) == 1
}
func (t *Igpflags) SetOspfPropagateNssa(v bool) {
	if v {
		t.flags34 |= uint8(0x10)
	} else {
		t.flags34 &= ^uint8(0x10)
	}
}
func (t *Igpflags) Reserved() uint8 {
	return ((t.flags34 & 0x0f) >> 0)
}
func (t *Igpflags) SetReserved(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags34 = (t.flags34 & ^uint8(0xf)) | ((v & 0xf) << 0)
	return true
}
func (t *Igpflags) Visit(v VisitorPRAYV) {
	v.Visit(v, "IsisUpDown", (func() uint8 {
		if t.IsisUpDown() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "OspfNoUnicast", (func() uint8 {
		if t.OspfNoUnicast() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "OspfNoLocalAddress", (func() uint8 {
		if t.OspfNoLocalAddress() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "OspfPropagateNssa", (func() uint8 {
		if t.OspfPropagateNssa() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved", t.Reserved())
}
func (t *Igpflags) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *Igpflags) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags34)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags34: %w", err)
	}
	return nil
}
func (t *Igpflags) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 1))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Igpflags) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Igpflags) Read(r io.Reader) (err error) {
	tmpflags34 := [1]byte{}
	n_flags34, err := io.ReadFull(r, tmpflags34[:])
	if err != nil {
		return fmt.Errorf("read flags34: expect 1 byte but read %d bytes: %w", n_flags34, err)
	}
	t.flags34 = uint8(tmpflags34[0])
	return nil
}

func (t *Igpflags) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Igpflags) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Igpflags: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *RouteTags) Visit(v VisitorPRAYV) {
	v.Visit(v, "Tags", &t.Tags)
}
func (t *RouteTags) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *RouteTags) Write(w io.Writer) (err error) {
	for _, v := range t.Tags {
		tmp35 := [4]byte{}
		binary.BigEndian.PutUint32(tmp35[:], uint32(v))
		if n, err := w.Write(tmp35[:]); err != nil || n != 4 {
			return fmt.Errorf("encode v: %w", err)
		}
	}
	return nil
}
func (t *RouteTags) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *RouteTags) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *RouteTags) Read(r io.Reader) (err error) {
	tmp_byte_scanner36_ := bufio.NewReaderSize(r, 1)
	old_r_Tags := r
	r = tmp_byte_scanner36_
	for {
		_, err := tmp_byte_scanner36_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Tags: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner36_.UnreadByte(); err != nil {
			return fmt.Errorf("read Tags: unexpected unread error: %w", err)
		}
		var tmp37_ uint32
		tmpTags := [4]byte{}
		n_Tags, err := io.ReadFull(r, tmpTags[:])
		if err != nil {
			return fmt.Errorf("read Tags: expect 4 bytes but read %d bytes: %w", n_Tags, err)
		}
		tmp37_ = uint32(binary.BigEndian.Uint32(tmpTags[:]))
		t.Tags = append(t.Tags, tmp37_)
	}
	r = old_r_Tags
	return nil
}

func (t *RouteTags) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *RouteTags) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode RouteTags: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *PrefixMetric) Visit(v VisitorPRAYV) {
	v.Visit(v, "Metric", &t.Metric)
}
func (t *PrefixMetric) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *PrefixMetric) Write(w io.Writer) (err error) {
	tmp38 := [4]byte{}
	binary.BigEndian.PutUint32(tmp38[:], uint32(t.Metric))
	if n, err := w.Write(tmp38[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Metric: %w", err)
	}
	return nil
}
func (t *PrefixMetric) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *PrefixMetric) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *PrefixMetric) Read(r io.Reader) (err error) {
	tmpMetric := [4]byte{}
	n_Metric, err := io.ReadFull(r, tmpMetric[:])
	if err != nil {
		return fmt.Errorf("read Metric: expect 4 bytes but read %d bytes: %w", n_Metric, err)
	}
	t.Metric = uint32(binary.BigEndian.Uint32(tmpMetric[:]))
	return nil
}

func (t *PrefixMetric) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *PrefixMetric) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode PrefixMetric: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *OspfforwardingAddress) Visit(v VisitorPRAYV) {
	v.Visit(v, "ForwardingAddress", &t.ForwardingAddress)
}
func (t *OspfforwardingAddress) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *OspfforwardingAddress) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.ForwardingAddress); err != nil || n != len(t.ForwardingAddress) {
		return fmt.Errorf("encode ForwardingAddress: %w", err)
	}
	return nil
}
func (t *OspfforwardingAddress) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *OspfforwardingAddress) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *OspfforwardingAddress) Read(r io.Reader) (err error) {
	bytes_buf_ForwardingAddress := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_ForwardingAddress, r); err != nil {
		return err
	}
	t.ForwardingAddress = bytes_buf_ForwardingAddress.Bytes()
	return nil
}

func (t *OspfforwardingAddress) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *OspfforwardingAddress) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode OspfforwardingAddress: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *OpaquePrefixAttribute) Visit(v VisitorPRAYV) {
	v.Visit(v, "PrefixAttributes", &t.PrefixAttributes)
}
func (t *OpaquePrefixAttribute) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *OpaquePrefixAttribute) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.PrefixAttributes); err != nil || n != len(t.PrefixAttributes) {
		return fmt.Errorf("encode PrefixAttributes: %w", err)
	}
	return nil
}
func (t *OpaquePrefixAttribute) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *OpaquePrefixAttribute) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *OpaquePrefixAttribute) Read(r io.Reader) (err error) {
	bytes_buf_PrefixAttributes := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_PrefixAttributes, r); err != nil {
		return err
	}
	t.PrefixAttributes = bytes_buf_PrefixAttributes.Bytes()
	return nil
}

func (t *OpaquePrefixAttribute) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *OpaquePrefixAttribute) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode OpaquePrefixAttribute: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *ExtendedCommunity) Visit(v VisitorPRAYV) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Subtype", &t.Subtype)
	v.Visit(v, "Data", &t.Data)
}
func (t *ExtendedCommunity) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *ExtendedCommunity) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Type)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Subtype)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Subtype: %w", err)
	}
	if n, err := w.Write(t.Data[:]); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *ExtendedCommunity) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *ExtendedCommunity) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *ExtendedCommunity) Read(r io.Reader) (err error) {
	tmpType := [1]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 1 byte but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint8(tmpType[0])
	tmpSubtype := [1]byte{}
	n_Subtype, err := io.ReadFull(r, tmpSubtype[:])
	if err != nil {
		return fmt.Errorf("read Subtype: expect 1 byte but read %d bytes: %w", n_Subtype, err)
	}
	t.Subtype = uint8(tmpSubtype[0])
	n_Data, err := io.ReadFull(r, t.Data[:])
	if err != nil {
		return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", 6, n_Data, err)
	}
	return nil
}

func (t *ExtendedCommunity) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *ExtendedCommunity) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode ExtendedCommunity: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *CandidatePathDescriptorSubTlv) SetData(v []uint8) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.Length = uint16(len(v))
	t.Data = v
	return true
}
func (t *CandidatePathDescriptorSubTlv) Visit(v VisitorPRAYV) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Data", &t.Data)
}
func (t *CandidatePathDescriptorSubTlv) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *CandidatePathDescriptorSubTlv) Write(w io.Writer) (err error) {
	tmp39 := [2]byte{}
	binary.BigEndian.PutUint16(tmp39[:], uint16(t.Type))
	if n, err := w.Write(tmp39[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	tmp40 := [2]byte{}
	binary.BigEndian.PutUint16(tmp40[:], uint16(t.Length))
	if n, err := w.Write(tmp40[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	len_Data := int(t.Length)
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.Data))
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *CandidatePathDescriptorSubTlv) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *CandidatePathDescriptorSubTlv) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *CandidatePathDescriptorSubTlv) Read(r io.Reader) (err error) {
	tmpType := [2]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 2 bytes but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint16(binary.BigEndian.Uint16(tmpType[:]))
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	len_Data := int(t.Length)
	if len_Data != 0 {
		tmpData := make([]byte, len_Data)
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
		}
		t.Data = tmpData[:]
	} else {
		t.Data = nil
	}
	return nil
}

func (t *CandidatePathDescriptorSubTlv) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *CandidatePathDescriptorSubTlv) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode CandidatePathDescriptorSubTlv: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SrpolicyCandidatePathDescriptor) EndpointAsIpv6() bool {
	return ((t.flags41 & 0x80) >> 7) == 1
}
func (t *SrpolicyCandidatePathDescriptor) SetEndpointAsIpv6(v bool) {
	if v {
		t.flags41 |= uint8(0x80)
	} else {
		t.flags41 &= ^uint8(0x80)
	}
}
func (t *SrpolicyCandidatePathDescriptor) OriginatorAsIpv6() bool {
	return ((t.flags41 & 0x40) >> 6) == 1
}
func (t *SrpolicyCandidatePathDescriptor) SetOriginatorAsIpv6(v bool) {
	if v {
		t.flags41 |= uint8(0x40)
	} else {
		t.flags41 &= ^uint8(0x40)
	}
}
func (t *SrpolicyCandidatePathDescriptor) Reserved1() uint8 {
	return ((t.flags41 & 0x3f) >> 0)
}
func (t *SrpolicyCandidatePathDescriptor) SetReserved1(v uint8) bool {
	if v > 63 {
		return false
	}
	t.flags41 = (t.flags41 & ^uint8(0x3f)) | ((v & 0x3f) << 0)
	return true
}
func (t *SrpolicyCandidatePathDescriptor) SetEndpoint(v []uint8) bool {
	t.Endpoint = v
	return true
}
func (t *SrpolicyCandidatePathDescriptor) SetOriginatorAddress(v []uint8) bool {
	t.OriginatorAddress = v
	return true
}
func (t *SrpolicyCandidatePathDescriptor) Visit(v VisitorPRAYV) {
	v.Visit(v, "ProtocolOrigin", &t.ProtocolOrigin)
	v.Visit(v, "EndpointAsIpv6", (func() uint8 {
		if t.EndpointAsIpv6() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "OriginatorAsIpv6", (func() uint8 {
		if t.OriginatorAsIpv6() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved1", t.Reserved1())
	v.Visit(v, "Reserved2", &t.Reserved2)
	v.Visit(v, "Endpoint", &t.Endpoint)
	v.Visit(v, "PolicyColor", &t.PolicyColor)
	v.Visit(v, "OriginatorAsNumber", &t.OriginatorAsNumber)
	v.Visit(v, "OriginatorAddress", &t.OriginatorAddress)
	v.Visit(v, "Discriminator", &t.Discriminator)
}
func (t *SrpolicyCandidatePathDescriptor) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *SrpolicyCandidatePathDescriptor) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.ProtocolOrigin)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.ProtocolOrigin: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags41)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags41: %w", err)
	}
	tmp42 := [2]byte{}
	binary.BigEndian.PutUint16(tmp42[:], uint16(t.Reserved2))
	if n, err := w.Write(tmp42[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Reserved2: %w", err)
	}
	EndpointLen := (func() uint8 {
		if (func() uint8 {
			if t.EndpointAsIpv6() {
				return 1
			} else {
				return 0
			}
		}()) == 1 {
			return uint8(16)
		} else {
			return uint8(4)
		}
	}())
	len_Endpoint := int(EndpointLen)
	if len(t.Endpoint) != len_Endpoint {
		return fmt.Errorf("encode Endpoint: expect %d bytes but got %d bytes", len_Endpoint, len(t.Endpoint))
	}
	if n, err := w.Write(t.Endpoint); err != nil || n != len(t.Endpoint) {
		return fmt.Errorf("encode Endpoint: %w", err)
	}
	tmp43 := [4]byte{}
	binary.BigEndian.PutUint32(tmp43[:], uint32(t.PolicyColor))
	if n, err := w.Write(tmp43[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.PolicyColor: %w", err)
	}
	tmp44 := [4]byte{}
	binary.BigEndian.PutUint32(tmp44[:], uint32(t.OriginatorAsNumber))
	if n, err := w.Write(tmp44[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.OriginatorAsNumber: %w", err)
	}
	OriginatorLen := (func() uint8 {
		if (func() uint8 {
			if t.OriginatorAsIpv6() {
				return 1
			} else {
				return 0
			}
		}()) == 1 {
			return uint8(16)
		} else {
			return uint8(4)
		}
	}())
	len_OriginatorAddress := int(OriginatorLen)
	if len(t.OriginatorAddress) != len_OriginatorAddress {
		return fmt.Errorf("encode OriginatorAddress: expect %d bytes but got %d bytes", len_OriginatorAddress, len(t.OriginatorAddress))
	}
	if n, err := w.Write(t.OriginatorAddress); err != nil || n != len(t.OriginatorAddress) {
		return fmt.Errorf("encode OriginatorAddress: %w", err)
	}
	tmp45 := [4]byte{}
	binary.BigEndian.PutUint32(tmp45[:], uint32(t.Discriminator))
	if n, err := w.Write(tmp45[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Discriminator: %w", err)
	}
	return nil
}
func (t *SrpolicyCandidatePathDescriptor) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SrpolicyCandidatePathDescriptor) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SrpolicyCandidatePathDescriptor) Read(r io.Reader) (err error) {
	tmpProtocolOrigin := [1]byte{}
	n_ProtocolOrigin, err := io.ReadFull(r, tmpProtocolOrigin[:])
	if err != nil {
		return fmt.Errorf("read ProtocolOrigin: expect 1 byte but read %d bytes: %w", n_ProtocolOrigin, err)
	}
	t.ProtocolOrigin = uint8(tmpProtocolOrigin[0])
	tmpflags41 := [1]byte{}
	n_flags41, err := io.ReadFull(r, tmpflags41[:])
	if err != nil {
		return fmt.Errorf("read flags41: expect 1 byte but read %d bytes: %w", n_flags41, err)
	}
	t.flags41 = uint8(tmpflags41[0])
	tmpReserved2 := [2]byte{}
	n_Reserved2, err := io.ReadFull(r, tmpReserved2[:])
	if err != nil {
		return fmt.Errorf("read Reserved2: expect 2 bytes but read %d bytes: %w", n_Reserved2, err)
	}
	t.Reserved2 = uint16(binary.BigEndian.Uint16(tmpReserved2[:]))
	EndpointLen := (func() uint8 {
		if (func() uint8 {
			if t.EndpointAsIpv6() {
				return 1
			} else {
				return 0
			}
		}()) == 1 {
			return uint8(16)
		} else {
			return uint8(4)
		}
	}())
	len_Endpoint := int(EndpointLen)
	if len_Endpoint != 0 {
		tmpEndpoint := make([]byte, len_Endpoint)
		n_Endpoint, err := io.ReadFull(r, tmpEndpoint[:])
		if err != nil {
			return fmt.Errorf("read Endpoint: expect %d bytes but read %d bytes: %w", len_Endpoint, n_Endpoint, err)
		}
		t.Endpoint = tmpEndpoint[:]
	} else {
		t.Endpoint = nil
	}
	tmpPolicyColor := [4]byte{}
	n_PolicyColor, err := io.ReadFull(r, tmpPolicyColor[:])
	if err != nil {
		return fmt.Errorf("read PolicyColor: expect 4 bytes but read %d bytes: %w", n_PolicyColor, err)
	}
	t.PolicyColor = uint32(binary.BigEndian.Uint32(tmpPolicyColor[:]))
	tmpOriginatorAsNumber := [4]byte{}
	n_OriginatorAsNumber, err := io.ReadFull(r, tmpOriginatorAsNumber[:])
	if err != nil {
		return fmt.Errorf("read OriginatorAsNumber: expect 4 bytes but read %d bytes: %w", n_OriginatorAsNumber, err)
	}
	t.OriginatorAsNumber = uint32(binary.BigEndian.Uint32(tmpOriginatorAsNumber[:]))
	OriginatorLen := (func() uint8 {
		if (func() uint8 {
			if t.OriginatorAsIpv6() {
				return 1
			} else {
				return 0
			}
		}()) == 1 {
			return uint8(16)
		} else {
			return uint8(4)
		}
	}())
	len_OriginatorAddress := int(OriginatorLen)
	if len_OriginatorAddress != 0 {
		tmpOriginatorAddress := make([]byte, len_OriginatorAddress)
		n_OriginatorAddress, err := io.ReadFull(r, tmpOriginatorAddress[:])
		if err != nil {
			return fmt.Errorf("read OriginatorAddress: expect %d bytes but read %d bytes: %w", len_OriginatorAddress, n_OriginatorAddress, err)
		}
		t.OriginatorAddress = tmpOriginatorAddress[:]
	} else {
		t.OriginatorAddress = nil
	}
	tmpDiscriminator := [4]byte{}
	n_Discriminator, err := io.ReadFull(r, tmpDiscriminator[:])
	if err != nil {
		return fmt.Errorf("read Discriminator: expect 4 bytes but read %d bytes: %w", n_Discriminator, err)
	}
	t.Discriminator = uint32(binary.BigEndian.Uint32(tmpDiscriminator[:]))
	return nil
}

func (t *SrpolicyCandidatePathDescriptor) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SrpolicyCandidatePathDescriptor) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SrpolicyCandidatePathDescriptor: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SrbindingSid) DataplaneAsSrv6() bool {
	return ((t.flags46 & 0x8000) >> 15) == 1
}
func (t *SrbindingSid) SetDataplaneAsSrv6(v bool) {
	if v {
		t.flags46 |= uint16(0x8000)
	} else {
		t.flags46 &= ^uint16(0x8000)
	}
}
func (t *SrbindingSid) Allocation() bool {
	return ((t.flags46 & 0x4000) >> 14) == 1
}
func (t *SrbindingSid) SetAllocation(v bool) {
	if v {
		t.flags46 |= uint16(0x4000)
	} else {
		t.flags46 &= ^uint16(0x4000)
	}
}
func (t *SrbindingSid) Unavailable() bool {
	return ((t.flags46 & 0x2000) >> 13) == 1
}
func (t *SrbindingSid) SetUnavailable(v bool) {
	if v {
		t.flags46 |= uint16(0x2000)
	} else {
		t.flags46 &= ^uint16(0x2000)
	}
}
func (t *SrbindingSid) LocalBlock() bool {
	return ((t.flags46 & 0x1000) >> 12) == 1
}
func (t *SrbindingSid) SetLocalBlock(v bool) {
	if v {
		t.flags46 |= uint16(0x1000)
	} else {
		t.flags46 &= ^uint16(0x1000)
	}
}
func (t *SrbindingSid) Fallback() bool {
	return ((t.flags46 & 0x0800) >> 11) == 1
}
func (t *SrbindingSid) SetFallback(v bool) {
	if v {
		t.flags46 |= uint16(0x800)
	} else {
		t.flags46 &= ^uint16(0x800)
	}
}
func (t *SrbindingSid) Reserved1() uint16 {
	return ((t.flags46 & 0x07ff) >> 0)
}
func (t *SrbindingSid) SetReserved1(v uint16) bool {
	if v > 2047 {
		return false
	}
	t.flags46 = (t.flags46 & ^uint16(0x7ff)) | ((v & 0x7ff) << 0)
	return true
}
func (t *SrbindingSid) SetBindingSid(v []uint8) bool {
	t.BindingSid = v
	return true
}
func (t *SrbindingSid) SetSpecifiedBindingSid(v []uint8) bool {
	t.SpecifiedBindingSid = v
	return true
}
func (t *SrbindingSid) Visit(v VisitorPRAYV) {
	v.Visit(v, "DataplaneAsSrv6", (func() uint16 {
		if t.DataplaneAsSrv6() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Allocation", (func() uint16 {
		if t.Allocation() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Unavailable", (func() uint16 {
		if t.Unavailable() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "LocalBlock", (func() uint16 {
		if t.LocalBlock() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Fallback", (func() uint16 {
		if t.Fallback() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved1", t.Reserved1())
	v.Visit(v, "Reserved2", &t.Reserved2)
	v.Visit(v, "BindingSid", &t.BindingSid)
	v.Visit(v, "SpecifiedBindingSid", &t.SpecifiedBindingSid)
}
func (t *SrbindingSid) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *SrbindingSid) Write(w io.Writer) (err error) {
	tmp47 := [2]byte{}
	binary.BigEndian.PutUint16(tmp47[:], uint16(t.flags46))
	if n, err := w.Write(tmp47[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.flags46: %w", err)
	}
	tmp48 := [2]byte{}
	binary.BigEndian.PutUint16(tmp48[:], uint16(t.Reserved2))
	if n, err := w.Write(tmp48[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Reserved2: %w", err)
	}
	SidLen := (func() uint8 {
		if (func() uint16 {
			if t.DataplaneAsSrv6() {
				return 1
			} else {
				return 0
			}
		}()) == 1 {
			return uint8(16)
		} else {
			return uint8(4)
		}
	}())
	len_BindingSid := int(SidLen)
	if len(t.BindingSid) != len_BindingSid {
		return fmt.Errorf("encode BindingSid: expect %d bytes but got %d bytes", len_BindingSid, len(t.BindingSid))
	}
	if n, err := w.Write(t.BindingSid); err != nil || n != len(t.BindingSid) {
		return fmt.Errorf("encode BindingSid: %w", err)
	}
	len_SpecifiedBindingSid := int(SidLen)
	if len(t.SpecifiedBindingSid) != len_SpecifiedBindingSid {
		return fmt.Errorf("encode SpecifiedBindingSid: expect %d bytes but got %d bytes", len_SpecifiedBindingSid, len(t.SpecifiedBindingSid))
	}
	if n, err := w.Write(t.SpecifiedBindingSid); err != nil || n != len(t.SpecifiedBindingSid) {
		return fmt.Errorf("encode SpecifiedBindingSid: %w", err)
	}
	return nil
}
func (t *SrbindingSid) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SrbindingSid) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SrbindingSid) Read(r io.Reader) (err error) {
	tmpflags46 := [2]byte{}
	n_flags46, err := io.ReadFull(r, tmpflags46[:])
	if err != nil {
		return fmt.Errorf("read flags46: expect 2 bytes but read %d bytes: %w", n_flags46, err)
	}
	t.flags46 = uint16(binary.BigEndian.Uint16(tmpflags46[:]))
	tmpReserved2 := [2]byte{}
	n_Reserved2, err := io.ReadFull(r, tmpReserved2[:])
	if err != nil {
		return fmt.Errorf("read Reserved2: expect 2 bytes but read %d bytes: %w", n_Reserved2, err)
	}
	t.Reserved2 = uint16(binary.BigEndian.Uint16(tmpReserved2[:]))
	SidLen := (func() uint8 {
		if (func() uint16 {
			if t.DataplaneAsSrv6() {
				return 1
			} else {
				return 0
			}
		}()) == 1 {
			return uint8(16)
		} else {
			return uint8(4)
		}
	}())
	len_BindingSid := int(SidLen)
	if len_BindingSid != 0 {
		tmpBindingSid := make([]byte, len_BindingSid)
		n_BindingSid, err := io.ReadFull(r, tmpBindingSid[:])
		if err != nil {
			return fmt.Errorf("read BindingSid: expect %d bytes but read %d bytes: %w", len_BindingSid, n_BindingSid, err)
		}
		t.BindingSid = tmpBindingSid[:]
	} else {
		t.BindingSid = nil
	}
	len_SpecifiedBindingSid := int(SidLen)
	if len_SpecifiedBindingSid != 0 {
		tmpSpecifiedBindingSid := make([]byte, len_SpecifiedBindingSid)
		n_SpecifiedBindingSid, err := io.ReadFull(r, tmpSpecifiedBindingSid[:])
		if err != nil {
			return fmt.Errorf("read SpecifiedBindingSid: expect %d bytes but read %d bytes: %w", len_SpecifiedBindingSid, n_SpecifiedBindingSid, err)
		}
		t.SpecifiedBindingSid = tmpSpecifiedBindingSid[:]
	} else {
		t.SpecifiedBindingSid = nil
	}
	return nil
}

func (t *SrbindingSid) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SrbindingSid) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SrbindingSid: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Srv6BindingSidsubTlv) SetData(v []uint8) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.Length = uint16(len(v))
	t.Data = v
	return true
}
func (t *Srv6BindingSidsubTlv) Visit(v VisitorPRAYV) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Data", &t.Data)
}
func (t *Srv6BindingSidsubTlv) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *Srv6BindingSidsubTlv) Write(w io.Writer) (err error) {
	tmp49 := [2]byte{}
	binary.BigEndian.PutUint16(tmp49[:], uint16(t.Type))
	if n, err := w.Write(tmp49[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	tmp50 := [2]byte{}
	binary.BigEndian.PutUint16(tmp50[:], uint16(t.Length))
	if n, err := w.Write(tmp50[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	len_Data := int(t.Length)
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.Data))
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *Srv6BindingSidsubTlv) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Srv6BindingSidsubTlv) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Srv6BindingSidsubTlv) Read(r io.Reader) (err error) {
	tmpType := [2]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 2 bytes but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint16(binary.BigEndian.Uint16(tmpType[:]))
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	len_Data := int(t.Length)
	if len_Data != 0 {
		tmpData := make([]byte, len_Data)
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
		}
		t.Data = tmpData[:]
	} else {
		t.Data = nil
	}
	return nil
}

func (t *Srv6BindingSidsubTlv) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Srv6BindingSidsubTlv) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Srv6BindingSidsubTlv: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SrcandidatePathState) IsAdministrative() bool {
	return ((t.flags51 & 0x80) >> 7) == 1
}
func (t *SrcandidatePathState) SetIsAdministrative(v bool) {
	if v {
		t.flags51 |= uint8(0x80)
	} else {
		t.flags51 &= ^uint8(0x80)
	}
}
func (t *SrcandidatePathState) IsActive() bool {
	return ((t.flags51 & 0x40) >> 6) == 1
}
func (t *SrcandidatePathState) SetIsActive(v bool) {
	if v {
		t.flags51 |= uint8(0x40)
	} else {
		t.flags51 &= ^uint8(0x40)
	}
}
func (t *SrcandidatePathState) IsBackup() bool {
	return ((t.flags51 & 0x20) >> 5) == 1
}
func (t *SrcandidatePathState) SetIsBackup(v bool) {
	if v {
		t.flags51 |= uint8(0x20)
	} else {
		t.flags51 &= ^uint8(0x20)
	}
}
func (t *SrcandidatePathState) EvaluatedForValidity() bool {
	return ((t.flags51 & 0x10) >> 4) == 1
}
func (t *SrcandidatePathState) SetEvaluatedForValidity(v bool) {
	if v {
		t.flags51 |= uint8(0x10)
	} else {
		t.flags51 &= ^uint8(0x10)
	}
}
func (t *SrcandidatePathState) LeastOneSidList() bool {
	return ((t.flags51 & 0x08) >> 3) == 1
}
func (t *SrcandidatePathState) SetLeastOneSidList(v bool) {
	if v {
		t.flags51 |= uint8(0x8)
	} else {
		t.flags51 &= ^uint8(0x8)
	}
}
func (t *SrcandidatePathState) DueToOnDemandNextHopTrigger() bool {
	return ((t.flags51 & 0x04) >> 2) == 1
}
func (t *SrcandidatePathState) SetDueToOnDemandNextHopTrigger(v bool) {
	if v {
		t.flags51 |= uint8(0x4)
	} else {
		t.flags51 &= ^uint8(0x4)
	}
}
func (t *SrcandidatePathState) Delegated() bool {
	return ((t.flags51 & 0x02) >> 1) == 1
}
func (t *SrcandidatePathState) SetDelegated(v bool) {
	if v {
		t.flags51 |= uint8(0x2)
	} else {
		t.flags51 &= ^uint8(0x2)
	}
}
func (t *SrcandidatePathState) Provisioned() bool {
	return ((t.flags51 & 0x01) >> 0) == 1
}
func (t *SrcandidatePathState) SetProvisioned(v bool) {
	if v {
		t.flags51 |= uint8(0x1)
	} else {
		t.flags51 &= ^uint8(0x1)
	}
}
func (t *SrcandidatePathState) DropUponInvalid() bool {
	return ((t.flags52 & 0x80) >> 7) == 1
}
func (t *SrcandidatePathState) SetDropUponInvalid(v bool) {
	if v {
		t.flags52 |= uint8(0x80)
	} else {
		t.flags52 &= ^uint8(0x80)
	}
}
func (t *SrcandidatePathState) EligibleForTransitPolicy() bool {
	return ((t.flags52 & 0x40) >> 6) == 1
}
func (t *SrcandidatePathState) SetEligibleForTransitPolicy(v bool) {
	if v {
		t.flags52 |= uint8(0x40)
	} else {
		t.flags52 &= ^uint8(0x40)
	}
}
func (t *SrcandidatePathState) SrPolicyDropUponInvalid() bool {
	return ((t.flags52 & 0x20) >> 5) == 1
}
func (t *SrcandidatePathState) SetSrPolicyDropUponInvalid(v bool) {
	if v {
		t.flags52 |= uint8(0x20)
	} else {
		t.flags52 &= ^uint8(0x20)
	}
}
func (t *SrcandidatePathState) Reserved2() uint8 {
	return ((t.flags52 & 0x1f) >> 0)
}
func (t *SrcandidatePathState) SetReserved2(v uint8) bool {
	if v > 31 {
		return false
	}
	t.flags52 = (t.flags52 & ^uint8(0x1f)) | ((v & 0x1f) << 0)
	return true
}
func (t *SrcandidatePathState) Visit(v VisitorPRAYV) {
	v.Visit(v, "Priority", &t.Priority)
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "IsAdministrative", (func() uint8 {
		if t.IsAdministrative() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "IsActive", (func() uint8 {
		if t.IsActive() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "IsBackup", (func() uint8 {
		if t.IsBackup() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "EvaluatedForValidity", (func() uint8 {
		if t.EvaluatedForValidity() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "LeastOneSidList", (func() uint8 {
		if t.LeastOneSidList() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "DueToOnDemandNextHopTrigger", (func() uint8 {
		if t.DueToOnDemandNextHopTrigger() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Delegated", (func() uint8 {
		if t.Delegated() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Provisioned", (func() uint8 {
		if t.Provisioned() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "DropUponInvalid", (func() uint8 {
		if t.DropUponInvalid() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "EligibleForTransitPolicy", (func() uint8 {
		if t.EligibleForTransitPolicy() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "SrPolicyDropUponInvalid", (func() uint8 {
		if t.SrPolicyDropUponInvalid() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved2", t.Reserved2())
	v.Visit(v, "Preference", &t.Preference)
}
func (t *SrcandidatePathState) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *SrcandidatePathState) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Priority)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Priority: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Reserved)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags51)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags51: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags52)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags52: %w", err)
	}
	tmp53 := [4]byte{}
	binary.BigEndian.PutUint32(tmp53[:], uint32(t.Preference))
	if n, err := w.Write(tmp53[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Preference: %w", err)
	}
	return nil
}
func (t *SrcandidatePathState) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SrcandidatePathState) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SrcandidatePathState) Read(r io.Reader) (err error) {
	tmpPriority := [1]byte{}
	n_Priority, err := io.ReadFull(r, tmpPriority[:])
	if err != nil {
		return fmt.Errorf("read Priority: expect 1 byte but read %d bytes: %w", n_Priority, err)
	}
	t.Priority = uint8(tmpPriority[0])
	tmpReserved := [1]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 1 byte but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint8(tmpReserved[0])
	tmpflags51 := [1]byte{}
	n_flags51, err := io.ReadFull(r, tmpflags51[:])
	if err != nil {
		return fmt.Errorf("read flags51: expect 1 byte but read %d bytes: %w", n_flags51, err)
	}
	t.flags51 = uint8(tmpflags51[0])
	tmpflags52 := [1]byte{}
	n_flags52, err := io.ReadFull(r, tmpflags52[:])
	if err != nil {
		return fmt.Errorf("read flags52: expect 1 byte but read %d bytes: %w", n_flags52, err)
	}
	t.flags52 = uint8(tmpflags52[0])
	tmpPreference := [4]byte{}
	n_Preference, err := io.ReadFull(r, tmpPreference[:])
	if err != nil {
		return fmt.Errorf("read Preference: expect 4 bytes but read %d bytes: %w", n_Preference, err)
	}
	t.Preference = uint32(binary.BigEndian.Uint32(tmpPreference[:]))
	return nil
}

func (t *SrcandidatePathState) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SrcandidatePathState) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SrcandidatePathState: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SrpolicyName) Visit(v VisitorPRAYV) {
	v.Visit(v, "Name", &t.Name)
}
func (t *SrpolicyName) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *SrpolicyName) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.Name); err != nil || n != len(t.Name) {
		return fmt.Errorf("encode Name: %w", err)
	}
	return nil
}
func (t *SrpolicyName) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SrpolicyName) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SrpolicyName) Read(r io.Reader) (err error) {
	bytes_buf_Name := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Name, r); err != nil {
		return err
	}
	t.Name = bytes_buf_Name.Bytes()
	return nil
}

func (t *SrpolicyName) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SrpolicyName) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SrpolicyName: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SrcandidatePathName) Visit(v VisitorPRAYV) {
	v.Visit(v, "Name", &t.Name)
}
func (t *SrcandidatePathName) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *SrcandidatePathName) Write(w io.Writer) (err error) {
	if n, err := w.Write(t.Name); err != nil || n != len(t.Name) {
		return fmt.Errorf("encode Name: %w", err)
	}
	return nil
}
func (t *SrcandidatePathName) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SrcandidatePathName) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SrcandidatePathName) Read(r io.Reader) (err error) {
	bytes_buf_Name := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_Name, r); err != nil {
		return err
	}
	t.Name = bytes_buf_Name.Bytes()
	return nil
}

func (t *SrcandidatePathName) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SrcandidatePathName) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SrcandidatePathName: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SrcandidateConstraintsSubTlv) SetData(v []uint8) bool {
	if len(v) > int(^uint16(0)) {
		return false
	}
	t.Length = uint16(len(v))
	t.Data = v
	return true
}
func (t *SrcandidateConstraintsSubTlv) Visit(v VisitorPRAYV) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Data", &t.Data)
}
func (t *SrcandidateConstraintsSubTlv) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *SrcandidateConstraintsSubTlv) Write(w io.Writer) (err error) {
	tmp54 := [2]byte{}
	binary.BigEndian.PutUint16(tmp54[:], uint16(t.Type))
	if n, err := w.Write(tmp54[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	tmp55 := [2]byte{}
	binary.BigEndian.PutUint16(tmp55[:], uint16(t.Length))
	if n, err := w.Write(tmp55[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	len_Data := int(t.Length)
	if len(t.Data) != len_Data {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.Data))
	}
	if n, err := w.Write(t.Data); err != nil || n != len(t.Data) {
		return fmt.Errorf("encode Data: %w", err)
	}
	return nil
}
func (t *SrcandidateConstraintsSubTlv) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SrcandidateConstraintsSubTlv) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SrcandidateConstraintsSubTlv) Read(r io.Reader) (err error) {
	tmpType := [2]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 2 bytes but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint16(binary.BigEndian.Uint16(tmpType[:]))
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	len_Data := int(t.Length)
	if len_Data != 0 {
		tmpData := make([]byte, len_Data)
		n_Data, err := io.ReadFull(r, tmpData[:])
		if err != nil {
			return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
		}
		t.Data = tmpData[:]
	} else {
		t.Data = nil
	}
	return nil
}

func (t *SrcandidateConstraintsSubTlv) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SrcandidateConstraintsSubTlv) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SrcandidateConstraintsSubTlv: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SraffinityConstraint) SetExclAny(v []uint32) bool {
	if len(v) > int(^uint8(0)) {
		return false
	}
	t.ExclAnySize = uint8(len(v))
	t.ExclAny = v
	return true
}
func (t *SraffinityConstraint) SetIncAny(v []uint32) bool {
	if len(v) > int(^uint8(0)) {
		return false
	}
	t.IncAnySize = uint8(len(v))
	t.IncAny = v
	return true
}
func (t *SraffinityConstraint) SetInclAll(v []uint32) bool {
	if len(v) > int(^uint8(0)) {
		return false
	}
	t.InclAllSize = uint8(len(v))
	t.InclAll = v
	return true
}
func (t *SraffinityConstraint) Visit(v VisitorPRAYV) {
	v.Visit(v, "ExclAnySize", &t.ExclAnySize)
	v.Visit(v, "IncAnySize", &t.IncAnySize)
	v.Visit(v, "InclAllSize", &t.InclAllSize)
	v.Visit(v, "Reserved", &t.Reserved)
	v.Visit(v, "ExclAny", &t.ExclAny)
	v.Visit(v, "IncAny", &t.IncAny)
	v.Visit(v, "InclAll", &t.InclAll)
}
func (t *SraffinityConstraint) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *SraffinityConstraint) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.ExclAnySize)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.ExclAnySize: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.IncAnySize)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.IncAnySize: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.InclAllSize)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.InclAllSize: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Reserved)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Reserved: %w", err)
	}
	len_ExclAny := int(t.ExclAnySize)
	if len(t.ExclAny) != len_ExclAny {
		return fmt.Errorf("encode ExclAny: expect %d but got %d for length", len_ExclAny, len(t.ExclAny))
	}
	for _, v := range t.ExclAny {
		tmp56 := [4]byte{}
		binary.BigEndian.PutUint32(tmp56[:], uint32(v))
		if n, err := w.Write(tmp56[:]); err != nil || n != 4 {
			return fmt.Errorf("encode v: %w", err)
		}
	}
	len_IncAny := int(t.IncAnySize)
	if len(t.IncAny) != len_IncAny {
		return fmt.Errorf("encode IncAny: expect %d but got %d for length", len_IncAny, len(t.IncAny))
	}
	for _, v := range t.IncAny {
		tmp57 := [4]byte{}
		binary.BigEndian.PutUint32(tmp57[:], uint32(v))
		if n, err := w.Write(tmp57[:]); err != nil || n != 4 {
			return fmt.Errorf("encode v: %w", err)
		}
	}
	len_InclAll := int(t.InclAllSize)
	if len(t.InclAll) != len_InclAll {
		return fmt.Errorf("encode InclAll: expect %d but got %d for length", len_InclAll, len(t.InclAll))
	}
	for _, v := range t.InclAll {
		tmp58 := [4]byte{}
		binary.BigEndian.PutUint32(tmp58[:], uint32(v))
		if n, err := w.Write(tmp58[:]); err != nil || n != 4 {
			return fmt.Errorf("encode v: %w", err)
		}
	}
	return nil
}
func (t *SraffinityConstraint) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SraffinityConstraint) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SraffinityConstraint) Read(r io.Reader) (err error) {
	tmpExclAnySize := [1]byte{}
	n_ExclAnySize, err := io.ReadFull(r, tmpExclAnySize[:])
	if err != nil {
		return fmt.Errorf("read ExclAnySize: expect 1 byte but read %d bytes: %w", n_ExclAnySize, err)
	}
	t.ExclAnySize = uint8(tmpExclAnySize[0])
	tmpIncAnySize := [1]byte{}
	n_IncAnySize, err := io.ReadFull(r, tmpIncAnySize[:])
	if err != nil {
		return fmt.Errorf("read IncAnySize: expect 1 byte but read %d bytes: %w", n_IncAnySize, err)
	}
	t.IncAnySize = uint8(tmpIncAnySize[0])
	tmpInclAllSize := [1]byte{}
	n_InclAllSize, err := io.ReadFull(r, tmpInclAllSize[:])
	if err != nil {
		return fmt.Errorf("read InclAllSize: expect 1 byte but read %d bytes: %w", n_InclAllSize, err)
	}
	t.InclAllSize = uint8(tmpInclAllSize[0])
	tmpReserved := [1]byte{}
	n_Reserved, err := io.ReadFull(r, tmpReserved[:])
	if err != nil {
		return fmt.Errorf("read Reserved: expect 1 byte but read %d bytes: %w", n_Reserved, err)
	}
	t.Reserved = uint8(tmpReserved[0])
	len_ExclAny := int(t.ExclAnySize)
	for i_59 := 0; i_59 < len_ExclAny; i_59++ {
		var tmp60_ uint32
		tmpExclAny := [4]byte{}
		n_ExclAny, err := io.ReadFull(r, tmpExclAny[:])
		if err != nil {
			return fmt.Errorf("read ExclAny: expect 4 bytes but read %d bytes: %w", n_ExclAny, err)
		}
		tmp60_ = uint32(binary.BigEndian.Uint32(tmpExclAny[:]))
		t.ExclAny = append(t.ExclAny, tmp60_)
	}
	len_IncAny := int(t.IncAnySize)
	for i_61 := 0; i_61 < len_IncAny; i_61++ {
		var tmp62_ uint32
		tmpIncAny := [4]byte{}
		n_IncAny, err := io.ReadFull(r, tmpIncAny[:])
		if err != nil {
			return fmt.Errorf("read IncAny: expect 4 bytes but read %d bytes: %w", n_IncAny, err)
		}
		tmp62_ = uint32(binary.BigEndian.Uint32(tmpIncAny[:]))
		t.IncAny = append(t.IncAny, tmp62_)
	}
	len_InclAll := int(t.InclAllSize)
	for i_63 := 0; i_63 < len_InclAll; i_63++ {
		var tmp64_ uint32
		tmpInclAll := [4]byte{}
		n_InclAll, err := io.ReadFull(r, tmpInclAll[:])
		if err != nil {
			return fmt.Errorf("read InclAll: expect 4 bytes but read %d bytes: %w", n_InclAll, err)
		}
		tmp64_ = uint32(binary.BigEndian.Uint32(tmpInclAll[:]))
		t.InclAll = append(t.InclAll, tmp64_)
	}
	return nil
}

func (t *SraffinityConstraint) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SraffinityConstraint) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SraffinityConstraint: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Srsrlgconstraint) Visit(v VisitorPRAYV) {
	v.Visit(v, "Srlg", &t.Srlg)
}
func (t *Srsrlgconstraint) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *Srsrlgconstraint) Write(w io.Writer) (err error) {
	for _, v := range t.Srlg {
		tmp65 := [4]byte{}
		binary.BigEndian.PutUint32(tmp65[:], uint32(v))
		if n, err := w.Write(tmp65[:]); err != nil || n != 4 {
			return fmt.Errorf("encode v: %w", err)
		}
	}
	return nil
}
func (t *Srsrlgconstraint) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Srsrlgconstraint) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Srsrlgconstraint) Read(r io.Reader) (err error) {
	tmp_byte_scanner66_ := bufio.NewReaderSize(r, 1)
	old_r_Srlg := r
	r = tmp_byte_scanner66_
	for {
		_, err := tmp_byte_scanner66_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Srlg: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner66_.UnreadByte(); err != nil {
			return fmt.Errorf("read Srlg: unexpected unread error: %w", err)
		}
		var tmp67_ uint32
		tmpSrlg := [4]byte{}
		n_Srlg, err := io.ReadFull(r, tmpSrlg[:])
		if err != nil {
			return fmt.Errorf("read Srlg: expect 4 bytes but read %d bytes: %w", n_Srlg, err)
		}
		tmp67_ = uint32(binary.BigEndian.Uint32(tmpSrlg[:]))
		t.Srlg = append(t.Srlg, tmp67_)
	}
	r = old_r_Srlg
	return nil
}

func (t *Srsrlgconstraint) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Srsrlgconstraint) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Srsrlgconstraint: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SrbandwidthConstraint) Visit(v VisitorPRAYV) {
	v.Visit(v, "Bandwidth", &t.Bandwidth)
}
func (t *SrbandwidthConstraint) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *SrbandwidthConstraint) Write(w io.Writer) (err error) {
	tmp68 := [4]byte{}
	binary.BigEndian.PutUint32(tmp68[:], uint32(t.Bandwidth))
	if n, err := w.Write(tmp68[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Bandwidth: %w", err)
	}
	return nil
}
func (t *SrbandwidthConstraint) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SrbandwidthConstraint) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SrbandwidthConstraint) Read(r io.Reader) (err error) {
	tmpBandwidth := [4]byte{}
	n_Bandwidth, err := io.ReadFull(r, tmpBandwidth[:])
	if err != nil {
		return fmt.Errorf("read Bandwidth: expect 4 bytes but read %d bytes: %w", n_Bandwidth, err)
	}
	t.Bandwidth = uint32(binary.BigEndian.Uint32(tmpBandwidth[:]))
	return nil
}

func (t *SrbandwidthConstraint) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SrbandwidthConstraint) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SrbandwidthConstraint: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SrdisjointGroup) SrlgDisjointnessRequested() bool {
	return ((t.flags69 & 0x80) >> 7) == 1
}
func (t *SrdisjointGroup) SetSrlgDisjointnessRequested(v bool) {
	if v {
		t.flags69 |= uint8(0x80)
	} else {
		t.flags69 &= ^uint8(0x80)
	}
}
func (t *SrdisjointGroup) NodeDisjointnessRequested() bool {
	return ((t.flags69 & 0x40) >> 6) == 1
}
func (t *SrdisjointGroup) SetNodeDisjointnessRequested(v bool) {
	if v {
		t.flags69 |= uint8(0x40)
	} else {
		t.flags69 &= ^uint8(0x40)
	}
}
func (t *SrdisjointGroup) LinkDisjointnessRequested() bool {
	return ((t.flags69 & 0x20) >> 5) == 1
}
func (t *SrdisjointGroup) SetLinkDisjointnessRequested(v bool) {
	if v {
		t.flags69 |= uint8(0x20)
	} else {
		t.flags69 &= ^uint8(0x20)
	}
}
func (t *SrdisjointGroup) FallbackRequested() bool {
	return ((t.flags69 & 0x10) >> 4) == 1
}
func (t *SrdisjointGroup) SetFallbackRequested(v bool) {
	if v {
		t.flags69 |= uint8(0x10)
	} else {
		t.flags69 &= ^uint8(0x10)
	}
}
func (t *SrdisjointGroup) FallbackToDefaultRequested() bool {
	return ((t.flags69 & 0x08) >> 3) == 1
}
func (t *SrdisjointGroup) SetFallbackToDefaultRequested(v bool) {
	if v {
		t.flags69 |= uint8(0x8)
	} else {
		t.flags69 &= ^uint8(0x8)
	}
}
func (t *SrdisjointGroup) Reserved1() uint8 {
	return ((t.flags69 & 0x07) >> 0)
}
func (t *SrdisjointGroup) SetReserved1(v uint8) bool {
	if v > 7 {
		return false
	}
	t.flags69 = (t.flags69 & ^uint8(0x7)) | ((v & 0x7) << 0)
	return true
}
func (t *SrdisjointGroup) SrlgDisjointnessAchieved() bool {
	return ((t.flags70 & 0x80) >> 7) == 1
}
func (t *SrdisjointGroup) SetSrlgDisjointnessAchieved(v bool) {
	if v {
		t.flags70 |= uint8(0x80)
	} else {
		t.flags70 &= ^uint8(0x80)
	}
}
func (t *SrdisjointGroup) NodeDisjointnessAchieved() bool {
	return ((t.flags70 & 0x40) >> 6) == 1
}
func (t *SrdisjointGroup) SetNodeDisjointnessAchieved(v bool) {
	if v {
		t.flags70 |= uint8(0x40)
	} else {
		t.flags70 &= ^uint8(0x40)
	}
}
func (t *SrdisjointGroup) LinkDisjointnessAchieved() bool {
	return ((t.flags70 & 0x20) >> 5) == 1
}
func (t *SrdisjointGroup) SetLinkDisjointnessAchieved(v bool) {
	if v {
		t.flags70 |= uint8(0x20)
	} else {
		t.flags70 &= ^uint8(0x20)
	}
}
func (t *SrdisjointGroup) FallbackAchieved() bool {
	return ((t.flags70 & 0x10) >> 4) == 1
}
func (t *SrdisjointGroup) SetFallbackAchieved(v bool) {
	if v {
		t.flags70 |= uint8(0x10)
	} else {
		t.flags70 &= ^uint8(0x10)
	}
}
func (t *SrdisjointGroup) FallbackToDefaultAchieved() bool {
	return ((t.flags70 & 0x08) >> 3) == 1
}
func (t *SrdisjointGroup) SetFallbackToDefaultAchieved(v bool) {
	if v {
		t.flags70 |= uint8(0x8)
	} else {
		t.flags70 &= ^uint8(0x8)
	}
}
func (t *SrdisjointGroup) CouldNotBeAcheived() bool {
	return ((t.flags70 & 0x04) >> 2) == 1
}
func (t *SrdisjointGroup) SetCouldNotBeAcheived(v bool) {
	if v {
		t.flags70 |= uint8(0x4)
	} else {
		t.flags70 &= ^uint8(0x4)
	}
}
func (t *SrdisjointGroup) Reserved2() uint8 {
	return ((t.flags70 & 0x03) >> 0)
}
func (t *SrdisjointGroup) SetReserved2(v uint8) bool {
	if v > 3 {
		return false
	}
	t.flags70 = (t.flags70 & ^uint8(0x3)) | ((v & 0x3) << 0)
	return true
}
func (t *SrdisjointGroup) Visit(v VisitorPRAYV) {
	v.Visit(v, "SrlgDisjointnessRequested", (func() uint8 {
		if t.SrlgDisjointnessRequested() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "NodeDisjointnessRequested", (func() uint8 {
		if t.NodeDisjointnessRequested() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "LinkDisjointnessRequested", (func() uint8 {
		if t.LinkDisjointnessRequested() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "FallbackRequested", (func() uint8 {
		if t.FallbackRequested() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "FallbackToDefaultRequested", (func() uint8 {
		if t.FallbackToDefaultRequested() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved1", t.Reserved1())
	v.Visit(v, "SrlgDisjointnessAchieved", (func() uint8 {
		if t.SrlgDisjointnessAchieved() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "NodeDisjointnessAchieved", (func() uint8 {
		if t.NodeDisjointnessAchieved() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "LinkDisjointnessAchieved", (func() uint8 {
		if t.LinkDisjointnessAchieved() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "FallbackAchieved", (func() uint8 {
		if t.FallbackAchieved() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "FallbackToDefaultAchieved", (func() uint8 {
		if t.FallbackToDefaultAchieved() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "CouldNotBeAcheived", (func() uint8 {
		if t.CouldNotBeAcheived() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved2", t.Reserved2())
	v.Visit(v, "Reserved3", &t.Reserved3)
	v.Visit(v, "DisjointnessGroupId", &t.DisjointnessGroupId)
}
func (t *SrdisjointGroup) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *SrdisjointGroup) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags69)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags69: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags70)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags70: %w", err)
	}
	tmp71 := [2]byte{}
	binary.BigEndian.PutUint16(tmp71[:], uint16(t.Reserved3))
	if n, err := w.Write(tmp71[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Reserved3: %w", err)
	}
	if n, err := w.Write(t.DisjointnessGroupId); err != nil || n != len(t.DisjointnessGroupId) {
		return fmt.Errorf("encode DisjointnessGroupId: %w", err)
	}
	return nil
}
func (t *SrdisjointGroup) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SrdisjointGroup) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SrdisjointGroup) Read(r io.Reader) (err error) {
	tmpflags69 := [1]byte{}
	n_flags69, err := io.ReadFull(r, tmpflags69[:])
	if err != nil {
		return fmt.Errorf("read flags69: expect 1 byte but read %d bytes: %w", n_flags69, err)
	}
	t.flags69 = uint8(tmpflags69[0])
	tmpflags70 := [1]byte{}
	n_flags70, err := io.ReadFull(r, tmpflags70[:])
	if err != nil {
		return fmt.Errorf("read flags70: expect 1 byte but read %d bytes: %w", n_flags70, err)
	}
	t.flags70 = uint8(tmpflags70[0])
	tmpReserved3 := [2]byte{}
	n_Reserved3, err := io.ReadFull(r, tmpReserved3[:])
	if err != nil {
		return fmt.Errorf("read Reserved3: expect 2 bytes but read %d bytes: %w", n_Reserved3, err)
	}
	t.Reserved3 = uint16(binary.BigEndian.Uint16(tmpReserved3[:]))
	bytes_buf_DisjointnessGroupId := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_DisjointnessGroupId, r); err != nil {
		return err
	}
	t.DisjointnessGroupId = bytes_buf_DisjointnessGroupId.Bytes()
	return nil
}

func (t *SrdisjointGroup) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SrdisjointGroup) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SrdisjointGroup: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SrbidirectionalGroupConstraint) IsReservePath() bool {
	return ((t.flags72 & 0x8000) >> 15) == 1
}
func (t *SrbidirectionalGroupConstraint) SetIsReservePath(v bool) {
	if v {
		t.flags72 |= uint16(0x8000)
	} else {
		t.flags72 &= ^uint16(0x8000)
	}
}
func (t *SrbidirectionalGroupConstraint) CoRouted() bool {
	return ((t.flags72 & 0x4000) >> 14) == 1
}
func (t *SrbidirectionalGroupConstraint) SetCoRouted(v bool) {
	if v {
		t.flags72 |= uint16(0x4000)
	} else {
		t.flags72 &= ^uint16(0x4000)
	}
}
func (t *SrbidirectionalGroupConstraint) Reserved1() uint16 {
	return ((t.flags72 & 0x3fff) >> 0)
}
func (t *SrbidirectionalGroupConstraint) SetReserved1(v uint16) bool {
	if v > 16383 {
		return false
	}
	t.flags72 = (t.flags72 & ^uint16(0x3fff)) | ((v & 0x3fff) << 0)
	return true
}
func (t *SrbidirectionalGroupConstraint) Visit(v VisitorPRAYV) {
	v.Visit(v, "IsReservePath", (func() uint16 {
		if t.IsReservePath() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "CoRouted", (func() uint16 {
		if t.CoRouted() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved1", t.Reserved1())
	v.Visit(v, "Reserved2", &t.Reserved2)
	v.Visit(v, "BidiGroupId", &t.BidiGroupId)
}
func (t *SrbidirectionalGroupConstraint) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *SrbidirectionalGroupConstraint) Write(w io.Writer) (err error) {
	tmp73 := [2]byte{}
	binary.BigEndian.PutUint16(tmp73[:], uint16(t.flags72))
	if n, err := w.Write(tmp73[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.flags72: %w", err)
	}
	tmp74 := [2]byte{}
	binary.BigEndian.PutUint16(tmp74[:], uint16(t.Reserved2))
	if n, err := w.Write(tmp74[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Reserved2: %w", err)
	}
	if n, err := w.Write(t.BidiGroupId); err != nil || n != len(t.BidiGroupId) {
		return fmt.Errorf("encode BidiGroupId: %w", err)
	}
	return nil
}
func (t *SrbidirectionalGroupConstraint) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SrbidirectionalGroupConstraint) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SrbidirectionalGroupConstraint) Read(r io.Reader) (err error) {
	tmpflags72 := [2]byte{}
	n_flags72, err := io.ReadFull(r, tmpflags72[:])
	if err != nil {
		return fmt.Errorf("read flags72: expect 2 bytes but read %d bytes: %w", n_flags72, err)
	}
	t.flags72 = uint16(binary.BigEndian.Uint16(tmpflags72[:]))
	tmpReserved2 := [2]byte{}
	n_Reserved2, err := io.ReadFull(r, tmpReserved2[:])
	if err != nil {
		return fmt.Errorf("read Reserved2: expect 2 bytes but read %d bytes: %w", n_Reserved2, err)
	}
	t.Reserved2 = uint16(binary.BigEndian.Uint16(tmpReserved2[:]))
	bytes_buf_BidiGroupId := &bytes.Buffer{}
	if _, err := io.Copy(bytes_buf_BidiGroupId, r); err != nil {
		return err
	}
	t.BidiGroupId = bytes_buf_BidiGroupId.Bytes()
	return nil
}

func (t *SrbidirectionalGroupConstraint) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SrbidirectionalGroupConstraint) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SrbidirectionalGroupConstraint: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SrmetricConstraint) Optimization() bool {
	return ((t.flags75 & 0x80) >> 7) == 1
}
func (t *SrmetricConstraint) SetOptimization(v bool) {
	if v {
		t.flags75 |= uint8(0x80)
	} else {
		t.flags75 &= ^uint8(0x80)
	}
}
func (t *SrmetricConstraint) MarginAllowed() bool {
	return ((t.flags75 & 0x40) >> 6) == 1
}
func (t *SrmetricConstraint) SetMarginAllowed(v bool) {
	if v {
		t.flags75 |= uint8(0x40)
	} else {
		t.flags75 &= ^uint8(0x40)
	}
}
func (t *SrmetricConstraint) AbsoluteMargin() bool {
	return ((t.flags75 & 0x20) >> 5) == 1
}
func (t *SrmetricConstraint) SetAbsoluteMargin(v bool) {
	if v {
		t.flags75 |= uint8(0x20)
	} else {
		t.flags75 &= ^uint8(0x20)
	}
}
func (t *SrmetricConstraint) BoundAllowed() bool {
	return ((t.flags75 & 0x10) >> 4) == 1
}
func (t *SrmetricConstraint) SetBoundAllowed(v bool) {
	if v {
		t.flags75 |= uint8(0x10)
	} else {
		t.flags75 &= ^uint8(0x10)
	}
}
func (t *SrmetricConstraint) Reserved1() uint8 {
	return ((t.flags75 & 0x0f) >> 0)
}
func (t *SrmetricConstraint) SetReserved1(v uint8) bool {
	if v > 15 {
		return false
	}
	t.flags75 = (t.flags75 & ^uint8(0xf)) | ((v & 0xf) << 0)
	return true
}
func (t *SrmetricConstraint) Visit(v VisitorPRAYV) {
	v.Visit(v, "MetricType", &t.MetricType)
	v.Visit(v, "Optimization", (func() uint8 {
		if t.Optimization() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "MarginAllowed", (func() uint8 {
		if t.MarginAllowed() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "AbsoluteMargin", (func() uint8 {
		if t.AbsoluteMargin() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "BoundAllowed", (func() uint8 {
		if t.BoundAllowed() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved1", t.Reserved1())
	v.Visit(v, "MetricMargin", &t.MetricMargin)
	v.Visit(v, "MetricBound", &t.MetricBound)
}
func (t *SrmetricConstraint) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *SrmetricConstraint) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.MetricType)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.MetricType: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.flags75)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags75: %w", err)
	}
	tmp76 := [4]byte{}
	binary.BigEndian.PutUint32(tmp76[:], uint32(t.MetricMargin))
	if n, err := w.Write(tmp76[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.MetricMargin: %w", err)
	}
	tmp77 := [4]byte{}
	binary.BigEndian.PutUint32(tmp77[:], uint32(t.MetricBound))
	if n, err := w.Write(tmp77[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.MetricBound: %w", err)
	}
	return nil
}
func (t *SrmetricConstraint) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 10))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SrmetricConstraint) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SrmetricConstraint) Read(r io.Reader) (err error) {
	tmpMetricType := [1]byte{}
	n_MetricType, err := io.ReadFull(r, tmpMetricType[:])
	if err != nil {
		return fmt.Errorf("read MetricType: expect 1 byte but read %d bytes: %w", n_MetricType, err)
	}
	t.MetricType = uint8(tmpMetricType[0])
	tmpflags75 := [1]byte{}
	n_flags75, err := io.ReadFull(r, tmpflags75[:])
	if err != nil {
		return fmt.Errorf("read flags75: expect 1 byte but read %d bytes: %w", n_flags75, err)
	}
	t.flags75 = uint8(tmpflags75[0])
	tmpMetricMargin := [4]byte{}
	n_MetricMargin, err := io.ReadFull(r, tmpMetricMargin[:])
	if err != nil {
		return fmt.Errorf("read MetricMargin: expect 4 bytes but read %d bytes: %w", n_MetricMargin, err)
	}
	t.MetricMargin = uint32(binary.BigEndian.Uint32(tmpMetricMargin[:]))
	tmpMetricBound := [4]byte{}
	n_MetricBound, err := io.ReadFull(r, tmpMetricBound[:])
	if err != nil {
		return fmt.Errorf("read MetricBound: expect 4 bytes but read %d bytes: %w", n_MetricBound, err)
	}
	t.MetricBound = uint32(binary.BigEndian.Uint32(tmpMetricBound[:]))
	return nil
}

func (t *SrmetricConstraint) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SrmetricConstraint) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SrmetricConstraint: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Open) Visit(v VisitorPRAYV) {
	v.Visit(v, "Version", &t.Version)
	v.Visit(v, "As", &t.As)
	v.Visit(v, "Hold", &t.Hold)
	v.Visit(v, "Id", &t.Id)
	v.Visit(v, "Optlen", &t.Optlen)
	v.Visit(v, "Options", &t.Options)
}
func (t *Open) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *Open) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.Version)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Version: %w", err)
	}
	tmp78 := [2]byte{}
	binary.BigEndian.PutUint16(tmp78[:], uint16(t.As))
	if n, err := w.Write(tmp78[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.As: %w", err)
	}
	tmp79 := [2]byte{}
	binary.BigEndian.PutUint16(tmp79[:], uint16(t.Hold))
	if n, err := w.Write(tmp79[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Hold: %w", err)
	}
	tmp80 := [4]byte{}
	binary.BigEndian.PutUint32(tmp80[:], uint32(t.Id))
	if n, err := w.Write(tmp80[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.Id: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Optlen)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Optlen: %w", err)
	}
	new_buf_81 := bytes.NewBuffer(nil)
	old_buf_81_w := w
	w = new_buf_81
	for _, v := range t.Options {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Options: %w", err)
		}
	}
	if new_buf_81.Len() != int(t.Optlen) {
		return fmt.Errorf("encode Options: expect %d bytes but got %d bytes", new_buf_81.Len(), int(t.Optlen))
	}
	_, err = new_buf_81.WriteTo(old_buf_81_w)
	if err != nil {
		return err
	}
	w = old_buf_81_w
	return nil
}
func (t *Open) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 10))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Open) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Open) Read(r io.Reader) (err error) {
	tmpVersion := [1]byte{}
	n_Version, err := io.ReadFull(r, tmpVersion[:])
	if err != nil {
		return fmt.Errorf("read Version: expect 1 byte but read %d bytes: %w", n_Version, err)
	}
	t.Version = uint8(tmpVersion[0])
	tmpAs := [2]byte{}
	n_As, err := io.ReadFull(r, tmpAs[:])
	if err != nil {
		return fmt.Errorf("read As: expect 2 bytes but read %d bytes: %w", n_As, err)
	}
	t.As = uint16(binary.BigEndian.Uint16(tmpAs[:]))
	tmpHold := [2]byte{}
	n_Hold, err := io.ReadFull(r, tmpHold[:])
	if err != nil {
		return fmt.Errorf("read Hold: expect 2 bytes but read %d bytes: %w", n_Hold, err)
	}
	t.Hold = uint16(binary.BigEndian.Uint16(tmpHold[:]))
	tmpId := [4]byte{}
	n_Id, err := io.ReadFull(r, tmpId[:])
	if err != nil {
		return fmt.Errorf("read Id: expect 4 bytes but read %d bytes: %w", n_Id, err)
	}
	t.Id = uint32(binary.BigEndian.Uint32(tmpId[:]))
	tmpOptlen := [1]byte{}
	n_Optlen, err := io.ReadFull(r, tmpOptlen[:])
	if err != nil {
		return fmt.Errorf("read Optlen: expect 1 byte but read %d bytes: %w", n_Optlen, err)
	}
	t.Optlen = uint8(tmpOptlen[0])
	sub_byte_len_Options := int64(t.Optlen)
	sub_byte_r_Options := io.LimitReader(r, int64(sub_byte_len_Options))
	tmp_old_r_Options_82 := r
	r = sub_byte_r_Options
	len_Options := int(r.(*io.LimitedReader).N)
	tmpOptions := make([]byte, len_Options)
	n_Options, err := io.ReadFull(r, tmpOptions[:])
	if err != nil {
		return fmt.Errorf("read Options: expect %d bytes but read %d bytes: %w", len_Options, n_Options, err)
	}
	range_tmp_Options := bytes.NewReader(tmpOptions[:])
	tmp_old_r_Options := r
	r = range_tmp_Options
	for range_tmp_Options.Len() > 0 {
		var tmp83_ Bgpoption
		if err := tmp83_.Read(r); err != nil {
			return fmt.Errorf("read Options: %w", err)
		}
		t.Options = append(t.Options, tmp83_)
	}
	r = tmp_old_r_Options
	if sub_byte_r_Options.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Options: expect %d bytes but got %d bytes", sub_byte_len_Options, sub_byte_len_Options-sub_byte_r_Options.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Options_82
	return nil
}

func (t *Open) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Open) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Open: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *WithdrawnRoutes) Visit(v VisitorPRAYV) {
	v.Visit(v, "Len", &t.Len)
	v.Visit(v, "Data", &t.Data)
}
func (t *WithdrawnRoutes) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *WithdrawnRoutes) Write(w io.Writer) (err error) {
	tmp84 := [2]byte{}
	binary.BigEndian.PutUint16(tmp84[:], uint16(t.Len))
	if n, err := w.Write(tmp84[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Len: %w", err)
	}
	new_buf_85 := bytes.NewBuffer(nil)
	old_buf_85_w := w
	w = new_buf_85
	for _, v := range t.Data {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	if new_buf_85.Len() != int(t.Len) {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", new_buf_85.Len(), int(t.Len))
	}
	_, err = new_buf_85.WriteTo(old_buf_85_w)
	if err != nil {
		return err
	}
	w = old_buf_85_w
	return nil
}
func (t *WithdrawnRoutes) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *WithdrawnRoutes) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *WithdrawnRoutes) Read(r io.Reader) (err error) {
	tmpLen := [2]byte{}
	n_Len, err := io.ReadFull(r, tmpLen[:])
	if err != nil {
		return fmt.Errorf("read Len: expect 2 bytes but read %d bytes: %w", n_Len, err)
	}
	t.Len = uint16(binary.BigEndian.Uint16(tmpLen[:]))
	sub_byte_len_Data := int64(t.Len)
	sub_byte_r_Data := io.LimitReader(r, int64(sub_byte_len_Data))
	tmp_old_r_Data_86 := r
	r = sub_byte_r_Data
	len_Data := int(r.(*io.LimitedReader).N)
	tmpData := make([]byte, len_Data)
	n_Data, err := io.ReadFull(r, tmpData[:])
	if err != nil {
		return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
	}
	range_tmp_Data := bytes.NewReader(tmpData[:])
	tmp_old_r_Data := r
	r = range_tmp_Data
	for range_tmp_Data.Len() > 0 {
		var tmp87_ WithdrawnRoute
		if err := tmp87_.Read(r); err != nil {
			return fmt.Errorf("read Data: %w", err)
		}
		t.Data = append(t.Data, tmp87_)
	}
	r = tmp_old_r_Data
	if sub_byte_r_Data.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Data: expect %d bytes but got %d bytes", sub_byte_len_Data, sub_byte_len_Data-sub_byte_r_Data.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Data_86
	return nil
}

func (t *WithdrawnRoutes) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *WithdrawnRoutes) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode WithdrawnRoutes: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *AsPath) Visit(v VisitorPRAYV) {
	v.Visit(v, "Segments", &t.Segments)
}
func (t *AsPath) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *AsPath) Write(w io.Writer) (err error) {
	for _, v := range t.Segments {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Segments: %w", err)
		}
	}
	return nil
}
func (t *AsPath) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *AsPath) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *AsPath) Read(r io.Reader) (err error) {
	tmp_byte_scanner88_ := bufio.NewReaderSize(r, 1)
	old_r_Segments := r
	r = tmp_byte_scanner88_
	for {
		_, err := tmp_byte_scanner88_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Segments: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner88_.UnreadByte(); err != nil {
			return fmt.Errorf("read Segments: unexpected unread error: %w", err)
		}
		var tmp89_ AsPathSegment
		if err := tmp89_.Read(r); err != nil {
			return fmt.Errorf("read Segments: %w", err)
		}
		t.Segments = append(t.Segments, tmp89_)
	}
	r = old_r_Segments
	return nil
}

func (t *AsPath) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *AsPath) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode AsPath: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NodeDescriptors) Visit(v VisitorPRAYV) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Descriptor", &t.Descriptor)
}
func (t *NodeDescriptors) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *NodeDescriptors) Write(w io.Writer) (err error) {
	tmp90 := [2]byte{}
	binary.BigEndian.PutUint16(tmp90[:], uint16(t.Type))
	if n, err := w.Write(tmp90[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	tmp91 := [2]byte{}
	binary.BigEndian.PutUint16(tmp91[:], uint16(t.Length))
	if n, err := w.Write(tmp91[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	new_buf_92 := bytes.NewBuffer(nil)
	old_buf_92_w := w
	w = new_buf_92
	for _, v := range t.Descriptor {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Descriptor: %w", err)
		}
	}
	if new_buf_92.Len() != int(t.Length) {
		return fmt.Errorf("encode Descriptor: expect %d bytes but got %d bytes", new_buf_92.Len(), int(t.Length))
	}
	_, err = new_buf_92.WriteTo(old_buf_92_w)
	if err != nil {
		return err
	}
	w = old_buf_92_w
	return nil
}
func (t *NodeDescriptors) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NodeDescriptors) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NodeDescriptors) Read(r io.Reader) (err error) {
	tmpType := [2]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 2 bytes but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint16(binary.BigEndian.Uint16(tmpType[:]))
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	sub_byte_len_Descriptor := int64(t.Length)
	sub_byte_r_Descriptor := io.LimitReader(r, int64(sub_byte_len_Descriptor))
	tmp_old_r_Descriptor_93 := r
	r = sub_byte_r_Descriptor
	len_Descriptor := int(r.(*io.LimitedReader).N)
	tmpDescriptor := make([]byte, len_Descriptor)
	n_Descriptor, err := io.ReadFull(r, tmpDescriptor[:])
	if err != nil {
		return fmt.Errorf("read Descriptor: expect %d bytes but read %d bytes: %w", len_Descriptor, n_Descriptor, err)
	}
	range_tmp_Descriptor := bytes.NewReader(tmpDescriptor[:])
	tmp_old_r_Descriptor := r
	r = range_tmp_Descriptor
	for range_tmp_Descriptor.Len() > 0 {
		var tmp94_ NodeDescriptorSubTlv
		if err := tmp94_.Read(r); err != nil {
			return fmt.Errorf("read Descriptor: %w", err)
		}
		t.Descriptor = append(t.Descriptor, tmp94_)
	}
	r = tmp_old_r_Descriptor
	if sub_byte_r_Descriptor.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Descriptor: expect %d bytes but got %d bytes", sub_byte_len_Descriptor, sub_byte_len_Descriptor-sub_byte_r_Descriptor.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Descriptor_93
	return nil
}

func (t *NodeDescriptors) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NodeDescriptors) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NodeDescriptors: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *NodeNlri) Visit(v VisitorPRAYV) {
	v.Visit(v, "ProtocolId", &t.ProtocolId)
	v.Visit(v, "Identifier", &t.Identifier)
	v.Visit(v, "LocalNodeDescriptors", &t.LocalNodeDescriptors)
}
func (t *NodeNlri) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *NodeNlri) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.ProtocolId)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.ProtocolId: %w", err)
	}
	tmp95 := [8]byte{}
	binary.BigEndian.PutUint64(tmp95[:], uint64(t.Identifier))
	if n, err := w.Write(tmp95[:]); err != nil || n != 8 {
		return fmt.Errorf("encode t.Identifier: %w", err)
	}
	if err := t.LocalNodeDescriptors.Write(w); err != nil {
		return fmt.Errorf("encode LocalNodeDescriptors: %w", err)
	}
	return nil
}
func (t *NodeNlri) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 9))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *NodeNlri) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *NodeNlri) Read(r io.Reader) (err error) {
	tmpProtocolId := [1]byte{}
	n_ProtocolId, err := io.ReadFull(r, tmpProtocolId[:])
	if err != nil {
		return fmt.Errorf("read ProtocolId: expect 1 byte but read %d bytes: %w", n_ProtocolId, err)
	}
	t.ProtocolId = uint8(tmpProtocolId[0])
	tmpIdentifier := [8]byte{}
	n_Identifier, err := io.ReadFull(r, tmpIdentifier[:])
	if err != nil {
		return fmt.Errorf("read Identifier: expect 8 bytes but read %d bytes: %w", n_Identifier, err)
	}
	t.Identifier = uint64(binary.BigEndian.Uint64(tmpIdentifier[:]))
	if err := t.LocalNodeDescriptors.Read(r); err != nil {
		return fmt.Errorf("read LocalNodeDescriptors: %w", err)
	}
	return nil
}

func (t *NodeNlri) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *NodeNlri) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode NodeNlri: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *LinkDescriptors) Visit(v VisitorPRAYV) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Descriptor", &t.Descriptor)
}
func (t *LinkDescriptors) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *LinkDescriptors) Write(w io.Writer) (err error) {
	tmp96 := [2]byte{}
	binary.BigEndian.PutUint16(tmp96[:], uint16(t.Type))
	if n, err := w.Write(tmp96[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	tmp97 := [2]byte{}
	binary.BigEndian.PutUint16(tmp97[:], uint16(t.Length))
	if n, err := w.Write(tmp97[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	new_buf_98 := bytes.NewBuffer(nil)
	old_buf_98_w := w
	w = new_buf_98
	for _, v := range t.Descriptor {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Descriptor: %w", err)
		}
	}
	if new_buf_98.Len() != int(t.Length) {
		return fmt.Errorf("encode Descriptor: expect %d bytes but got %d bytes", new_buf_98.Len(), int(t.Length))
	}
	_, err = new_buf_98.WriteTo(old_buf_98_w)
	if err != nil {
		return err
	}
	w = old_buf_98_w
	return nil
}
func (t *LinkDescriptors) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *LinkDescriptors) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *LinkDescriptors) Read(r io.Reader) (err error) {
	tmpType := [2]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 2 bytes but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint16(binary.BigEndian.Uint16(tmpType[:]))
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	sub_byte_len_Descriptor := int64(t.Length)
	sub_byte_r_Descriptor := io.LimitReader(r, int64(sub_byte_len_Descriptor))
	tmp_old_r_Descriptor_99 := r
	r = sub_byte_r_Descriptor
	len_Descriptor := int(r.(*io.LimitedReader).N)
	tmpDescriptor := make([]byte, len_Descriptor)
	n_Descriptor, err := io.ReadFull(r, tmpDescriptor[:])
	if err != nil {
		return fmt.Errorf("read Descriptor: expect %d bytes but read %d bytes: %w", len_Descriptor, n_Descriptor, err)
	}
	range_tmp_Descriptor := bytes.NewReader(tmpDescriptor[:])
	tmp_old_r_Descriptor := r
	r = range_tmp_Descriptor
	for range_tmp_Descriptor.Len() > 0 {
		var tmp100_ LinkDescriptorSubTlv
		if err := tmp100_.Read(r); err != nil {
			return fmt.Errorf("read Descriptor: %w", err)
		}
		t.Descriptor = append(t.Descriptor, tmp100_)
	}
	r = tmp_old_r_Descriptor
	if sub_byte_r_Descriptor.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Descriptor: expect %d bytes but got %d bytes", sub_byte_len_Descriptor, sub_byte_len_Descriptor-sub_byte_r_Descriptor.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Descriptor_99
	return nil
}

func (t *LinkDescriptors) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *LinkDescriptors) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode LinkDescriptors: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *LinkNlri) Visit(v VisitorPRAYV) {
	v.Visit(v, "LinkLocalId", &t.LinkLocalId)
	v.Visit(v, "LocalNodeDescriptors", &t.LocalNodeDescriptors)
	v.Visit(v, "RemoteNodeDescriptors", &t.RemoteNodeDescriptors)
	v.Visit(v, "LinkDescriptors", &t.LinkDescriptors)
}
func (t *LinkNlri) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *LinkNlri) Write(w io.Writer) (err error) {
	tmp101 := [4]byte{}
	binary.BigEndian.PutUint32(tmp101[:], uint32(t.LinkLocalId))
	if n, err := w.Write(tmp101[:]); err != nil || n != 4 {
		return fmt.Errorf("encode t.LinkLocalId: %w", err)
	}
	if err := t.LocalNodeDescriptors.Write(w); err != nil {
		return fmt.Errorf("encode LocalNodeDescriptors: %w", err)
	}
	if err := t.RemoteNodeDescriptors.Write(w); err != nil {
		return fmt.Errorf("encode RemoteNodeDescriptors: %w", err)
	}
	if err := t.LinkDescriptors.Write(w); err != nil {
		return fmt.Errorf("encode LinkDescriptors: %w", err)
	}
	return nil
}
func (t *LinkNlri) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *LinkNlri) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *LinkNlri) Read(r io.Reader) (err error) {
	tmpLinkLocalId := [4]byte{}
	n_LinkLocalId, err := io.ReadFull(r, tmpLinkLocalId[:])
	if err != nil {
		return fmt.Errorf("read LinkLocalId: expect 4 bytes but read %d bytes: %w", n_LinkLocalId, err)
	}
	t.LinkLocalId = uint32(binary.BigEndian.Uint32(tmpLinkLocalId[:]))
	if err := t.LocalNodeDescriptors.Read(r); err != nil {
		return fmt.Errorf("read LocalNodeDescriptors: %w", err)
	}
	if err := t.RemoteNodeDescriptors.Read(r); err != nil {
		return fmt.Errorf("read RemoteNodeDescriptors: %w", err)
	}
	if err := t.LinkDescriptors.Read(r); err != nil {
		return fmt.Errorf("read LinkDescriptors: %w", err)
	}
	return nil
}

func (t *LinkNlri) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *LinkNlri) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode LinkNlri: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *MultiTopologyIdlist) Visit(v VisitorPRAYV) {
	v.Visit(v, "MtIds", &t.MtIds)
}
func (t *MultiTopologyIdlist) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *MultiTopologyIdlist) Write(w io.Writer) (err error) {
	for _, v := range t.MtIds {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode MtIds: %w", err)
		}
	}
	return nil
}
func (t *MultiTopologyIdlist) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *MultiTopologyIdlist) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *MultiTopologyIdlist) Read(r io.Reader) (err error) {
	tmp_byte_scanner102_ := bufio.NewReaderSize(r, 1)
	old_r_MtIds := r
	r = tmp_byte_scanner102_
	for {
		_, err := tmp_byte_scanner102_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read MtIds: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner102_.UnreadByte(); err != nil {
			return fmt.Errorf("read MtIds: unexpected unread error: %w", err)
		}
		var tmp103_ MultiTopologyId
		if err := tmp103_.Read(r); err != nil {
			return fmt.Errorf("read MtIds: %w", err)
		}
		t.MtIds = append(t.MtIds, tmp103_)
	}
	r = old_r_MtIds
	return nil
}

func (t *MultiTopologyIdlist) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *MultiTopologyIdlist) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode MultiTopologyIdlist: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_106_t) isunion104_() {}
func (t *union_107_t) isunion104_() {}
func (t *union_108_t) isunion104_() {}
func (t *union_109_t) isunion104_() {}
func (t *PrefixDescriptorSubTlv) Data() *[]uint8 {
	if t.Type == SubTlvtype_MultiTopologyId {
		return nil
	} else if t.Type == SubTlvtype_OspfrouteType {
		return nil
	} else if t.Type == SubTlvtype_IpreachabilityInformation {
		return nil
	} else if true {
		if _, ok := t.union104_.(*union_109_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union104_.(*union_109_t).Data)
		return &tmp
	}
	return nil
}
func (t *PrefixDescriptorSubTlv) SetData(v []uint8) bool {
	if t.Type == SubTlvtype_MultiTopologyId {
		return false
	} else if t.Type == SubTlvtype_OspfrouteType {
		return false
	} else if t.Type == SubTlvtype_IpreachabilityInformation {
		return false
	} else if true {
		if len(v) > int(^uint16(0)) {
			return false
		}
		if _, ok := t.union104_.(*union_109_t); !ok {
			t.union104_ = &union_109_t{}
		}
		t.Length = uint16(len(v))
		t.union104_.(*union_109_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *PrefixDescriptorSubTlv) IpReachabilityInformation() *IpreachabilityInformation {
	if t.Type == SubTlvtype_MultiTopologyId {
		return nil
	} else if t.Type == SubTlvtype_OspfrouteType {
		return nil
	} else if t.Type == SubTlvtype_IpreachabilityInformation {
		if _, ok := t.union104_.(*union_108_t); !ok {
			return nil // not set
		}
		tmp := IpreachabilityInformation(t.union104_.(*union_108_t).IpReachabilityInformation)
		return &tmp
	}
	return nil
}
func (t *PrefixDescriptorSubTlv) SetIpReachabilityInformation(v IpreachabilityInformation) bool {
	if t.Type == SubTlvtype_MultiTopologyId {
		return false
	} else if t.Type == SubTlvtype_OspfrouteType {
		return false
	} else if t.Type == SubTlvtype_IpreachabilityInformation {
		if _, ok := t.union104_.(*union_108_t); !ok {
			t.union104_ = &union_108_t{}
		}
		t.union104_.(*union_108_t).IpReachabilityInformation = IpreachabilityInformation(v)
		return true
	}
	return false
}
func (t *PrefixDescriptorSubTlv) MultiTopologyIdentifier() *MultiTopologyIdlist {
	if t.Type == SubTlvtype_MultiTopologyId {
		if _, ok := t.union104_.(*union_106_t); !ok {
			return nil // not set
		}
		tmp := MultiTopologyIdlist(t.union104_.(*union_106_t).MultiTopologyIdentifier)
		return &tmp
	}
	return nil
}
func (t *PrefixDescriptorSubTlv) SetMultiTopologyIdentifier(v MultiTopologyIdlist) bool {
	if t.Type == SubTlvtype_MultiTopologyId {
		if _, ok := t.union104_.(*union_106_t); !ok {
			t.union104_ = &union_106_t{}
		}
		t.union104_.(*union_106_t).MultiTopologyIdentifier = MultiTopologyIdlist(v)
		return true
	}
	return false
}
func (t *PrefixDescriptorSubTlv) OspfRouteType() *OspfrouteType {
	if t.Type == SubTlvtype_MultiTopologyId {
		return nil
	} else if t.Type == SubTlvtype_OspfrouteType {
		if _, ok := t.union104_.(*union_107_t); !ok {
			return nil // not set
		}
		tmp := OspfrouteType(t.union104_.(*union_107_t).OspfRouteType)
		return &tmp
	}
	return nil
}
func (t *PrefixDescriptorSubTlv) SetOspfRouteType(v OspfrouteType) bool {
	if t.Type == SubTlvtype_MultiTopologyId {
		return false
	} else if t.Type == SubTlvtype_OspfrouteType {
		if _, ok := t.union104_.(*union_107_t); !ok {
			t.union104_ = &union_107_t{}
		}
		t.union104_.(*union_107_t).OspfRouteType = OspfrouteType(v)
		return true
	}
	return false
}
func (t *PrefixDescriptorSubTlv) Visit(v VisitorPRAYV) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "IpReachabilityInformation", (t.IpReachabilityInformation()))
	v.Visit(v, "MultiTopologyIdentifier", (t.MultiTopologyIdentifier()))
	v.Visit(v, "OspfRouteType", (t.OspfRouteType()))
}
func (t *PrefixDescriptorSubTlv) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *PrefixDescriptorSubTlv) Write(w io.Writer) (err error) {
	tmp110 := [2]byte{}
	binary.BigEndian.PutUint16(tmp110[:], uint16(t.Type))
	if n, err := w.Write(tmp110[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	tmp111 := [2]byte{}
	binary.BigEndian.PutUint16(tmp111[:], uint16(t.Length))
	if n, err := w.Write(tmp111[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	switch {
	case (t.Type == SubTlvtype_MultiTopologyId):
		if _, ok := t.union104_.(*union_106_t); !ok {
			return fmt.Errorf("encode t.union104_: union is not set to union_106_t")
		}
		new_buf_112 := bytes.NewBuffer(nil)
		old_buf_112_w := w
		w = new_buf_112
		if err := t.union104_.(*union_106_t).MultiTopologyIdentifier.Write(w); err != nil {
			return fmt.Errorf("encode MultiTopologyIdentifier: %w", err)
		}
		if new_buf_112.Len() != int(t.Length) {
			return fmt.Errorf("encode MultiTopologyIdentifier: expect %d bytes but got %d bytes", new_buf_112.Len(), int(t.Length))
		}
		_, err = new_buf_112.WriteTo(old_buf_112_w)
		if err != nil {
			return err
		}
		w = old_buf_112_w
	case (t.Type == SubTlvtype_OspfrouteType):
		if _, ok := t.union104_.(*union_107_t); !ok {
			return fmt.Errorf("encode t.union104_: union is not set to union_107_t")
		}
		new_buf_113 := bytes.NewBuffer(nil)
		old_buf_113_w := w
		w = new_buf_113
		if n, err := w.Write([]byte{byte(t.union104_.(*union_107_t).OspfRouteType)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union104_.(*union_107_t).OspfRouteType: %w", err)
		}
		if new_buf_113.Len() != int(t.Length) {
			return fmt.Errorf("encode OspfRouteType: expect %d bytes but got %d bytes", new_buf_113.Len(), int(t.Length))
		}
		_, err = new_buf_113.WriteTo(old_buf_113_w)
		if err != nil {
			return err
		}
		w = old_buf_113_w
	case (t.Type == SubTlvtype_IpreachabilityInformation):
		if _, ok := t.union104_.(*union_108_t); !ok {
			return fmt.Errorf("encode t.union104_: union is not set to union_108_t")
		}
		new_buf_114 := bytes.NewBuffer(nil)
		old_buf_114_w := w
		w = new_buf_114
		if err := t.union104_.(*union_108_t).IpReachabilityInformation.Write(w); err != nil {
			return fmt.Errorf("encode IpReachabilityInformation: %w", err)
		}
		if new_buf_114.Len() != int(t.Length) {
			return fmt.Errorf("encode IpReachabilityInformation: expect %d bytes but got %d bytes", new_buf_114.Len(), int(t.Length))
		}
		_, err = new_buf_114.WriteTo(old_buf_114_w)
		if err != nil {
			return err
		}
		w = old_buf_114_w
	default:
		if _, ok := t.union104_.(*union_109_t); !ok {
			return fmt.Errorf("encode t.union104_: union is not set to union_109_t")
		}
		len_Data := int(t.Length)
		if len(t.union104_.(*union_109_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union104_.(*union_109_t).Data))
		}
		if n, err := w.Write(t.union104_.(*union_109_t).Data); err != nil || n != len(t.union104_.(*union_109_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *PrefixDescriptorSubTlv) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *PrefixDescriptorSubTlv) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *PrefixDescriptorSubTlv) Read(r io.Reader) (err error) {
	tmpType := [2]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 2 bytes but read %d bytes: %w", n_Type, err)
	}
	t.Type = SubTlvtype(binary.BigEndian.Uint16(tmpType[:]))
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	switch {
	case (t.Type == SubTlvtype_MultiTopologyId):
		t.union104_ = &union_106_t{}
		sub_byte_len_MultiTopologyIdentifier := int64(t.Length)
		sub_byte_r_MultiTopologyIdentifier := io.LimitReader(r, int64(sub_byte_len_MultiTopologyIdentifier))
		tmp_old_r_MultiTopologyIdentifier_115 := r
		r = sub_byte_r_MultiTopologyIdentifier
		if err := t.union104_.(*union_106_t).MultiTopologyIdentifier.Read(r); err != nil {
			return fmt.Errorf("read MultiTopologyIdentifier: %w", err)
		}
		if sub_byte_r_MultiTopologyIdentifier.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read MultiTopologyIdentifier: expect %d bytes but got %d bytes", sub_byte_len_MultiTopologyIdentifier, sub_byte_len_MultiTopologyIdentifier-sub_byte_r_MultiTopologyIdentifier.(*io.LimitedReader).N)
		}
		r = tmp_old_r_MultiTopologyIdentifier_115
	case (t.Type == SubTlvtype_OspfrouteType):
		t.union104_ = &union_107_t{}
		sub_byte_len_OspfRouteType := int64(t.Length)
		sub_byte_r_OspfRouteType := io.LimitReader(r, int64(sub_byte_len_OspfRouteType))
		tmp_old_r_OspfRouteType_116 := r
		r = sub_byte_r_OspfRouteType
		tmpOspfRouteType := [1]byte{}
		n_OspfRouteType, err := io.ReadFull(r, tmpOspfRouteType[:])
		if err != nil {
			return fmt.Errorf("read OspfRouteType: expect 1 byte but read %d bytes: %w", n_OspfRouteType, err)
		}
		t.union104_.(*union_107_t).OspfRouteType = OspfrouteType(tmpOspfRouteType[0])
		if sub_byte_r_OspfRouteType.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read OspfRouteType: expect %d bytes but got %d bytes", sub_byte_len_OspfRouteType, sub_byte_len_OspfRouteType-sub_byte_r_OspfRouteType.(*io.LimitedReader).N)
		}
		r = tmp_old_r_OspfRouteType_116
	case (t.Type == SubTlvtype_IpreachabilityInformation):
		t.union104_ = &union_108_t{}
		sub_byte_len_IpReachabilityInformation := int64(t.Length)
		sub_byte_r_IpReachabilityInformation := io.LimitReader(r, int64(sub_byte_len_IpReachabilityInformation))
		tmp_old_r_IpReachabilityInformation_117 := r
		r = sub_byte_r_IpReachabilityInformation
		if err := t.union104_.(*union_108_t).IpReachabilityInformation.Read(r); err != nil {
			return fmt.Errorf("read IpReachabilityInformation: %w", err)
		}
		if sub_byte_r_IpReachabilityInformation.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read IpReachabilityInformation: expect %d bytes but got %d bytes", sub_byte_len_IpReachabilityInformation, sub_byte_len_IpReachabilityInformation-sub_byte_r_IpReachabilityInformation.(*io.LimitedReader).N)
		}
		r = tmp_old_r_IpReachabilityInformation_117
	default:
		t.union104_ = &union_109_t{}
		len_Data := int(t.Length)
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union104_.(*union_109_t).Data = tmpData[:]
		} else {
			t.union104_.(*union_109_t).Data = nil
		}
	}
	return nil
}

func (t *PrefixDescriptorSubTlv) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *PrefixDescriptorSubTlv) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode PrefixDescriptorSubTlv: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *PrefixDescriptors) Visit(v VisitorPRAYV) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Length", &t.Length)
	v.Visit(v, "Descriptor", &t.Descriptor)
}
func (t *PrefixDescriptors) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *PrefixDescriptors) Write(w io.Writer) (err error) {
	tmp118 := [2]byte{}
	binary.BigEndian.PutUint16(tmp118[:], uint16(t.Type))
	if n, err := w.Write(tmp118[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Type: %w", err)
	}
	tmp119 := [2]byte{}
	binary.BigEndian.PutUint16(tmp119[:], uint16(t.Length))
	if n, err := w.Write(tmp119[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Length: %w", err)
	}
	new_buf_120 := bytes.NewBuffer(nil)
	old_buf_120_w := w
	w = new_buf_120
	for _, v := range t.Descriptor {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Descriptor: %w", err)
		}
	}
	if new_buf_120.Len() != int(t.Length) {
		return fmt.Errorf("encode Descriptor: expect %d bytes but got %d bytes", new_buf_120.Len(), int(t.Length))
	}
	_, err = new_buf_120.WriteTo(old_buf_120_w)
	if err != nil {
		return err
	}
	w = old_buf_120_w
	return nil
}
func (t *PrefixDescriptors) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *PrefixDescriptors) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *PrefixDescriptors) Read(r io.Reader) (err error) {
	tmpType := [2]byte{}
	n_Type, err := io.ReadFull(r, tmpType[:])
	if err != nil {
		return fmt.Errorf("read Type: expect 2 bytes but read %d bytes: %w", n_Type, err)
	}
	t.Type = uint16(binary.BigEndian.Uint16(tmpType[:]))
	tmpLength := [2]byte{}
	n_Length, err := io.ReadFull(r, tmpLength[:])
	if err != nil {
		return fmt.Errorf("read Length: expect 2 bytes but read %d bytes: %w", n_Length, err)
	}
	t.Length = uint16(binary.BigEndian.Uint16(tmpLength[:]))
	sub_byte_len_Descriptor := int64(t.Length)
	sub_byte_r_Descriptor := io.LimitReader(r, int64(sub_byte_len_Descriptor))
	tmp_old_r_Descriptor_121 := r
	r = sub_byte_r_Descriptor
	len_Descriptor := int(r.(*io.LimitedReader).N)
	tmpDescriptor := make([]byte, len_Descriptor)
	n_Descriptor, err := io.ReadFull(r, tmpDescriptor[:])
	if err != nil {
		return fmt.Errorf("read Descriptor: expect %d bytes but read %d bytes: %w", len_Descriptor, n_Descriptor, err)
	}
	range_tmp_Descriptor := bytes.NewReader(tmpDescriptor[:])
	tmp_old_r_Descriptor := r
	r = range_tmp_Descriptor
	for range_tmp_Descriptor.Len() > 0 {
		var tmp122_ PrefixDescriptorSubTlv
		if err := tmp122_.Read(r); err != nil {
			return fmt.Errorf("read Descriptor: %w", err)
		}
		t.Descriptor = append(t.Descriptor, tmp122_)
	}
	r = tmp_old_r_Descriptor
	if sub_byte_r_Descriptor.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Descriptor: expect %d bytes but got %d bytes", sub_byte_len_Descriptor, sub_byte_len_Descriptor-sub_byte_r_Descriptor.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Descriptor_121
	return nil
}

func (t *PrefixDescriptors) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *PrefixDescriptors) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode PrefixDescriptors: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *PrefixNlri) Visit(v VisitorPRAYV) {
	v.Visit(v, "ProtocolId", &t.ProtocolId)
	v.Visit(v, "Identifier", &t.Identifier)
	v.Visit(v, "LocalNodeDescriptors", &t.LocalNodeDescriptors)
	v.Visit(v, "PrefixDescriptors", &t.PrefixDescriptors)
}
func (t *PrefixNlri) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *PrefixNlri) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.ProtocolId)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.ProtocolId: %w", err)
	}
	tmp123 := [8]byte{}
	binary.BigEndian.PutUint64(tmp123[:], uint64(t.Identifier))
	if n, err := w.Write(tmp123[:]); err != nil || n != 8 {
		return fmt.Errorf("encode t.Identifier: %w", err)
	}
	if err := t.LocalNodeDescriptors.Write(w); err != nil {
		return fmt.Errorf("encode LocalNodeDescriptors: %w", err)
	}
	if err := t.PrefixDescriptors.Write(w); err != nil {
		return fmt.Errorf("encode PrefixDescriptors: %w", err)
	}
	return nil
}
func (t *PrefixNlri) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 9))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *PrefixNlri) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *PrefixNlri) Read(r io.Reader) (err error) {
	tmpProtocolId := [1]byte{}
	n_ProtocolId, err := io.ReadFull(r, tmpProtocolId[:])
	if err != nil {
		return fmt.Errorf("read ProtocolId: expect 1 byte but read %d bytes: %w", n_ProtocolId, err)
	}
	t.ProtocolId = uint8(tmpProtocolId[0])
	tmpIdentifier := [8]byte{}
	n_Identifier, err := io.ReadFull(r, tmpIdentifier[:])
	if err != nil {
		return fmt.Errorf("read Identifier: expect 8 bytes but read %d bytes: %w", n_Identifier, err)
	}
	t.Identifier = uint64(binary.BigEndian.Uint64(tmpIdentifier[:]))
	if err := t.LocalNodeDescriptors.Read(r); err != nil {
		return fmt.Errorf("read LocalNodeDescriptors: %w", err)
	}
	if err := t.PrefixDescriptors.Read(r); err != nil {
		return fmt.Errorf("read PrefixDescriptors: %w", err)
	}
	return nil
}

func (t *PrefixNlri) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *PrefixNlri) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode PrefixNlri: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_126_t) isunion124_() {}
func (t *union_127_t) isunion124_() {}
func (t *union_128_t) isunion124_() {}
func (t *union_129_t) isunion124_() {}
func (t *union_130_t) isunion124_() {}
func (t *LinkStateNlri) Data() *[]uint8 {
	if t.NlriType == Nlritype_NodeNlri {
		return nil
	} else if t.NlriType == Nlritype_LinkNlri {
		return nil
	} else if t.NlriType == Nlritype_Ipv4TopologyPrefix {
		return nil
	} else if t.NlriType == Nlritype_Ipv6TopologyPrefix {
		return nil
	} else if true {
		if _, ok := t.union124_.(*union_130_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union124_.(*union_130_t).Data)
		return &tmp
	}
	return nil
}
func (t *LinkStateNlri) SetData(v []uint8) bool {
	if t.NlriType == Nlritype_NodeNlri {
		return false
	} else if t.NlriType == Nlritype_LinkNlri {
		return false
	} else if t.NlriType == Nlritype_Ipv4TopologyPrefix {
		return false
	} else if t.NlriType == Nlritype_Ipv6TopologyPrefix {
		return false
	} else if true {
		if len(v) > int(^uint16(0)) {
			return false
		}
		if _, ok := t.union124_.(*union_130_t); !ok {
			t.union124_ = &union_130_t{}
		}
		t.NlriLength = uint16(len(v))
		t.union124_.(*union_130_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *LinkStateNlri) LinkNlri() *LinkNlri {
	if t.NlriType == Nlritype_NodeNlri {
		return nil
	} else if t.NlriType == Nlritype_LinkNlri {
		if _, ok := t.union124_.(*union_127_t); !ok {
			return nil // not set
		}
		tmp := LinkNlri(t.union124_.(*union_127_t).LinkNlri)
		return &tmp
	}
	return nil
}
func (t *LinkStateNlri) SetLinkNlri(v LinkNlri) bool {
	if t.NlriType == Nlritype_NodeNlri {
		return false
	} else if t.NlriType == Nlritype_LinkNlri {
		if _, ok := t.union124_.(*union_127_t); !ok {
			t.union124_ = &union_127_t{}
		}
		t.union124_.(*union_127_t).LinkNlri = LinkNlri(v)
		return true
	}
	return false
}
func (t *LinkStateNlri) NodeNlri() *NodeNlri {
	if t.NlriType == Nlritype_NodeNlri {
		if _, ok := t.union124_.(*union_126_t); !ok {
			return nil // not set
		}
		tmp := NodeNlri(t.union124_.(*union_126_t).NodeNlri)
		return &tmp
	}
	return nil
}
func (t *LinkStateNlri) SetNodeNlri(v NodeNlri) bool {
	if t.NlriType == Nlritype_NodeNlri {
		if _, ok := t.union124_.(*union_126_t); !ok {
			t.union124_ = &union_126_t{}
		}
		t.union124_.(*union_126_t).NodeNlri = NodeNlri(v)
		return true
	}
	return false
}
func (t *LinkStateNlri) PrefixNlri() *PrefixNlri {
	if t.NlriType == Nlritype_NodeNlri {
		return nil
	} else if t.NlriType == Nlritype_LinkNlri {
		return nil
	} else if t.NlriType == Nlritype_Ipv4TopologyPrefix {
		if _, ok := t.union124_.(*union_128_t); !ok {
			return nil // not set
		}
		tmp := PrefixNlri(t.union124_.(*union_128_t).PrefixNlri)
		return &tmp
	} else if t.NlriType == Nlritype_Ipv6TopologyPrefix {
		if _, ok := t.union124_.(*union_129_t); !ok {
			return nil // not set
		}
		tmp := PrefixNlri(t.union124_.(*union_129_t).PrefixNlri)
		return &tmp
	}
	return nil
}
func (t *LinkStateNlri) SetPrefixNlri(v PrefixNlri) bool {
	if t.NlriType == Nlritype_NodeNlri {
		return false
	} else if t.NlriType == Nlritype_LinkNlri {
		return false
	} else if t.NlriType == Nlritype_Ipv4TopologyPrefix {
		if _, ok := t.union124_.(*union_128_t); !ok {
			t.union124_ = &union_128_t{}
		}
		t.union124_.(*union_128_t).PrefixNlri = PrefixNlri(v)
		return true
	} else if t.NlriType == Nlritype_Ipv6TopologyPrefix {
		if _, ok := t.union124_.(*union_129_t); !ok {
			t.union124_ = &union_129_t{}
		}
		t.union124_.(*union_129_t).PrefixNlri = PrefixNlri(v)
		return true
	}
	return false
}
func (t *LinkStateNlri) Visit(v VisitorPRAYV) {
	v.Visit(v, "NlriType", &t.NlriType)
	v.Visit(v, "NlriLength", &t.NlriLength)
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "LinkNlri", (t.LinkNlri()))
	v.Visit(v, "NodeNlri", (t.NodeNlri()))
	v.Visit(v, "PrefixNlri", (t.PrefixNlri()))
}
func (t *LinkStateNlri) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *LinkStateNlri) Write(w io.Writer) (err error) {
	tmp131 := [2]byte{}
	binary.BigEndian.PutUint16(tmp131[:], uint16(t.NlriType))
	if n, err := w.Write(tmp131[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.NlriType: %w", err)
	}
	tmp132 := [2]byte{}
	binary.BigEndian.PutUint16(tmp132[:], uint16(t.NlriLength))
	if n, err := w.Write(tmp132[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.NlriLength: %w", err)
	}
	switch {
	case (t.NlriType == Nlritype_NodeNlri):
		if _, ok := t.union124_.(*union_126_t); !ok {
			return fmt.Errorf("encode t.union124_: union is not set to union_126_t")
		}
		new_buf_133 := bytes.NewBuffer(nil)
		old_buf_133_w := w
		w = new_buf_133
		if err := t.union124_.(*union_126_t).NodeNlri.Write(w); err != nil {
			return fmt.Errorf("encode NodeNlri: %w", err)
		}
		if new_buf_133.Len() != int(t.NlriLength) {
			return fmt.Errorf("encode NodeNlri: expect %d bytes but got %d bytes", new_buf_133.Len(), int(t.NlriLength))
		}
		_, err = new_buf_133.WriteTo(old_buf_133_w)
		if err != nil {
			return err
		}
		w = old_buf_133_w
	case (t.NlriType == Nlritype_LinkNlri):
		if _, ok := t.union124_.(*union_127_t); !ok {
			return fmt.Errorf("encode t.union124_: union is not set to union_127_t")
		}
		new_buf_134 := bytes.NewBuffer(nil)
		old_buf_134_w := w
		w = new_buf_134
		if err := t.union124_.(*union_127_t).LinkNlri.Write(w); err != nil {
			return fmt.Errorf("encode LinkNlri: %w", err)
		}
		if new_buf_134.Len() != int(t.NlriLength) {
			return fmt.Errorf("encode LinkNlri: expect %d bytes but got %d bytes", new_buf_134.Len(), int(t.NlriLength))
		}
		_, err = new_buf_134.WriteTo(old_buf_134_w)
		if err != nil {
			return err
		}
		w = old_buf_134_w
	case (t.NlriType == Nlritype_Ipv4TopologyPrefix):
		if _, ok := t.union124_.(*union_128_t); !ok {
			return fmt.Errorf("encode t.union124_: union is not set to union_128_t")
		}
		new_buf_135 := bytes.NewBuffer(nil)
		old_buf_135_w := w
		w = new_buf_135
		if err := t.union124_.(*union_128_t).PrefixNlri.Write(w); err != nil {
			return fmt.Errorf("encode PrefixNlri: %w", err)
		}
		if new_buf_135.Len() != int(t.NlriLength) {
			return fmt.Errorf("encode PrefixNlri: expect %d bytes but got %d bytes", new_buf_135.Len(), int(t.NlriLength))
		}
		_, err = new_buf_135.WriteTo(old_buf_135_w)
		if err != nil {
			return err
		}
		w = old_buf_135_w
	case (t.NlriType == Nlritype_Ipv6TopologyPrefix):
		if _, ok := t.union124_.(*union_129_t); !ok {
			return fmt.Errorf("encode t.union124_: union is not set to union_129_t")
		}
		new_buf_136 := bytes.NewBuffer(nil)
		old_buf_136_w := w
		w = new_buf_136
		if err := t.union124_.(*union_129_t).PrefixNlri.Write(w); err != nil {
			return fmt.Errorf("encode PrefixNlri: %w", err)
		}
		if new_buf_136.Len() != int(t.NlriLength) {
			return fmt.Errorf("encode PrefixNlri: expect %d bytes but got %d bytes", new_buf_136.Len(), int(t.NlriLength))
		}
		_, err = new_buf_136.WriteTo(old_buf_136_w)
		if err != nil {
			return err
		}
		w = old_buf_136_w
	default:
		if _, ok := t.union124_.(*union_130_t); !ok {
			return fmt.Errorf("encode t.union124_: union is not set to union_130_t")
		}
		len_Data := int(t.NlriLength)
		if len(t.union124_.(*union_130_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union124_.(*union_130_t).Data))
		}
		if n, err := w.Write(t.union124_.(*union_130_t).Data); err != nil || n != len(t.union124_.(*union_130_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *LinkStateNlri) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 4))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *LinkStateNlri) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *LinkStateNlri) Read(r io.Reader) (err error) {
	tmpNlriType := [2]byte{}
	n_NlriType, err := io.ReadFull(r, tmpNlriType[:])
	if err != nil {
		return fmt.Errorf("read NlriType: expect 2 bytes but read %d bytes: %w", n_NlriType, err)
	}
	t.NlriType = Nlritype(binary.BigEndian.Uint16(tmpNlriType[:]))
	tmpNlriLength := [2]byte{}
	n_NlriLength, err := io.ReadFull(r, tmpNlriLength[:])
	if err != nil {
		return fmt.Errorf("read NlriLength: expect 2 bytes but read %d bytes: %w", n_NlriLength, err)
	}
	t.NlriLength = uint16(binary.BigEndian.Uint16(tmpNlriLength[:]))
	switch {
	case (t.NlriType == Nlritype_NodeNlri):
		t.union124_ = &union_126_t{}
		sub_byte_len_NodeNlri := int64(t.NlriLength)
		sub_byte_r_NodeNlri := io.LimitReader(r, int64(sub_byte_len_NodeNlri))
		tmp_old_r_NodeNlri_137 := r
		r = sub_byte_r_NodeNlri
		if err := t.union124_.(*union_126_t).NodeNlri.Read(r); err != nil {
			return fmt.Errorf("read NodeNlri: %w", err)
		}
		if sub_byte_r_NodeNlri.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read NodeNlri: expect %d bytes but got %d bytes", sub_byte_len_NodeNlri, sub_byte_len_NodeNlri-sub_byte_r_NodeNlri.(*io.LimitedReader).N)
		}
		r = tmp_old_r_NodeNlri_137
	case (t.NlriType == Nlritype_LinkNlri):
		t.union124_ = &union_127_t{}
		sub_byte_len_LinkNlri := int64(t.NlriLength)
		sub_byte_r_LinkNlri := io.LimitReader(r, int64(sub_byte_len_LinkNlri))
		tmp_old_r_LinkNlri_138 := r
		r = sub_byte_r_LinkNlri
		if err := t.union124_.(*union_127_t).LinkNlri.Read(r); err != nil {
			return fmt.Errorf("read LinkNlri: %w", err)
		}
		if sub_byte_r_LinkNlri.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read LinkNlri: expect %d bytes but got %d bytes", sub_byte_len_LinkNlri, sub_byte_len_LinkNlri-sub_byte_r_LinkNlri.(*io.LimitedReader).N)
		}
		r = tmp_old_r_LinkNlri_138
	case (t.NlriType == Nlritype_Ipv4TopologyPrefix):
		t.union124_ = &union_128_t{}
		sub_byte_len_PrefixNlri := int64(t.NlriLength)
		sub_byte_r_PrefixNlri := io.LimitReader(r, int64(sub_byte_len_PrefixNlri))
		tmp_old_r_PrefixNlri_139 := r
		r = sub_byte_r_PrefixNlri
		if err := t.union124_.(*union_128_t).PrefixNlri.Read(r); err != nil {
			return fmt.Errorf("read PrefixNlri: %w", err)
		}
		if sub_byte_r_PrefixNlri.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read PrefixNlri: expect %d bytes but got %d bytes", sub_byte_len_PrefixNlri, sub_byte_len_PrefixNlri-sub_byte_r_PrefixNlri.(*io.LimitedReader).N)
		}
		r = tmp_old_r_PrefixNlri_139
	case (t.NlriType == Nlritype_Ipv6TopologyPrefix):
		t.union124_ = &union_129_t{}
		sub_byte_len_PrefixNlri := int64(t.NlriLength)
		sub_byte_r_PrefixNlri := io.LimitReader(r, int64(sub_byte_len_PrefixNlri))
		tmp_old_r_PrefixNlri_140 := r
		r = sub_byte_r_PrefixNlri
		if err := t.union124_.(*union_129_t).PrefixNlri.Read(r); err != nil {
			return fmt.Errorf("read PrefixNlri: %w", err)
		}
		if sub_byte_r_PrefixNlri.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read PrefixNlri: expect %d bytes but got %d bytes", sub_byte_len_PrefixNlri, sub_byte_len_PrefixNlri-sub_byte_r_PrefixNlri.(*io.LimitedReader).N)
		}
		r = tmp_old_r_PrefixNlri_140
	default:
		t.union124_ = &union_130_t{}
		len_Data := int(t.NlriLength)
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union124_.(*union_130_t).Data = tmpData[:]
		} else {
			t.union124_.(*union_130_t).Data = nil
		}
	}
	return nil
}

func (t *LinkStateNlri) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *LinkStateNlri) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode LinkStateNlri: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_143_t) isunion141_() {}
func (t *union_144_t) isunion141_() {}
func (t *PathAttribute) Len() *uint16 {
	if true == ((func() uint8 {
		if t.Type.Extended() {
			return 1
		} else {
			return 0
		}
	}()) == 1) {
		if _, ok := t.union141_.(*union_143_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union141_.(*union_143_t).Len)
		return &tmp
	} else if true {
		if _, ok := t.union141_.(*union_144_t); !ok {
			return nil // not set
		}
		tmp := uint16(t.union141_.(*union_144_t).Len)
		return &tmp
	}
	return nil
}
func (t *PathAttribute) SetLen(v uint16) bool {
	if true == ((func() uint8 {
		if t.Type.Extended() {
			return 1
		} else {
			return 0
		}
	}()) == 1) {
		if _, ok := t.union141_.(*union_143_t); !ok {
			t.union141_ = &union_143_t{}
		}
		t.union141_.(*union_143_t).Len = uint16(v)
		return true
	} else if true {
		if v > uint16(^uint8(0)) {
			return false
		}
		if _, ok := t.union141_.(*union_144_t); !ok {
			t.union141_ = &union_144_t{}
		}
		t.union141_.(*union_144_t).Len = uint8(v)
		return true
	}
	return false
}
func (t *union_147_t) isunion145_() {}
func (t *union_148_t) isunion145_() {}
func (t *union_149_t) isunion145_() {}
func (t *union_150_t) isunion145_() {}
func (t *union_151_t) isunion145_() {}
func (t *union_152_t) isunion145_() {}
func (t *union_153_t) isunion145_() {}
func (t *union_154_t) isunion145_() {}
func (t *union_155_t) isunion145_() {}
func (t *union_156_t) isunion145_() {}
func (t *union_157_t) isunion145_() {}
func (t *PathAttribute) Aggregator() *Aggregator {
	if t.Type.Code == AttributeCode_Origin {
		return nil
	} else if t.Type.Code == AttributeCode_AsPath {
		return nil
	} else if t.Type.Code == AttributeCode_NextHop {
		return nil
	} else if t.Type.Code == AttributeCode_MultiExitDisc {
		return nil
	} else if t.Type.Code == AttributeCode_LocalPref {
		return nil
	} else if t.Type.Code == AttributeCode_AtomicAggregate {
		return nil
	} else if t.Type.Code == AttributeCode_Aggregator {
		if _, ok := t.union145_.(*union_153_t); !ok {
			return nil // not set
		}
		tmp := Aggregator(t.union145_.(*union_153_t).Aggregator)
		return &tmp
	}
	return nil
}
func (t *PathAttribute) SetAggregator(v Aggregator) bool {
	if t.Type.Code == AttributeCode_Origin {
		return false
	} else if t.Type.Code == AttributeCode_AsPath {
		return false
	} else if t.Type.Code == AttributeCode_NextHop {
		return false
	} else if t.Type.Code == AttributeCode_MultiExitDisc {
		return false
	} else if t.Type.Code == AttributeCode_LocalPref {
		return false
	} else if t.Type.Code == AttributeCode_AtomicAggregate {
		return false
	} else if t.Type.Code == AttributeCode_Aggregator {
		if _, ok := t.union145_.(*union_153_t); !ok {
			t.union145_ = &union_153_t{}
		}
		t.union145_.(*union_153_t).Aggregator = Aggregator(v)
		return true
	}
	return false
}
func (t *PathAttribute) AsPath() *AsPath {
	if t.Type.Code == AttributeCode_Origin {
		return nil
	} else if t.Type.Code == AttributeCode_AsPath {
		if _, ok := t.union145_.(*union_148_t); !ok {
			return nil // not set
		}
		tmp := AsPath(t.union145_.(*union_148_t).AsPath)
		return &tmp
	}
	return nil
}
func (t *PathAttribute) SetAsPath(v AsPath) bool {
	if t.Type.Code == AttributeCode_Origin {
		return false
	} else if t.Type.Code == AttributeCode_AsPath {
		if _, ok := t.union145_.(*union_148_t); !ok {
			t.union145_ = &union_148_t{}
		}
		t.union145_.(*union_148_t).AsPath = AsPath(v)
		return true
	}
	return false
}
func (t *PathAttribute) BgpLs() *LinkStateNlri {
	if t.Type.Code == AttributeCode_Origin {
		return nil
	} else if t.Type.Code == AttributeCode_AsPath {
		return nil
	} else if t.Type.Code == AttributeCode_NextHop {
		return nil
	} else if t.Type.Code == AttributeCode_MultiExitDisc {
		return nil
	} else if t.Type.Code == AttributeCode_LocalPref {
		return nil
	} else if t.Type.Code == AttributeCode_AtomicAggregate {
		return nil
	} else if t.Type.Code == AttributeCode_Aggregator {
		return nil
	} else if t.Type.Code == AttributeCode_Communities {
		return nil
	} else if t.Type.Code == AttributeCode_ExtendedCommunities {
		return nil
	} else if t.Type.Code == AttributeCode_BgpLs {
		if _, ok := t.union145_.(*union_156_t); !ok {
			return nil // not set
		}
		tmp := LinkStateNlri(t.union145_.(*union_156_t).BgpLs)
		return &tmp
	}
	return nil
}
func (t *PathAttribute) SetBgpLs(v LinkStateNlri) bool {
	if t.Type.Code == AttributeCode_Origin {
		return false
	} else if t.Type.Code == AttributeCode_AsPath {
		return false
	} else if t.Type.Code == AttributeCode_NextHop {
		return false
	} else if t.Type.Code == AttributeCode_MultiExitDisc {
		return false
	} else if t.Type.Code == AttributeCode_LocalPref {
		return false
	} else if t.Type.Code == AttributeCode_AtomicAggregate {
		return false
	} else if t.Type.Code == AttributeCode_Aggregator {
		return false
	} else if t.Type.Code == AttributeCode_Communities {
		return false
	} else if t.Type.Code == AttributeCode_ExtendedCommunities {
		return false
	} else if t.Type.Code == AttributeCode_BgpLs {
		if _, ok := t.union145_.(*union_156_t); !ok {
			t.union145_ = &union_156_t{}
		}
		t.union145_.(*union_156_t).BgpLs = LinkStateNlri(v)
		return true
	}
	return false
}
func (t *PathAttribute) Communities() *[]uint32 {
	if t.Type.Code == AttributeCode_Origin {
		return nil
	} else if t.Type.Code == AttributeCode_AsPath {
		return nil
	} else if t.Type.Code == AttributeCode_NextHop {
		return nil
	} else if t.Type.Code == AttributeCode_MultiExitDisc {
		return nil
	} else if t.Type.Code == AttributeCode_LocalPref {
		return nil
	} else if t.Type.Code == AttributeCode_AtomicAggregate {
		return nil
	} else if t.Type.Code == AttributeCode_Aggregator {
		return nil
	} else if t.Type.Code == AttributeCode_Communities {
		if _, ok := t.union145_.(*union_154_t); !ok {
			return nil // not set
		}
		tmp := []uint32(t.union145_.(*union_154_t).Communities)
		return &tmp
	}
	return nil
}
func (t *PathAttribute) SetCommunities(v []uint32) bool {
	if t.Type.Code == AttributeCode_Origin {
		return false
	} else if t.Type.Code == AttributeCode_AsPath {
		return false
	} else if t.Type.Code == AttributeCode_NextHop {
		return false
	} else if t.Type.Code == AttributeCode_MultiExitDisc {
		return false
	} else if t.Type.Code == AttributeCode_LocalPref {
		return false
	} else if t.Type.Code == AttributeCode_AtomicAggregate {
		return false
	} else if t.Type.Code == AttributeCode_Aggregator {
		return false
	} else if t.Type.Code == AttributeCode_Communities {
		if _, ok := t.union145_.(*union_154_t); !ok {
			t.union145_ = &union_154_t{}
		}
		t.union145_.(*union_154_t).Communities = []uint32(v)
		return true
	}
	return false
}
func (t *PathAttribute) Data() *[]uint8 {
	if t.Type.Code == AttributeCode_Origin {
		return nil
	} else if t.Type.Code == AttributeCode_AsPath {
		return nil
	} else if t.Type.Code == AttributeCode_NextHop {
		return nil
	} else if t.Type.Code == AttributeCode_MultiExitDisc {
		return nil
	} else if t.Type.Code == AttributeCode_LocalPref {
		return nil
	} else if t.Type.Code == AttributeCode_AtomicAggregate {
		return nil
	} else if t.Type.Code == AttributeCode_Aggregator {
		return nil
	} else if t.Type.Code == AttributeCode_Communities {
		return nil
	} else if t.Type.Code == AttributeCode_ExtendedCommunities {
		return nil
	} else if t.Type.Code == AttributeCode_BgpLs {
		return nil
	} else if true {
		if _, ok := t.union145_.(*union_157_t); !ok {
			return nil // not set
		}
		tmp := []uint8(t.union145_.(*union_157_t).Data)
		return &tmp
	}
	return nil
}
func (t *PathAttribute) SetData(v []uint8) bool {
	if t.Type.Code == AttributeCode_Origin {
		return false
	} else if t.Type.Code == AttributeCode_AsPath {
		return false
	} else if t.Type.Code == AttributeCode_NextHop {
		return false
	} else if t.Type.Code == AttributeCode_MultiExitDisc {
		return false
	} else if t.Type.Code == AttributeCode_LocalPref {
		return false
	} else if t.Type.Code == AttributeCode_AtomicAggregate {
		return false
	} else if t.Type.Code == AttributeCode_Aggregator {
		return false
	} else if t.Type.Code == AttributeCode_Communities {
		return false
	} else if t.Type.Code == AttributeCode_ExtendedCommunities {
		return false
	} else if t.Type.Code == AttributeCode_BgpLs {
		return false
	} else if true {
		if _, ok := t.union145_.(*union_157_t); !ok {
			t.union145_ = &union_157_t{}
		}
		t.union145_.(*union_157_t).Data = []uint8(v)
		return true
	}
	return false
}
func (t *PathAttribute) ExtendedCommunities() *[]ExtendedCommunity {
	if t.Type.Code == AttributeCode_Origin {
		return nil
	} else if t.Type.Code == AttributeCode_AsPath {
		return nil
	} else if t.Type.Code == AttributeCode_NextHop {
		return nil
	} else if t.Type.Code == AttributeCode_MultiExitDisc {
		return nil
	} else if t.Type.Code == AttributeCode_LocalPref {
		return nil
	} else if t.Type.Code == AttributeCode_AtomicAggregate {
		return nil
	} else if t.Type.Code == AttributeCode_Aggregator {
		return nil
	} else if t.Type.Code == AttributeCode_Communities {
		return nil
	} else if t.Type.Code == AttributeCode_ExtendedCommunities {
		if _, ok := t.union145_.(*union_155_t); !ok {
			return nil // not set
		}
		tmp := []ExtendedCommunity(t.union145_.(*union_155_t).ExtendedCommunities)
		return &tmp
	}
	return nil
}
func (t *PathAttribute) SetExtendedCommunities(v []ExtendedCommunity) bool {
	if t.Type.Code == AttributeCode_Origin {
		return false
	} else if t.Type.Code == AttributeCode_AsPath {
		return false
	} else if t.Type.Code == AttributeCode_NextHop {
		return false
	} else if t.Type.Code == AttributeCode_MultiExitDisc {
		return false
	} else if t.Type.Code == AttributeCode_LocalPref {
		return false
	} else if t.Type.Code == AttributeCode_AtomicAggregate {
		return false
	} else if t.Type.Code == AttributeCode_Aggregator {
		return false
	} else if t.Type.Code == AttributeCode_Communities {
		return false
	} else if t.Type.Code == AttributeCode_ExtendedCommunities {
		if _, ok := t.union145_.(*union_155_t); !ok {
			t.union145_ = &union_155_t{}
		}
		t.union145_.(*union_155_t).ExtendedCommunities = []ExtendedCommunity(v)
		return true
	}
	return false
}
func (t *PathAttribute) LocalPref() *uint32 {
	if t.Type.Code == AttributeCode_Origin {
		return nil
	} else if t.Type.Code == AttributeCode_AsPath {
		return nil
	} else if t.Type.Code == AttributeCode_NextHop {
		return nil
	} else if t.Type.Code == AttributeCode_MultiExitDisc {
		return nil
	} else if t.Type.Code == AttributeCode_LocalPref {
		if _, ok := t.union145_.(*union_151_t); !ok {
			return nil // not set
		}
		tmp := uint32(t.union145_.(*union_151_t).LocalPref)
		return &tmp
	}
	return nil
}
func (t *PathAttribute) SetLocalPref(v uint32) bool {
	if t.Type.Code == AttributeCode_Origin {
		return false
	} else if t.Type.Code == AttributeCode_AsPath {
		return false
	} else if t.Type.Code == AttributeCode_NextHop {
		return false
	} else if t.Type.Code == AttributeCode_MultiExitDisc {
		return false
	} else if t.Type.Code == AttributeCode_LocalPref {
		if _, ok := t.union145_.(*union_151_t); !ok {
			t.union145_ = &union_151_t{}
		}
		t.union145_.(*union_151_t).LocalPref = uint32(v)
		return true
	}
	return false
}
func (t *PathAttribute) MultiExitDisc() *uint32 {
	if t.Type.Code == AttributeCode_Origin {
		return nil
	} else if t.Type.Code == AttributeCode_AsPath {
		return nil
	} else if t.Type.Code == AttributeCode_NextHop {
		return nil
	} else if t.Type.Code == AttributeCode_MultiExitDisc {
		if _, ok := t.union145_.(*union_150_t); !ok {
			return nil // not set
		}
		tmp := uint32(t.union145_.(*union_150_t).MultiExitDisc)
		return &tmp
	}
	return nil
}
func (t *PathAttribute) SetMultiExitDisc(v uint32) bool {
	if t.Type.Code == AttributeCode_Origin {
		return false
	} else if t.Type.Code == AttributeCode_AsPath {
		return false
	} else if t.Type.Code == AttributeCode_NextHop {
		return false
	} else if t.Type.Code == AttributeCode_MultiExitDisc {
		if _, ok := t.union145_.(*union_150_t); !ok {
			t.union145_ = &union_150_t{}
		}
		t.union145_.(*union_150_t).MultiExitDisc = uint32(v)
		return true
	}
	return false
}
func (t *PathAttribute) NextHop() *[4]uint8 {
	if t.Type.Code == AttributeCode_Origin {
		return nil
	} else if t.Type.Code == AttributeCode_AsPath {
		return nil
	} else if t.Type.Code == AttributeCode_NextHop {
		if _, ok := t.union145_.(*union_149_t); !ok {
			return nil // not set
		}
		tmp := [4]uint8(t.union145_.(*union_149_t).NextHop[:])
		return &tmp
	}
	return nil
}
func (t *PathAttribute) SetNextHop(v [4]uint8) bool {
	if t.Type.Code == AttributeCode_Origin {
		return false
	} else if t.Type.Code == AttributeCode_AsPath {
		return false
	} else if t.Type.Code == AttributeCode_NextHop {
		if _, ok := t.union145_.(*union_149_t); !ok {
			t.union145_ = &union_149_t{}
		}
		t.union145_.(*union_149_t).NextHop = [4]uint8(v)
		return true
	}
	return false
}
func (t *PathAttribute) Origin() *Origin {
	if t.Type.Code == AttributeCode_Origin {
		if _, ok := t.union145_.(*union_147_t); !ok {
			return nil // not set
		}
		tmp := Origin(t.union145_.(*union_147_t).Origin)
		return &tmp
	}
	return nil
}
func (t *PathAttribute) SetOrigin(v Origin) bool {
	if t.Type.Code == AttributeCode_Origin {
		if _, ok := t.union145_.(*union_147_t); !ok {
			t.union145_ = &union_147_t{}
		}
		t.union145_.(*union_147_t).Origin = Origin(v)
		return true
	}
	return false
}
func (t *PathAttribute) Visit(v VisitorPRAYV) {
	v.Visit(v, "Type", &t.Type)
	v.Visit(v, "Len", (t.Len()))
	v.Visit(v, "Aggregator", (t.Aggregator()))
	v.Visit(v, "AsPath", (t.AsPath()))
	v.Visit(v, "BgpLs", (t.BgpLs()))
	v.Visit(v, "Communities", (t.Communities()))
	v.Visit(v, "Data", (t.Data()))
	v.Visit(v, "ExtendedCommunities", (t.ExtendedCommunities()))
	v.Visit(v, "LocalPref", (t.LocalPref()))
	v.Visit(v, "MultiExitDisc", (t.MultiExitDisc()))
	v.Visit(v, "NextHop", (t.NextHop()))
	v.Visit(v, "Origin", (t.Origin()))
}
func (t *PathAttribute) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *PathAttribute) Write(w io.Writer) (err error) {
	if err := t.Type.Write(w); err != nil {
		return fmt.Errorf("encode Type: %w", err)
	}
	if (func() uint8 {
		if t.Type.Extended() {
			return 1
		} else {
			return 0
		}
	}()) == 1 {
		if _, ok := t.union141_.(*union_143_t); !ok {
			return fmt.Errorf("encode t.union141_: union is not set to union_143_t")
		}
		tmp158 := [2]byte{}
		binary.BigEndian.PutUint16(tmp158[:], uint16(t.union141_.(*union_143_t).Len))
		if n, err := w.Write(tmp158[:]); err != nil || n != 2 {
			return fmt.Errorf("encode t.union141_.(*union_143_t).Len: %w", err)
		}
	} else {
		if _, ok := t.union141_.(*union_144_t); !ok {
			return fmt.Errorf("encode t.union141_: union is not set to union_144_t")
		}
		if n, err := w.Write([]byte{byte(t.union141_.(*union_144_t).Len)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union141_.(*union_144_t).Len: %w", err)
		}
	}
	LenTmp := uint16((*t.Len()))
	switch {
	case (t.Type.Code == AttributeCode_Origin):
		if _, ok := t.union145_.(*union_147_t); !ok {
			return fmt.Errorf("encode t.union145_: union is not set to union_147_t")
		}
		new_buf_159 := bytes.NewBuffer(nil)
		old_buf_159_w := w
		w = new_buf_159
		if n, err := w.Write([]byte{byte(t.union145_.(*union_147_t).Origin)}); err != nil || n != 1 {
			return fmt.Errorf("encode t.union145_.(*union_147_t).Origin: %w", err)
		}
		if new_buf_159.Len() != int(LenTmp) {
			return fmt.Errorf("encode Origin: expect %d bytes but got %d bytes", new_buf_159.Len(), int(LenTmp))
		}
		_, err = new_buf_159.WriteTo(old_buf_159_w)
		if err != nil {
			return err
		}
		w = old_buf_159_w
	case (t.Type.Code == AttributeCode_AsPath):
		if _, ok := t.union145_.(*union_148_t); !ok {
			return fmt.Errorf("encode t.union145_: union is not set to union_148_t")
		}
		new_buf_160 := bytes.NewBuffer(nil)
		old_buf_160_w := w
		w = new_buf_160
		if err := t.union145_.(*union_148_t).AsPath.Write(w); err != nil {
			return fmt.Errorf("encode AsPath: %w", err)
		}
		if new_buf_160.Len() != int(LenTmp) {
			return fmt.Errorf("encode AsPath: expect %d bytes but got %d bytes", new_buf_160.Len(), int(LenTmp))
		}
		_, err = new_buf_160.WriteTo(old_buf_160_w)
		if err != nil {
			return err
		}
		w = old_buf_160_w
	case (t.Type.Code == AttributeCode_NextHop):
		if _, ok := t.union145_.(*union_149_t); !ok {
			return fmt.Errorf("encode t.union145_: union is not set to union_149_t")
		}
		new_buf_161 := bytes.NewBuffer(nil)
		old_buf_161_w := w
		w = new_buf_161
		if n, err := w.Write(t.union145_.(*union_149_t).NextHop[:]); err != nil || n != len(t.union145_.(*union_149_t).NextHop) {
			return fmt.Errorf("encode NextHop: %w", err)
		}
		if new_buf_161.Len() != int(LenTmp) {
			return fmt.Errorf("encode NextHop: expect %d bytes but got %d bytes", new_buf_161.Len(), int(LenTmp))
		}
		_, err = new_buf_161.WriteTo(old_buf_161_w)
		if err != nil {
			return err
		}
		w = old_buf_161_w
	case (t.Type.Code == AttributeCode_MultiExitDisc):
		if _, ok := t.union145_.(*union_150_t); !ok {
			return fmt.Errorf("encode t.union145_: union is not set to union_150_t")
		}
		new_buf_162 := bytes.NewBuffer(nil)
		old_buf_162_w := w
		w = new_buf_162
		tmp163 := [4]byte{}
		binary.BigEndian.PutUint32(tmp163[:], uint32(t.union145_.(*union_150_t).MultiExitDisc))
		if n, err := w.Write(tmp163[:]); err != nil || n != 4 {
			return fmt.Errorf("encode t.union145_.(*union_150_t).MultiExitDisc: %w", err)
		}
		if new_buf_162.Len() != int(LenTmp) {
			return fmt.Errorf("encode MultiExitDisc: expect %d bytes but got %d bytes", new_buf_162.Len(), int(LenTmp))
		}
		_, err = new_buf_162.WriteTo(old_buf_162_w)
		if err != nil {
			return err
		}
		w = old_buf_162_w
	case (t.Type.Code == AttributeCode_LocalPref):
		if _, ok := t.union145_.(*union_151_t); !ok {
			return fmt.Errorf("encode t.union145_: union is not set to union_151_t")
		}
		new_buf_164 := bytes.NewBuffer(nil)
		old_buf_164_w := w
		w = new_buf_164
		tmp165 := [4]byte{}
		binary.BigEndian.PutUint32(tmp165[:], uint32(t.union145_.(*union_151_t).LocalPref))
		if n, err := w.Write(tmp165[:]); err != nil || n != 4 {
			return fmt.Errorf("encode t.union145_.(*union_151_t).LocalPref: %w", err)
		}
		if new_buf_164.Len() != int(LenTmp) {
			return fmt.Errorf("encode LocalPref: expect %d bytes but got %d bytes", new_buf_164.Len(), int(LenTmp))
		}
		_, err = new_buf_164.WriteTo(old_buf_164_w)
		if err != nil {
			return err
		}
		w = old_buf_164_w
	case (t.Type.Code == AttributeCode_AtomicAggregate):
	case (t.Type.Code == AttributeCode_Aggregator):
		if _, ok := t.union145_.(*union_153_t); !ok {
			return fmt.Errorf("encode t.union145_: union is not set to union_153_t")
		}
		new_buf_166 := bytes.NewBuffer(nil)
		old_buf_166_w := w
		w = new_buf_166
		if err := t.union145_.(*union_153_t).Aggregator.Write(w); err != nil {
			return fmt.Errorf("encode Aggregator: %w", err)
		}
		if new_buf_166.Len() != int(LenTmp) {
			return fmt.Errorf("encode Aggregator: expect %d bytes but got %d bytes", new_buf_166.Len(), int(LenTmp))
		}
		_, err = new_buf_166.WriteTo(old_buf_166_w)
		if err != nil {
			return err
		}
		w = old_buf_166_w
	case (t.Type.Code == AttributeCode_Communities):
		if _, ok := t.union145_.(*union_154_t); !ok {
			return fmt.Errorf("encode t.union145_: union is not set to union_154_t")
		}
		new_buf_167 := bytes.NewBuffer(nil)
		old_buf_167_w := w
		w = new_buf_167
		for _, v := range t.union145_.(*union_154_t).Communities {
			tmp168 := [4]byte{}
			binary.BigEndian.PutUint32(tmp168[:], uint32(v))
			if n, err := w.Write(tmp168[:]); err != nil || n != 4 {
				return fmt.Errorf("encode v: %w", err)
			}
		}
		if new_buf_167.Len() != int(LenTmp) {
			return fmt.Errorf("encode Communities: expect %d bytes but got %d bytes", new_buf_167.Len(), int(LenTmp))
		}
		_, err = new_buf_167.WriteTo(old_buf_167_w)
		if err != nil {
			return err
		}
		w = old_buf_167_w
	case (t.Type.Code == AttributeCode_ExtendedCommunities):
		if _, ok := t.union145_.(*union_155_t); !ok {
			return fmt.Errorf("encode t.union145_: union is not set to union_155_t")
		}
		new_buf_169 := bytes.NewBuffer(nil)
		old_buf_169_w := w
		w = new_buf_169
		for _, v := range t.union145_.(*union_155_t).ExtendedCommunities {
			if err := v.Write(w); err != nil {
				return fmt.Errorf("encode ExtendedCommunities: %w", err)
			}
		}
		if new_buf_169.Len() != int(LenTmp) {
			return fmt.Errorf("encode ExtendedCommunities: expect %d bytes but got %d bytes", new_buf_169.Len(), int(LenTmp))
		}
		_, err = new_buf_169.WriteTo(old_buf_169_w)
		if err != nil {
			return err
		}
		w = old_buf_169_w
	case (t.Type.Code == AttributeCode_BgpLs):
		if _, ok := t.union145_.(*union_156_t); !ok {
			return fmt.Errorf("encode t.union145_: union is not set to union_156_t")
		}
		new_buf_170 := bytes.NewBuffer(nil)
		old_buf_170_w := w
		w = new_buf_170
		if err := t.union145_.(*union_156_t).BgpLs.Write(w); err != nil {
			return fmt.Errorf("encode BgpLs: %w", err)
		}
		if new_buf_170.Len() != int(LenTmp) {
			return fmt.Errorf("encode BgpLs: expect %d bytes but got %d bytes", new_buf_170.Len(), int(LenTmp))
		}
		_, err = new_buf_170.WriteTo(old_buf_170_w)
		if err != nil {
			return err
		}
		w = old_buf_170_w
	default:
		if _, ok := t.union145_.(*union_157_t); !ok {
			return fmt.Errorf("encode t.union145_: union is not set to union_157_t")
		}
		len_Data := int(LenTmp)
		if len(t.union145_.(*union_157_t).Data) != len_Data {
			return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", len_Data, len(t.union145_.(*union_157_t).Data))
		}
		if n, err := w.Write(t.union145_.(*union_157_t).Data); err != nil || n != len(t.union145_.(*union_157_t).Data) {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	return nil
}
func (t *PathAttribute) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *PathAttribute) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *PathAttribute) Read(r io.Reader) (err error) {
	if err := t.Type.Read(r); err != nil {
		return fmt.Errorf("read Type: %w", err)
	}
	if (func() uint8 {
		if t.Type.Extended() {
			return 1
		} else {
			return 0
		}
	}()) == 1 {
		t.union141_ = &union_143_t{}
		tmpLen := [2]byte{}
		n_Len, err := io.ReadFull(r, tmpLen[:])
		if err != nil {
			return fmt.Errorf("read Len: expect 2 bytes but read %d bytes: %w", n_Len, err)
		}
		t.union141_.(*union_143_t).Len = uint16(binary.BigEndian.Uint16(tmpLen[:]))
	} else {
		t.union141_ = &union_144_t{}
		tmpLen := [1]byte{}
		n_Len, err := io.ReadFull(r, tmpLen[:])
		if err != nil {
			return fmt.Errorf("read Len: expect 1 byte but read %d bytes: %w", n_Len, err)
		}
		t.union141_.(*union_144_t).Len = uint8(tmpLen[0])
	}
	LenTmp := uint16((*t.Len()))
	switch {
	case (t.Type.Code == AttributeCode_Origin):
		t.union145_ = &union_147_t{}
		sub_byte_len_Origin := int64(LenTmp)
		sub_byte_r_Origin := io.LimitReader(r, int64(sub_byte_len_Origin))
		tmp_old_r_Origin_171 := r
		r = sub_byte_r_Origin
		tmpOrigin := [1]byte{}
		n_Origin, err := io.ReadFull(r, tmpOrigin[:])
		if err != nil {
			return fmt.Errorf("read Origin: expect 1 byte but read %d bytes: %w", n_Origin, err)
		}
		t.union145_.(*union_147_t).Origin = Origin(tmpOrigin[0])
		if sub_byte_r_Origin.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Origin: expect %d bytes but got %d bytes", sub_byte_len_Origin, sub_byte_len_Origin-sub_byte_r_Origin.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Origin_171
	case (t.Type.Code == AttributeCode_AsPath):
		t.union145_ = &union_148_t{}
		sub_byte_len_AsPath := int64(LenTmp)
		sub_byte_r_AsPath := io.LimitReader(r, int64(sub_byte_len_AsPath))
		tmp_old_r_AsPath_172 := r
		r = sub_byte_r_AsPath
		if err := t.union145_.(*union_148_t).AsPath.Read(r); err != nil {
			return fmt.Errorf("read AsPath: %w", err)
		}
		if sub_byte_r_AsPath.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read AsPath: expect %d bytes but got %d bytes", sub_byte_len_AsPath, sub_byte_len_AsPath-sub_byte_r_AsPath.(*io.LimitedReader).N)
		}
		r = tmp_old_r_AsPath_172
	case (t.Type.Code == AttributeCode_NextHop):
		t.union145_ = &union_149_t{}
		sub_byte_len_NextHop := int64(LenTmp)
		sub_byte_r_NextHop := io.LimitReader(r, int64(sub_byte_len_NextHop))
		tmp_old_r_NextHop_173 := r
		r = sub_byte_r_NextHop
		n_NextHop, err := io.ReadFull(r, t.union145_.(*union_149_t).NextHop[:])
		if err != nil {
			return fmt.Errorf("read NextHop: expect %d bytes but read %d bytes: %w", 4, n_NextHop, err)
		}
		if sub_byte_r_NextHop.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read NextHop: expect %d bytes but got %d bytes", sub_byte_len_NextHop, sub_byte_len_NextHop-sub_byte_r_NextHop.(*io.LimitedReader).N)
		}
		r = tmp_old_r_NextHop_173
	case (t.Type.Code == AttributeCode_MultiExitDisc):
		t.union145_ = &union_150_t{}
		sub_byte_len_MultiExitDisc := int64(LenTmp)
		sub_byte_r_MultiExitDisc := io.LimitReader(r, int64(sub_byte_len_MultiExitDisc))
		tmp_old_r_MultiExitDisc_174 := r
		r = sub_byte_r_MultiExitDisc
		tmpMultiExitDisc := [4]byte{}
		n_MultiExitDisc, err := io.ReadFull(r, tmpMultiExitDisc[:])
		if err != nil {
			return fmt.Errorf("read MultiExitDisc: expect 4 bytes but read %d bytes: %w", n_MultiExitDisc, err)
		}
		t.union145_.(*union_150_t).MultiExitDisc = uint32(binary.BigEndian.Uint32(tmpMultiExitDisc[:]))
		if sub_byte_r_MultiExitDisc.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read MultiExitDisc: expect %d bytes but got %d bytes", sub_byte_len_MultiExitDisc, sub_byte_len_MultiExitDisc-sub_byte_r_MultiExitDisc.(*io.LimitedReader).N)
		}
		r = tmp_old_r_MultiExitDisc_174
	case (t.Type.Code == AttributeCode_LocalPref):
		t.union145_ = &union_151_t{}
		sub_byte_len_LocalPref := int64(LenTmp)
		sub_byte_r_LocalPref := io.LimitReader(r, int64(sub_byte_len_LocalPref))
		tmp_old_r_LocalPref_175 := r
		r = sub_byte_r_LocalPref
		tmpLocalPref := [4]byte{}
		n_LocalPref, err := io.ReadFull(r, tmpLocalPref[:])
		if err != nil {
			return fmt.Errorf("read LocalPref: expect 4 bytes but read %d bytes: %w", n_LocalPref, err)
		}
		t.union145_.(*union_151_t).LocalPref = uint32(binary.BigEndian.Uint32(tmpLocalPref[:]))
		if sub_byte_r_LocalPref.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read LocalPref: expect %d bytes but got %d bytes", sub_byte_len_LocalPref, sub_byte_len_LocalPref-sub_byte_r_LocalPref.(*io.LimitedReader).N)
		}
		r = tmp_old_r_LocalPref_175
	case (t.Type.Code == AttributeCode_AtomicAggregate):
	case (t.Type.Code == AttributeCode_Aggregator):
		t.union145_ = &union_153_t{}
		sub_byte_len_Aggregator := int64(LenTmp)
		sub_byte_r_Aggregator := io.LimitReader(r, int64(sub_byte_len_Aggregator))
		tmp_old_r_Aggregator_176 := r
		r = sub_byte_r_Aggregator
		if err := t.union145_.(*union_153_t).Aggregator.Read(r); err != nil {
			return fmt.Errorf("read Aggregator: %w", err)
		}
		if sub_byte_r_Aggregator.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Aggregator: expect %d bytes but got %d bytes", sub_byte_len_Aggregator, sub_byte_len_Aggregator-sub_byte_r_Aggregator.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Aggregator_176
	case (t.Type.Code == AttributeCode_Communities):
		t.union145_ = &union_154_t{}
		sub_byte_len_Communities := int64(LenTmp)
		sub_byte_r_Communities := io.LimitReader(r, int64(sub_byte_len_Communities))
		tmp_old_r_Communities_177 := r
		r = sub_byte_r_Communities
		len_Communities := int(r.(*io.LimitedReader).N)
		tmpCommunities := make([]byte, len_Communities)
		n_Communities, err := io.ReadFull(r, tmpCommunities[:])
		if err != nil {
			return fmt.Errorf("read Communities: expect %d bytes but read %d bytes: %w", len_Communities, n_Communities, err)
		}
		range_tmp_Communities := bytes.NewReader(tmpCommunities[:])
		tmp_old_r_Communities := r
		r = range_tmp_Communities
		for range_tmp_Communities.Len() > 0 {
			var tmp178_ uint32
			tmpCommunities := [4]byte{}
			n_Communities, err := io.ReadFull(r, tmpCommunities[:])
			if err != nil {
				return fmt.Errorf("read Communities: expect 4 bytes but read %d bytes: %w", n_Communities, err)
			}
			tmp178_ = uint32(binary.BigEndian.Uint32(tmpCommunities[:]))
			t.union145_.(*union_154_t).Communities = append(t.union145_.(*union_154_t).Communities, tmp178_)
		}
		r = tmp_old_r_Communities
		if sub_byte_r_Communities.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Communities: expect %d bytes but got %d bytes", sub_byte_len_Communities, sub_byte_len_Communities-sub_byte_r_Communities.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Communities_177
	case (t.Type.Code == AttributeCode_ExtendedCommunities):
		t.union145_ = &union_155_t{}
		sub_byte_len_ExtendedCommunities := int64(LenTmp)
		sub_byte_r_ExtendedCommunities := io.LimitReader(r, int64(sub_byte_len_ExtendedCommunities))
		tmp_old_r_ExtendedCommunities_179 := r
		r = sub_byte_r_ExtendedCommunities
		len_ExtendedCommunities := int(r.(*io.LimitedReader).N)
		tmpExtendedCommunities := make([]byte, len_ExtendedCommunities)
		n_ExtendedCommunities, err := io.ReadFull(r, tmpExtendedCommunities[:])
		if err != nil {
			return fmt.Errorf("read ExtendedCommunities: expect %d bytes but read %d bytes: %w", len_ExtendedCommunities, n_ExtendedCommunities, err)
		}
		range_tmp_ExtendedCommunities := bytes.NewReader(tmpExtendedCommunities[:])
		tmp_old_r_ExtendedCommunities := r
		r = range_tmp_ExtendedCommunities
		for range_tmp_ExtendedCommunities.Len() > 0 {
			var tmp180_ ExtendedCommunity
			if err := tmp180_.Read(r); err != nil {
				return fmt.Errorf("read ExtendedCommunities: %w", err)
			}
			t.union145_.(*union_155_t).ExtendedCommunities = append(t.union145_.(*union_155_t).ExtendedCommunities, tmp180_)
		}
		r = tmp_old_r_ExtendedCommunities
		if sub_byte_r_ExtendedCommunities.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read ExtendedCommunities: expect %d bytes but got %d bytes", sub_byte_len_ExtendedCommunities, sub_byte_len_ExtendedCommunities-sub_byte_r_ExtendedCommunities.(*io.LimitedReader).N)
		}
		r = tmp_old_r_ExtendedCommunities_179
	case (t.Type.Code == AttributeCode_BgpLs):
		t.union145_ = &union_156_t{}
		sub_byte_len_BgpLs := int64(LenTmp)
		sub_byte_r_BgpLs := io.LimitReader(r, int64(sub_byte_len_BgpLs))
		tmp_old_r_BgpLs_181 := r
		r = sub_byte_r_BgpLs
		if err := t.union145_.(*union_156_t).BgpLs.Read(r); err != nil {
			return fmt.Errorf("read BgpLs: %w", err)
		}
		if sub_byte_r_BgpLs.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read BgpLs: expect %d bytes but got %d bytes", sub_byte_len_BgpLs, sub_byte_len_BgpLs-sub_byte_r_BgpLs.(*io.LimitedReader).N)
		}
		r = tmp_old_r_BgpLs_181
	default:
		t.union145_ = &union_157_t{}
		len_Data := int(LenTmp)
		if len_Data != 0 {
			tmpData := make([]byte, len_Data)
			n_Data, err := io.ReadFull(r, tmpData[:])
			if err != nil {
				return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
			}
			t.union145_.(*union_157_t).Data = tmpData[:]
		} else {
			t.union145_.(*union_157_t).Data = nil
		}
	}
	return nil
}

func (t *PathAttribute) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *PathAttribute) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode PathAttribute: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *PathAttributes) Visit(v VisitorPRAYV) {
	v.Visit(v, "Len", &t.Len)
	v.Visit(v, "Data", &t.Data)
}
func (t *PathAttributes) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *PathAttributes) Write(w io.Writer) (err error) {
	tmp182 := [2]byte{}
	binary.BigEndian.PutUint16(tmp182[:], uint16(t.Len))
	if n, err := w.Write(tmp182[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Len: %w", err)
	}
	new_buf_183 := bytes.NewBuffer(nil)
	old_buf_183_w := w
	w = new_buf_183
	for _, v := range t.Data {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Data: %w", err)
		}
	}
	if new_buf_183.Len() != int(t.Len) {
		return fmt.Errorf("encode Data: expect %d bytes but got %d bytes", new_buf_183.Len(), int(t.Len))
	}
	_, err = new_buf_183.WriteTo(old_buf_183_w)
	if err != nil {
		return err
	}
	w = old_buf_183_w
	return nil
}
func (t *PathAttributes) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 2))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *PathAttributes) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *PathAttributes) Read(r io.Reader) (err error) {
	tmpLen := [2]byte{}
	n_Len, err := io.ReadFull(r, tmpLen[:])
	if err != nil {
		return fmt.Errorf("read Len: expect 2 bytes but read %d bytes: %w", n_Len, err)
	}
	t.Len = uint16(binary.BigEndian.Uint16(tmpLen[:]))
	sub_byte_len_Data := int64(t.Len)
	sub_byte_r_Data := io.LimitReader(r, int64(sub_byte_len_Data))
	tmp_old_r_Data_184 := r
	r = sub_byte_r_Data
	len_Data := int(r.(*io.LimitedReader).N)
	tmpData := make([]byte, len_Data)
	n_Data, err := io.ReadFull(r, tmpData[:])
	if err != nil {
		return fmt.Errorf("read Data: expect %d bytes but read %d bytes: %w", len_Data, n_Data, err)
	}
	range_tmp_Data := bytes.NewReader(tmpData[:])
	tmp_old_r_Data := r
	r = range_tmp_Data
	for range_tmp_Data.Len() > 0 {
		var tmp185_ PathAttribute
		if err := tmp185_.Read(r); err != nil {
			return fmt.Errorf("read Data: %w", err)
		}
		t.Data = append(t.Data, tmp185_)
	}
	r = tmp_old_r_Data
	if sub_byte_r_Data.(*io.LimitedReader).N != 0 {
		return fmt.Errorf("read Data: expect %d bytes but got %d bytes", sub_byte_len_Data, sub_byte_len_Data-sub_byte_r_Data.(*io.LimitedReader).N)
	}
	r = tmp_old_r_Data_184
	return nil
}

func (t *PathAttributes) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *PathAttributes) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode PathAttributes: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *OpaqueNode) Visit(v VisitorPRAYV) {
	v.Visit(v, "NodeAttributes", &t.NodeAttributes)
}
func (t *OpaqueNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *OpaqueNode) Write(w io.Writer) (err error) {
	for _, v := range t.NodeAttributes {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode NodeAttributes: %w", err)
		}
	}
	return nil
}
func (t *OpaqueNode) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *OpaqueNode) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *OpaqueNode) Read(r io.Reader) (err error) {
	tmp_byte_scanner186_ := bufio.NewReaderSize(r, 1)
	old_r_NodeAttributes := r
	r = tmp_byte_scanner186_
	for {
		_, err := tmp_byte_scanner186_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read NodeAttributes: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner186_.UnreadByte(); err != nil {
			return fmt.Errorf("read NodeAttributes: unexpected unread error: %w", err)
		}
		var tmp187_ Lstlv
		if err := tmp187_.Read(r); err != nil {
			return fmt.Errorf("read NodeAttributes: %w", err)
		}
		t.NodeAttributes = append(t.NodeAttributes, tmp187_)
	}
	r = old_r_NodeAttributes
	return nil
}

func (t *OpaqueNode) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *OpaqueNode) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode OpaqueNode: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *OpaqueLink) Visit(v VisitorPRAYV) {
	v.Visit(v, "LinkAttributes", &t.LinkAttributes)
}
func (t *OpaqueLink) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *OpaqueLink) Write(w io.Writer) (err error) {
	for _, v := range t.LinkAttributes {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode LinkAttributes: %w", err)
		}
	}
	return nil
}
func (t *OpaqueLink) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *OpaqueLink) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *OpaqueLink) Read(r io.Reader) (err error) {
	tmp_byte_scanner188_ := bufio.NewReaderSize(r, 1)
	old_r_LinkAttributes := r
	r = tmp_byte_scanner188_
	for {
		_, err := tmp_byte_scanner188_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read LinkAttributes: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner188_.UnreadByte(); err != nil {
			return fmt.Errorf("read LinkAttributes: unexpected unread error: %w", err)
		}
		var tmp189_ Lstlv
		if err := tmp189_.Read(r); err != nil {
			return fmt.Errorf("read LinkAttributes: %w", err)
		}
		t.LinkAttributes = append(t.LinkAttributes, tmp189_)
	}
	r = old_r_LinkAttributes
	return nil
}

func (t *OpaqueLink) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *OpaqueLink) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode OpaqueLink: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *CandidatePathDescriptors) Visit(v VisitorPRAYV) {
	v.Visit(v, "Descriptor", &t.Descriptor)
}
func (t *CandidatePathDescriptors) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *CandidatePathDescriptors) Write(w io.Writer) (err error) {
	for _, v := range t.Descriptor {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode Descriptor: %w", err)
		}
	}
	return nil
}
func (t *CandidatePathDescriptors) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *CandidatePathDescriptors) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *CandidatePathDescriptors) Read(r io.Reader) (err error) {
	tmp_byte_scanner190_ := bufio.NewReaderSize(r, 1)
	old_r_Descriptor := r
	r = tmp_byte_scanner190_
	for {
		_, err := tmp_byte_scanner190_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read Descriptor: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner190_.UnreadByte(); err != nil {
			return fmt.Errorf("read Descriptor: unexpected unread error: %w", err)
		}
		var tmp191_ CandidatePathDescriptorSubTlv
		if err := tmp191_.Read(r); err != nil {
			return fmt.Errorf("read Descriptor: %w", err)
		}
		t.Descriptor = append(t.Descriptor, tmp191_)
	}
	r = old_r_Descriptor
	return nil
}

func (t *CandidatePathDescriptors) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *CandidatePathDescriptors) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode CandidatePathDescriptors: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *Srv6BindingSid) Allocation() bool {
	return ((t.flags192 & 0x8000) >> 15) == 1
}
func (t *Srv6BindingSid) SetAllocation(v bool) {
	if v {
		t.flags192 |= uint16(0x8000)
	} else {
		t.flags192 &= ^uint16(0x8000)
	}
}
func (t *Srv6BindingSid) Unavailable() bool {
	return ((t.flags192 & 0x4000) >> 14) == 1
}
func (t *Srv6BindingSid) SetUnavailable(v bool) {
	if v {
		t.flags192 |= uint16(0x4000)
	} else {
		t.flags192 &= ^uint16(0x4000)
	}
}
func (t *Srv6BindingSid) Fallback() bool {
	return ((t.flags192 & 0x2000) >> 13) == 1
}
func (t *Srv6BindingSid) SetFallback(v bool) {
	if v {
		t.flags192 |= uint16(0x2000)
	} else {
		t.flags192 &= ^uint16(0x2000)
	}
}
func (t *Srv6BindingSid) Reserved1() uint16 {
	return ((t.flags192 & 0x1fff) >> 0)
}
func (t *Srv6BindingSid) SetReserved1(v uint16) bool {
	if v > 8191 {
		return false
	}
	t.flags192 = (t.flags192 & ^uint16(0x1fff)) | ((v & 0x1fff) << 0)
	return true
}
func (t *Srv6BindingSid) Visit(v VisitorPRAYV) {
	v.Visit(v, "Allocation", (func() uint16 {
		if t.Allocation() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Unavailable", (func() uint16 {
		if t.Unavailable() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Fallback", (func() uint16 {
		if t.Fallback() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved1", t.Reserved1())
	v.Visit(v, "Reserved2", &t.Reserved2)
	v.Visit(v, "BindingSid", &t.BindingSid)
	v.Visit(v, "SpecifiedBindingSid", &t.SpecifiedBindingSid)
	v.Visit(v, "SubTlvs", &t.SubTlvs)
}
func (t *Srv6BindingSid) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *Srv6BindingSid) Write(w io.Writer) (err error) {
	tmp193 := [2]byte{}
	binary.BigEndian.PutUint16(tmp193[:], uint16(t.flags192))
	if n, err := w.Write(tmp193[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.flags192: %w", err)
	}
	tmp194 := [2]byte{}
	binary.BigEndian.PutUint16(tmp194[:], uint16(t.Reserved2))
	if n, err := w.Write(tmp194[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Reserved2: %w", err)
	}
	if n, err := w.Write(t.BindingSid[:]); err != nil || n != len(t.BindingSid) {
		return fmt.Errorf("encode BindingSid: %w", err)
	}
	if n, err := w.Write(t.SpecifiedBindingSid[:]); err != nil || n != len(t.SpecifiedBindingSid) {
		return fmt.Errorf("encode SpecifiedBindingSid: %w", err)
	}
	for _, v := range t.SubTlvs {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode SubTlvs: %w", err)
		}
	}
	return nil
}
func (t *Srv6BindingSid) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 36))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Srv6BindingSid) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Srv6BindingSid) Read(r io.Reader) (err error) {
	tmpflags192 := [2]byte{}
	n_flags192, err := io.ReadFull(r, tmpflags192[:])
	if err != nil {
		return fmt.Errorf("read flags192: expect 2 bytes but read %d bytes: %w", n_flags192, err)
	}
	t.flags192 = uint16(binary.BigEndian.Uint16(tmpflags192[:]))
	tmpReserved2 := [2]byte{}
	n_Reserved2, err := io.ReadFull(r, tmpReserved2[:])
	if err != nil {
		return fmt.Errorf("read Reserved2: expect 2 bytes but read %d bytes: %w", n_Reserved2, err)
	}
	t.Reserved2 = uint16(binary.BigEndian.Uint16(tmpReserved2[:]))
	n_BindingSid, err := io.ReadFull(r, t.BindingSid[:])
	if err != nil {
		return fmt.Errorf("read BindingSid: expect %d bytes but read %d bytes: %w", 16, n_BindingSid, err)
	}
	n_SpecifiedBindingSid, err := io.ReadFull(r, t.SpecifiedBindingSid[:])
	if err != nil {
		return fmt.Errorf("read SpecifiedBindingSid: expect %d bytes but read %d bytes: %w", 16, n_SpecifiedBindingSid, err)
	}
	tmp_byte_scanner195_ := bufio.NewReaderSize(r, 1)
	old_r_SubTlvs := r
	r = tmp_byte_scanner195_
	for {
		_, err := tmp_byte_scanner195_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read SubTlvs: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner195_.UnreadByte(); err != nil {
			return fmt.Errorf("read SubTlvs: unexpected unread error: %w", err)
		}
		var tmp196_ Srv6BindingSidsubTlv
		if err := tmp196_.Read(r); err != nil {
			return fmt.Errorf("read SubTlvs: %w", err)
		}
		t.SubTlvs = append(t.SubTlvs, tmp196_)
	}
	r = old_r_SubTlvs
	return nil
}

func (t *Srv6BindingSid) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Srv6BindingSid) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Srv6BindingSid: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SrcandidateConstraints) UseSrv6DataPlane() bool {
	return ((t.flags197 & 0x80) >> 7) == 1
}
func (t *SrcandidateConstraints) SetUseSrv6DataPlane(v bool) {
	if v {
		t.flags197 |= uint8(0x80)
	} else {
		t.flags197 &= ^uint8(0x80)
	}
}
func (t *SrcandidateConstraints) OnlyProtectedSids() bool {
	return ((t.flags197 & 0x40) >> 6) == 1
}
func (t *SrcandidateConstraints) SetOnlyProtectedSids(v bool) {
	if v {
		t.flags197 |= uint8(0x40)
	} else {
		t.flags197 &= ^uint8(0x40)
	}
}
func (t *SrcandidateConstraints) OnlyUnprotectedSids() bool {
	return ((t.flags197 & 0x20) >> 5) == 1
}
func (t *SrcandidateConstraints) SetOnlyUnprotectedSids(v bool) {
	if v {
		t.flags197 |= uint8(0x20)
	} else {
		t.flags197 &= ^uint8(0x20)
	}
}
func (t *SrcandidateConstraints) OnlyUseSpecifiedAlgorithm() bool {
	return ((t.flags197 & 0x10) >> 4) == 1
}
func (t *SrcandidateConstraints) SetOnlyUseSpecifiedAlgorithm(v bool) {
	if v {
		t.flags197 |= uint8(0x10)
	} else {
		t.flags197 &= ^uint8(0x10)
	}
}
func (t *SrcandidateConstraints) OnlyUseSpecifiedTopology() bool {
	return ((t.flags197 & 0x08) >> 3) == 1
}
func (t *SrcandidateConstraints) SetOnlyUseSpecifiedTopology(v bool) {
	if v {
		t.flags197 |= uint8(0x8)
	} else {
		t.flags197 &= ^uint8(0x8)
	}
}
func (t *SrcandidateConstraints) StrictConstraints() bool {
	return ((t.flags197 & 0x04) >> 2) == 1
}
func (t *SrcandidateConstraints) SetStrictConstraints(v bool) {
	if v {
		t.flags197 |= uint8(0x4)
	} else {
		t.flags197 &= ^uint8(0x4)
	}
}
func (t *SrcandidateConstraints) Fixed() bool {
	return ((t.flags197 & 0x02) >> 1) == 1
}
func (t *SrcandidateConstraints) SetFixed(v bool) {
	if v {
		t.flags197 |= uint8(0x2)
	} else {
		t.flags197 &= ^uint8(0x2)
	}
}
func (t *SrcandidateConstraints) HopByHop() bool {
	return ((t.flags197 & 0x01) >> 0) == 1
}
func (t *SrcandidateConstraints) SetHopByHop(v bool) {
	if v {
		t.flags197 |= uint8(0x1)
	} else {
		t.flags197 &= ^uint8(0x1)
	}
}
func (t *SrcandidateConstraints) Visit(v VisitorPRAYV) {
	v.Visit(v, "UseSrv6DataPlane", (func() uint8 {
		if t.UseSrv6DataPlane() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "OnlyProtectedSids", (func() uint8 {
		if t.OnlyProtectedSids() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "OnlyUnprotectedSids", (func() uint8 {
		if t.OnlyUnprotectedSids() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "OnlyUseSpecifiedAlgorithm", (func() uint8 {
		if t.OnlyUseSpecifiedAlgorithm() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "OnlyUseSpecifiedTopology", (func() uint8 {
		if t.OnlyUseSpecifiedTopology() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "StrictConstraints", (func() uint8 {
		if t.StrictConstraints() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Fixed", (func() uint8 {
		if t.Fixed() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "HopByHop", (func() uint8 {
		if t.HopByHop() {
			return 1
		} else {
			return 0
		}
	}()))
	v.Visit(v, "Reserved1", &t.Reserved1)
	v.Visit(v, "Reserved2", &t.Reserved2)
	v.Visit(v, "Mtid", &t.Mtid)
	v.Visit(v, "Algorithm", &t.Algorithm)
	v.Visit(v, "Reserved3", &t.Reserved3)
	v.Visit(v, "SubTlvs", &t.SubTlvs)
}
func (t *SrcandidateConstraints) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *SrcandidateConstraints) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.flags197)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.flags197: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Reserved1)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Reserved1: %w", err)
	}
	tmp198 := [2]byte{}
	binary.BigEndian.PutUint16(tmp198[:], uint16(t.Reserved2))
	if n, err := w.Write(tmp198[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Reserved2: %w", err)
	}
	tmp199 := [2]byte{}
	binary.BigEndian.PutUint16(tmp199[:], uint16(t.Mtid))
	if n, err := w.Write(tmp199[:]); err != nil || n != 2 {
		return fmt.Errorf("encode t.Mtid: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Algorithm)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Algorithm: %w", err)
	}
	if n, err := w.Write([]byte{byte(t.Reserved3)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.Reserved3: %w", err)
	}
	for _, v := range t.SubTlvs {
		if err := v.Write(w); err != nil {
			return fmt.Errorf("encode SubTlvs: %w", err)
		}
	}
	return nil
}
func (t *SrcandidateConstraints) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 8))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SrcandidateConstraints) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SrcandidateConstraints) Read(r io.Reader) (err error) {
	tmpflags197 := [1]byte{}
	n_flags197, err := io.ReadFull(r, tmpflags197[:])
	if err != nil {
		return fmt.Errorf("read flags197: expect 1 byte but read %d bytes: %w", n_flags197, err)
	}
	t.flags197 = uint8(tmpflags197[0])
	tmpReserved1 := [1]byte{}
	n_Reserved1, err := io.ReadFull(r, tmpReserved1[:])
	if err != nil {
		return fmt.Errorf("read Reserved1: expect 1 byte but read %d bytes: %w", n_Reserved1, err)
	}
	t.Reserved1 = uint8(tmpReserved1[0])
	tmpReserved2 := [2]byte{}
	n_Reserved2, err := io.ReadFull(r, tmpReserved2[:])
	if err != nil {
		return fmt.Errorf("read Reserved2: expect 2 bytes but read %d bytes: %w", n_Reserved2, err)
	}
	t.Reserved2 = uint16(binary.BigEndian.Uint16(tmpReserved2[:]))
	tmpMtid := [2]byte{}
	n_Mtid, err := io.ReadFull(r, tmpMtid[:])
	if err != nil {
		return fmt.Errorf("read Mtid: expect 2 bytes but read %d bytes: %w", n_Mtid, err)
	}
	t.Mtid = uint16(binary.BigEndian.Uint16(tmpMtid[:]))
	tmpAlgorithm := [1]byte{}
	n_Algorithm, err := io.ReadFull(r, tmpAlgorithm[:])
	if err != nil {
		return fmt.Errorf("read Algorithm: expect 1 byte but read %d bytes: %w", n_Algorithm, err)
	}
	t.Algorithm = uint8(tmpAlgorithm[0])
	tmpReserved3 := [1]byte{}
	n_Reserved3, err := io.ReadFull(r, tmpReserved3[:])
	if err != nil {
		return fmt.Errorf("read Reserved3: expect 1 byte but read %d bytes: %w", n_Reserved3, err)
	}
	t.Reserved3 = uint8(tmpReserved3[0])
	tmp_byte_scanner200_ := bufio.NewReaderSize(r, 1)
	old_r_SubTlvs := r
	r = tmp_byte_scanner200_
	for {
		_, err := tmp_byte_scanner200_.ReadByte()
		if err != nil {
			if err != io.EOF {
				return fmt.Errorf("read SubTlvs: %w", err)
			}
			break
		}
		if err := tmp_byte_scanner200_.UnreadByte(); err != nil {
			return fmt.Errorf("read SubTlvs: unexpected unread error: %w", err)
		}
		var tmp201_ SrcandidateConstraintsSubTlv
		if err := tmp201_.Read(r); err != nil {
			return fmt.Errorf("read SubTlvs: %w", err)
		}
		t.SubTlvs = append(t.SubTlvs, tmp201_)
	}
	r = old_r_SubTlvs
	return nil
}

func (t *SrcandidateConstraints) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SrcandidateConstraints) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SrcandidateConstraints: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *SrpolicyCandidatePathNlri) Visit(v VisitorPRAYV) {
	v.Visit(v, "ProtocolId", &t.ProtocolId)
	v.Visit(v, "Identifier", &t.Identifier)
	v.Visit(v, "LocalNodeDescriptors", &t.LocalNodeDescriptors)
	v.Visit(v, "CandidatePathDescriptors", &t.CandidatePathDescriptors)
}
func (t *SrpolicyCandidatePathNlri) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *SrpolicyCandidatePathNlri) Write(w io.Writer) (err error) {
	if n, err := w.Write([]byte{byte(t.ProtocolId)}); err != nil || n != 1 {
		return fmt.Errorf("encode t.ProtocolId: %w", err)
	}
	tmp202 := [8]byte{}
	binary.BigEndian.PutUint64(tmp202[:], uint64(t.Identifier))
	if n, err := w.Write(tmp202[:]); err != nil || n != 8 {
		return fmt.Errorf("encode t.Identifier: %w", err)
	}
	if err := t.LocalNodeDescriptors.Write(w); err != nil {
		return fmt.Errorf("encode LocalNodeDescriptors: %w", err)
	}
	if err := t.CandidatePathDescriptors.Write(w); err != nil {
		return fmt.Errorf("encode CandidatePathDescriptors: %w", err)
	}
	return nil
}
func (t *SrpolicyCandidatePathNlri) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 9))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *SrpolicyCandidatePathNlri) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *SrpolicyCandidatePathNlri) Read(r io.Reader) (err error) {
	tmpProtocolId := [1]byte{}
	n_ProtocolId, err := io.ReadFull(r, tmpProtocolId[:])
	if err != nil {
		return fmt.Errorf("read ProtocolId: expect 1 byte but read %d bytes: %w", n_ProtocolId, err)
	}
	t.ProtocolId = uint8(tmpProtocolId[0])
	tmpIdentifier := [8]byte{}
	n_Identifier, err := io.ReadFull(r, tmpIdentifier[:])
	if err != nil {
		return fmt.Errorf("read Identifier: expect 8 bytes but read %d bytes: %w", n_Identifier, err)
	}
	t.Identifier = uint64(binary.BigEndian.Uint64(tmpIdentifier[:]))
	if err := t.LocalNodeDescriptors.Read(r); err != nil {
		return fmt.Errorf("read LocalNodeDescriptors: %w", err)
	}
	if err := t.CandidatePathDescriptors.Read(r); err != nil {
		return fmt.Errorf("read CandidatePathDescriptors: %w", err)
	}
	return nil
}

func (t *SrpolicyCandidatePathNlri) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *SrpolicyCandidatePathNlri) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode SrpolicyCandidatePathNlri: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_205_t) isunion203_() {}
func (t *Update) NetworkReachabilityInfo() *[]NetWorkReachabilityInfo {
	if true == (t.PathAttr.Len > 0) {
		if _, ok := t.union203_.(*union_205_t); !ok {
			return nil // not set
		}
		tmp := []NetWorkReachabilityInfo(t.union203_.(*union_205_t).NetworkReachabilityInfo)
		return &tmp
	}
	return nil
}
func (t *Update) SetNetworkReachabilityInfo(v []NetWorkReachabilityInfo) bool {
	if true == (t.PathAttr.Len > 0) {
		if _, ok := t.union203_.(*union_205_t); !ok {
			t.union203_ = &union_205_t{}
		}
		t.union203_.(*union_205_t).NetworkReachabilityInfo = []NetWorkReachabilityInfo(v)
		return true
	}
	return false
}
func (t *Update) Visit(v VisitorPRAYV) {
	v.Visit(v, "WithdrawnRoutes", &t.WithdrawnRoutes)
	v.Visit(v, "PathAttr", &t.PathAttr)
	v.Visit(v, "NetworkReachabilityInfo", (t.NetworkReachabilityInfo()))
}
func (t *Update) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *Update) Write(w io.Writer) (err error) {
	if err := t.WithdrawnRoutes.Write(w); err != nil {
		return fmt.Errorf("encode WithdrawnRoutes: %w", err)
	}
	if err := t.PathAttr.Write(w); err != nil {
		return fmt.Errorf("encode PathAttr: %w", err)
	}
	if t.PathAttr.Len > 0 {
		if _, ok := t.union203_.(*union_205_t); !ok {
			return fmt.Errorf("encode t.union203_: union is not set to union_205_t")
		}
		for _, v := range t.union203_.(*union_205_t).NetworkReachabilityInfo {
			if err := v.Write(w); err != nil {
				return fmt.Errorf("encode NetworkReachabilityInfo: %w", err)
			}
		}
	}
	return nil
}
func (t *Update) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 0))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Update) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Update) Read(r io.Reader) (err error) {
	if err := t.WithdrawnRoutes.Read(r); err != nil {
		return fmt.Errorf("read WithdrawnRoutes: %w", err)
	}
	if err := t.PathAttr.Read(r); err != nil {
		return fmt.Errorf("read PathAttr: %w", err)
	}
	if t.PathAttr.Len > 0 {
		t.union203_ = &union_205_t{}
		tmp_byte_scanner206_ := bufio.NewReaderSize(r, 1)
		old_r_NetworkReachabilityInfo := r
		r = tmp_byte_scanner206_
		for {
			_, err := tmp_byte_scanner206_.ReadByte()
			if err != nil {
				if err != io.EOF {
					return fmt.Errorf("read NetworkReachabilityInfo: %w", err)
				}
				break
			}
			if err := tmp_byte_scanner206_.UnreadByte(); err != nil {
				return fmt.Errorf("read NetworkReachabilityInfo: unexpected unread error: %w", err)
			}
			var tmp207_ NetWorkReachabilityInfo
			if err := tmp207_.Read(r); err != nil {
				return fmt.Errorf("read NetworkReachabilityInfo: %w", err)
			}
			t.union203_.(*union_205_t).NetworkReachabilityInfo = append(t.union203_.(*union_205_t).NetworkReachabilityInfo, tmp207_)
		}
		r = old_r_NetworkReachabilityInfo
	}
	return nil
}

func (t *Update) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Update) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Update: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
func (t *union_210_t) isunion208_() {}
func (t *union_211_t) isunion208_() {}
func (t *union_212_t) isunion208_() {}
func (t *union_213_t) isunion208_() {}
func (t *Bgppacket) Notification() *Notification {
	if t.Header.Type == Bgptype_Open {
		return nil
	} else if t.Header.Type == Bgptype_Update {
		return nil
	} else if t.Header.Type == Bgptype_Notification {
		if _, ok := t.union208_.(*union_212_t); !ok {
			return nil // not set
		}
		tmp := Notification(t.union208_.(*union_212_t).Notification)
		return &tmp
	}
	return nil
}
func (t *Bgppacket) SetNotification(v Notification) bool {
	if t.Header.Type == Bgptype_Open {
		return false
	} else if t.Header.Type == Bgptype_Update {
		return false
	} else if t.Header.Type == Bgptype_Notification {
		if _, ok := t.union208_.(*union_212_t); !ok {
			t.union208_ = &union_212_t{}
		}
		t.union208_.(*union_212_t).Notification = Notification(v)
		return true
	}
	return false
}
func (t *Bgppacket) Open() *Open {
	if t.Header.Type == Bgptype_Open {
		if _, ok := t.union208_.(*union_210_t); !ok {
			return nil // not set
		}
		tmp := Open(t.union208_.(*union_210_t).Open)
		return &tmp
	}
	return nil
}
func (t *Bgppacket) SetOpen(v Open) bool {
	if t.Header.Type == Bgptype_Open {
		if _, ok := t.union208_.(*union_210_t); !ok {
			t.union208_ = &union_210_t{}
		}
		t.union208_.(*union_210_t).Open = Open(v)
		return true
	}
	return false
}
func (t *Bgppacket) Update() *Update {
	if t.Header.Type == Bgptype_Open {
		return nil
	} else if t.Header.Type == Bgptype_Update {
		if _, ok := t.union208_.(*union_211_t); !ok {
			return nil // not set
		}
		tmp := Update(t.union208_.(*union_211_t).Update)
		return &tmp
	}
	return nil
}
func (t *Bgppacket) SetUpdate(v Update) bool {
	if t.Header.Type == Bgptype_Open {
		return false
	} else if t.Header.Type == Bgptype_Update {
		if _, ok := t.union208_.(*union_211_t); !ok {
			t.union208_ = &union_211_t{}
		}
		t.union208_.(*union_211_t).Update = Update(v)
		return true
	}
	return false
}
func (t *Bgppacket) Visit(v VisitorPRAYV) {
	v.Visit(v, "Header", &t.Header)
	v.Visit(v, "Notification", (t.Notification()))
	v.Visit(v, "Open", (t.Open()))
	v.Visit(v, "Update", (t.Update()))
}
func (t *Bgppacket) MarshalJSON() ([]byte, error) {
	return json.Marshal(VisitorPRAYVToMap(t))
}
func (t *Bgppacket) Write(w io.Writer) (err error) {
	if err := t.Header.Write(w); err != nil {
		return fmt.Errorf("encode Header: %w", err)
	}
	switch {
	case (t.Header.Type == Bgptype_Open):
		if _, ok := t.union208_.(*union_210_t); !ok {
			return fmt.Errorf("encode t.union208_: union is not set to union_210_t")
		}
		new_buf_214 := bytes.NewBuffer(nil)
		old_buf_214_w := w
		w = new_buf_214
		if err := t.union208_.(*union_210_t).Open.Write(w); err != nil {
			return fmt.Errorf("encode Open: %w", err)
		}
		if new_buf_214.Len() != int((t.Header.Length - 19)) {
			return fmt.Errorf("encode Open: expect %d bytes but got %d bytes", new_buf_214.Len(), int((t.Header.Length - 19)))
		}
		_, err = new_buf_214.WriteTo(old_buf_214_w)
		if err != nil {
			return err
		}
		w = old_buf_214_w
	case (t.Header.Type == Bgptype_Update):
		if _, ok := t.union208_.(*union_211_t); !ok {
			return fmt.Errorf("encode t.union208_: union is not set to union_211_t")
		}
		new_buf_215 := bytes.NewBuffer(nil)
		old_buf_215_w := w
		w = new_buf_215
		if err := t.union208_.(*union_211_t).Update.Write(w); err != nil {
			return fmt.Errorf("encode Update: %w", err)
		}
		if new_buf_215.Len() != int((t.Header.Length - 19)) {
			return fmt.Errorf("encode Update: expect %d bytes but got %d bytes", new_buf_215.Len(), int((t.Header.Length - 19)))
		}
		_, err = new_buf_215.WriteTo(old_buf_215_w)
		if err != nil {
			return err
		}
		w = old_buf_215_w
	case (t.Header.Type == Bgptype_Notification):
		if _, ok := t.union208_.(*union_212_t); !ok {
			return fmt.Errorf("encode t.union208_: union is not set to union_212_t")
		}
		new_buf_216 := bytes.NewBuffer(nil)
		old_buf_216_w := w
		w = new_buf_216
		if err := t.union208_.(*union_212_t).Notification.Write(w); err != nil {
			return fmt.Errorf("encode Notification: %w", err)
		}
		if new_buf_216.Len() != int((t.Header.Length - 19)) {
			return fmt.Errorf("encode Notification: expect %d bytes but got %d bytes", new_buf_216.Len(), int((t.Header.Length - 19)))
		}
		_, err = new_buf_216.WriteTo(old_buf_216_w)
		if err != nil {
			return err
		}
		w = old_buf_216_w
	case (t.Header.Type == Bgptype_Keepalive):
	}
	return nil
}
func (t *Bgppacket) Encode() ([]byte, error) {
	w := bytes.NewBuffer(make([]byte, 0, 19))
	if err := t.Write(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}
func (t *Bgppacket) MustEncode() []byte {
	buf, err := t.Encode()
	if err != nil {
		panic(err)
	}
	return buf
}
func (t *Bgppacket) Read(r io.Reader) (err error) {
	if err := t.Header.Read(r); err != nil {
		return fmt.Errorf("read Header: %w", err)
	}
	switch {
	case (t.Header.Type == Bgptype_Open):
		t.union208_ = &union_210_t{}
		sub_byte_len_Open := int64((t.Header.Length - 19))
		sub_byte_r_Open := io.LimitReader(r, int64(sub_byte_len_Open))
		tmp_old_r_Open_217 := r
		r = sub_byte_r_Open
		if err := t.union208_.(*union_210_t).Open.Read(r); err != nil {
			return fmt.Errorf("read Open: %w", err)
		}
		if sub_byte_r_Open.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Open: expect %d bytes but got %d bytes", sub_byte_len_Open, sub_byte_len_Open-sub_byte_r_Open.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Open_217
	case (t.Header.Type == Bgptype_Update):
		t.union208_ = &union_211_t{}
		sub_byte_len_Update := int64((t.Header.Length - 19))
		sub_byte_r_Update := io.LimitReader(r, int64(sub_byte_len_Update))
		tmp_old_r_Update_218 := r
		r = sub_byte_r_Update
		if err := t.union208_.(*union_211_t).Update.Read(r); err != nil {
			return fmt.Errorf("read Update: %w", err)
		}
		if sub_byte_r_Update.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Update: expect %d bytes but got %d bytes", sub_byte_len_Update, sub_byte_len_Update-sub_byte_r_Update.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Update_218
	case (t.Header.Type == Bgptype_Notification):
		t.union208_ = &union_212_t{}
		sub_byte_len_Notification := int64((t.Header.Length - 19))
		sub_byte_r_Notification := io.LimitReader(r, int64(sub_byte_len_Notification))
		tmp_old_r_Notification_219 := r
		r = sub_byte_r_Notification
		if err := t.union208_.(*union_212_t).Notification.Read(r); err != nil {
			return fmt.Errorf("read Notification: %w", err)
		}
		if sub_byte_r_Notification.(*io.LimitedReader).N != 0 {
			return fmt.Errorf("read Notification: expect %d bytes but got %d bytes", sub_byte_len_Notification, sub_byte_len_Notification-sub_byte_r_Notification.(*io.LimitedReader).N)
		}
		r = tmp_old_r_Notification_219
	case (t.Header.Type == Bgptype_Keepalive):
	}
	return nil
}

func (t *Bgppacket) Decode(d []byte) (int, error) {
	r := bytes.NewReader(d)
	err := t.Read(r)
	return int(int(r.Size()) - r.Len()), err
}
func (t *Bgppacket) DecodeExact(d []byte) error {
	if n, err := t.Decode(d); err != nil {
		return err
	} else if n != len(d) {
		return fmt.Errorf("decode Bgppacket: expect %d bytes but got %d bytes", len(d), n)
	}
	return nil
}
